{
  "series": "Request for Comments",
  "number": "129",
  "howpublished": "RFC 129",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0129",
  "url": "https://www.rfc-editor.org/info/rfc129",
  "title": "Request for comments on socket name structure",
  "pagetotal": "6",
  "year": "1971",
  "month": "apr",
  "day": "1",
  "body": "\n\n\n\n\n\nNetwork Working Group                         22 April 1971\nRequest for Comments:  129               E. E. Harslem-Rand\nNIC 5845                                 J. F. Heafner-Rand\n                                         E.    Meyer-MIT\n\n                       A REQUEST FOR COMMENTS ON\n                         SOCKET NAME STRUCTURE\n\nINTRODUCTION\n\n     This RFC is in answer to a request (made at the\nFebruary NWG Meeting at the University of Illinois) that\nwe comment on several suggested socket name structures.\nWe apologize for the delay in getting out these comments\nand we hope that you will respond more quickly with your\nreactions.\n     Please direct your replies via the standard RFC\nmechanism.\n     Two structures are presented in this RFC as shown\nbelow.\n\n                        31                 1\n          +-------------------------------+-+\n     1.   |         Arbitrary             | | \u003c-- gender\n          +-------------------------------+-+\n\n                        24             7   1\n          +------------------------+------+-+\n     2.   |        User ID         | tag  | | \u003c-- gender\n          +------------------------+------+-+\n\n     Three variations are given for the way in which\nsocket names are assigned, as examples of use of the\nfirst structure.\n     1.   Users pick the arbitrary number arbitrarily\n          and associate it with a process.\n     2.   A logger chooses the arbitrary number dynamically\n          and associates it with a process via a directory.\n     3.   The arbitrary number is assigned outside of a\n          logger but may be issued by a logger to the\n          remote party.\n\n\n\n\n\n\n\n\n\n\n                                                                [Page 1]\n\f\nThe second format shown above associates sockets specifi-\ncally with users as opposed to processes.\n     The following discussion covers three different schemes\nof socket identifier assignment using a simple example.\nUser A at Host A has agreed (by letter, telephone, etc.)\nwith User B at Host B for their respective processes to\nestablish a connection through the Network at a particular\ntime.  User B is to be waiting for the connection attempt\ninitiated by User A.  The issues to be faced are those of\naddressing (how is User A to know to which socket to connect?),\nand of security (how are both users to be confident that\nthey are talking each other, and not some interloper?).\n     A fourth scheme follows which addresses another concept\nof Network use--that connections are made between processes\nand that processes not users should be identified via\nSocket names.\n\nFREELY SELECTED RANDOM SOCKET IDENTIFIERS (Scheme 1)\n\n     Under this scheme a user is able to use any 32-bit\nsocket identifier he chooses.  Two restrictions apply:  the\nleast significant bit denotes the socket's gender (0-read,\n1-write), and no more than one socket bearing a given iden-\ntifier can be active at a host at a time.\n     The two users select suitably random identifiers (\"a\"\nand \"b\").  User A will attempt to activate his socket with\nidentifier \"a\" an connect it to socket \"b\" at Host B.  There\nis the possibility that somebody other than User B has\nactivated socket \"b\" at Host B so that User A will address\nthe wrong  party.  However, the possibility that some other\nuser has accidentally picked this particular identifier is\nreasonably small, since there are about a billion different\nidentifiers.  When the connection request from A gets to\nUser B, he examines the identifier of the calling socket.\nIf for some reasom it is not \"a\" or not from Host A, he\nrejects the request, because it is likely to be from some\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                                [Page 2]\n\f\noutside party.  If the calling socket is named, \"a\" and\nfrom Host A, User B can be reasonably sure that it is from\nUser A.  It is very unlikely that some other party will\naccidentally address socket \"b\" from a socket named \"a\".\n     The advantages of this scheme are:  simplicity and\nreasonable security in a non-malicious environment.  The\ndisadvantages are that there are possibilities from annoy-\ningly unavoidable conflicts with other users and that each\npair of users must conduct a prior confidential private\ncommunication (as opposed to a broadcast announcement in\nmore secure schemes).\n\nHOST-SELECTED IDENTIFIERS PLUS DIRECTORY (Scheme 2)\n\n     This system uses the same socket identifier structure\nas presented above, except that the Host picks the identi-\nfier at the time the socket is assigned, and the user has no\nno prior knowledge or control of the assignment.  By itself,\nthis system would be totally unusable, because there would\nbe no way for User A to address User B.  However, it allows\ncertain service functions (such as the Network logger) to\nhave specifically assigned sockets.\n     One of these is a Network Directory service.  This\nserves to relate a socket identifier at a particular host\nto the name of the user operating it.  This might either\nbe a single distributed service, or there might be a separ-\nate service at each host.\n     Under this scheme, each user, A and B, first activates\nhis socket (or somehow gets his host to assign and tell\nhim of a socket identifier).  Then he gets the Directory\nmodule at his host to associate his name with the identi-\nfier of the socket just activated.  Following this, User A\nin some manner gets the Directory Service at Host B to tell\nhim the socket identifier assigned to User B.  Then User A\ndispatches a connection request for this socket.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                                [Page 3]\n\f\nWhen User B gets the request, he similarly calls on the\nDirectory service at Host A to find out the name of the user\nwho is operating the socket User B was called by.  If the\nname is that of User A, User B can safely accept the request.\nOtherwise, he rejects.\n     This scheme is rather cumbersome, but some directory\nservices must exist for Host-selected socket identifiers to\nwork.  On advantage of the Directory Service is thst it\nallows symbolic addressing.  A sizeable disadvantage in view\nof its complexity is that it does not provide absolute\nsecurity.  (For exemple, after User A gets the identifier\nof the socket he is to address, User B could deactivate it,\nand somebody else could come along and get the same-named\nsocket.)\n\nADMINISTRATIVELY ASSIGNED USER IDENTIFIERS (Scheme 3)\n\n     This is the system that is put forth on page 5 of\nProtocol Document 1(8/3/70).  Under it a user is permanently\nassigned a user identifier by his home host.  There is a\nuser identifier subfield within the socket identifier, and a\nuser is permitted by an NCP to operate only those sockets\nbearing his uder identifier.  This gives the user a selec-\ntion of 256 sockets operable by him.\n     In arranging for the connection the two Users A and B\ntell each other their user identifiers (alternatively a user\nID could be read from a directory), and User B specifies\nwhich of his sockets (\"b\") that he will \"listen\" on.  At\nconnection time, User A selects one of his sockets and\nrequests connection for it to socket \"b\" specified by User B.\nBy protocol only User B can operate socket \"b\", so User A\ncan be certain of reaching the right party.\n     When User B receives the connection request, he examines\nthe user identifier subfield of the calling socket identifier.\nIf it is the user identifier of User A, User B accepts the\nconnection request, confident that it is actually User A at\nthe other end.  Otherwise B rejects the request.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                                [Page 4]\n\f\nThe advantages of this scheme are that if both hosts\ninvolved in a connection enforce the user ID assignment,\nthe misconnection aspect of security is solved and there\ncan be no socket naming conflict between users.  Also,\narrangements can be made openly and publicly between many\npotential communicators.  A disadvantage to this scheme is\nthat some systems may be incapable of insuring user ID\nintegrity.\n\nA VIEW OF SOCKET NAME MEANING (Scheme 4)\n\n     Another view of Network use is that programs will con-\nnect to programs, via NCPs.  Some of these programs may be\nmulti-access subsystems that are really agents for local\nconsoles (and TELNETs).  Consoles will generally communicate\nthrough some such software agent rather than directly to\nan NCP.\n     Programs, then, must have a fixed, unique identifier,\nknown to its remote users and perhaps to its local logger.\nThe identifier is constant; it does not change from day to\nday.  If such a program is to allow multiple concurrent\nconnections (for many or a single user) then it must have\na range of variable identifiers as well.  It makes sense\nto group these sockets in a contiguous range.  The variable\nidentifiers are transient and are dynamically associated\nwith Network logical connections.\n\n      +---------------------   ---------------------+\n      |                                           |\n      | Fixed, unique       /  /  Variable          |\n      | Identifier         /  /  Identifier         |\n      |                                           |\n      +---------------------   ---------------------+\n\n      _________  _________/   _________  _________/\n                /                       /\n       Identifies the           Identifies a particular\n       program uniquely         connection of the program\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                                [Page 5]\n\f\nThe above premise is that the program (or agent) is\ndoing the communicating with an NCP and thus needs to be\nidentified for message traffic routing from an NCP.  In\nthe past it has been said that users can be mobile, i.e.,\nlog on from different sites, and thus it is the user that\nneeds identification.  In many typical on-line systems the\nuser first requests a service and then identifies himself\nto the service for purposes of accounting, etc.  User IDs\ncan be transmitted after requesting a service and can thus\nbe elevated above the meaning of socket names.\n     A program might typically associate the terminals, for\nwhich it is an agent, with the variable part of the identi-\nfier, i.e., the particular connection(s).  For example,\nthe Network Services Program (NSP) at Rand now uses the\nfollowing format for socket names.  The first 24 bits are\nadministratively assigned and would be known to a logger.\nThe multiplex code is normally chosen randomly.  Predefined,\nfixed multiplex codes are possible also.\n\n                24                   7     1\n       +------------------------+---------+-+\n       | Program Number         |Multiplex| | \u003c-- Gender\n       |                        |  Code   | |\n       +------------------------+---------+-+\n\n     The Socket name structure #1 (page 1) thus accomodates\nthe above example as well as other exploratory socket name\nstructures and various \"standards\" superimposed on the arbi-\ntrary field.\n\n\n       [ This RFC was put into machine readable form for entry ]\n         [ into the online RFC archives by Simone Demmel 4/97 ]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                                [Page 6]\n\f\n"
}