{
  "series": "Request for Comments",
  "number": "468",
  "howpublished": "RFC 468",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0468",
  "url": "https://www.rfc-editor.org/info/rfc468",
  "title": "FTP data compression",
  "pagetotal": "7",
  "year": "1973",
  "month": "mar",
  "body": "\n\n\n\n\n\nNetwork Working Group                                         R.  Braden\nRequest for Comment: 468                                        UCLA/CCN\nNIC: 14742                                                 March 8, 1973\n\n\n                          FTP DATA COMPRESSION\n\nI.  INTRODUCTION\n\nAPOLOGIA\n\n   Major design objectives of the proposed File Transfer Protocol (FTP)\n   are reliability and efficiency for transmission of large files.\n   Efficiency has two faces: efficiency of the host CPU's, and efficient\n   use of the Network bandwidth.  Block mode is intended to minimize CPU\n   overhead for bandwidth efficiency, there is a mode called \"HASP\" in\n   RFC 454.  The \"HASP\" mode of FTP is really transmission with data\n   compression, i.e., an encoding scheme to reduce the information\n   redundancy in the messages.\n\n   RFC 454 contains no explicit definition of the \"HASP\" or compressed\n   mode, but instead notes that a future RFC by yours truly will define\n   the mode.  Students of FTP may find this scarcely credible, but you\n   are now reading the promised RFC.  It turned out to be much farther\n   in the future than any of us expected.  Mea Culpa.\n\nGENERAL CONSIDERATIONS\n\n   In the early years of the Network, its major uses have been remote\n   terminal interactions and the small-to-medium-sized file transmission\n   typical of remote job entry.  As facilities such as the Illiac IV and\n   the Data Machine become operational on the Network, and the Network\n   community begins to include users with heavy data transmission\n   requirements, large file transmission will become a major mode of\n   Network use.  For example, one user of CCN expects to send 2 x 10**8\n   bits of data _each_ _day_ over the Network.\n\n   Local byte compression of the type proposed here is particular\n   effective for reducing the size of \"printer\" files such as those\n   transmitted under the Network RJE protocol.  Experience with CCN's\n   RJS service has shown a typical compression of print files by a\n   factor of between two and three.  Since FTP was intended to contain\n   the data transfer part of Network RJE protocol as a subset, it is\n   appropriate to include a print file compression mechanism in FTP.\n   These considerations led the FTP committee to include a compressed\n   mode within FTP.\n\n\n\n\n\nBraden                                                          [Page 1]\n\f\nRFC 468                   FTP Data Compression                March 1973\n\n\n   The two main arguments for data compression are economics and\n   convenience (usability).  Consider first economics, which is\n   essentially a trade-off between CPU time and transmission costs.  Of\n   course, as long as Network use is a free commodity, the economics of\n   data compression are all bad.  That happy state won't last forever.\n   What does data compression cost?\n\n   Let us consider only simple linear compression schemes, such as the\n   one proposed here.  By linear, I mean that the CPU time to examine a\n   source record is proportional to number of bytes in the record.  A\n   simple linear scheme could detect repeated single characters, for\n   example.  One could imagine quadratic schemes, which detected\n   repeated substrings; but except for possible special circumstance\n   where the source stings have some structure known to the compression\n   algorithm, the CPU economics don't favor quadratic compression.\n\n   Assuming a reasonable figure for large-scale CPU costs in the\n   generation of CCN's 360/91, we concluded that an upper bound on CPU\n   costs for total compression and decompression would be 5 cents per\n   megabit; this is based on very loose coding of a simple linear\n   algorithm.  This may be compared with the projected Network\n   transmission costs of over 30 cents per megabit (possibly a lot\n   over).\n\n   Thus, the CPU time to conserve bandwidth costs significantly less\n   than the bandwidth saved.  Both CPU costs and bandwidth costs are\n   trending downward, but it seems exceedingly unlikely that the ratio\n   of CPU cost to bandwidth cost for linear compression will reverse in\n   the next few years.  On the other hand, this calculation clearly\n   discourages one from using quadratic compression.\n\nWHY HASP\n\n   CCN's batch remote job entry protocol NETRJS (see RFC #189, July 15,\n   1971) was designed to include two data transfer modes, truncated and\n   compressed.  The NETRJS truncated mode is essentially identical to\n   current FTP block mode record structure (except for minor bit format\n   differences).  The compressed mode of NETRJS uses an adaptation of\n   the particular compression scheme which is incorporated in the\n   \"Multileaving protocol\" of the binary synchronous rje support in\n   IBM's HASP system.\n\n   Although it isn't really necessary for the purpose of defining a\n   compression scheme in FTP, I have included an appendix summarizing\n   very briefly the nature of HASP and its rje package.  That appendix\n   may be considered cultural enrichment for those in the Network\n   Community who have been denied the privilege of being an IBM\n   customer.  After all, I know a lot of HASP experts who never heard of\n\n\n\nBraden                                                          [Page 2]\n\f\nRFC 468                   FTP Data Compression                March 1973\n\n\n   TENEX! More seriously, because HASP is widely used on IBM machines,\n   the HASP compression scheme is also widely used.  In designing\n   NETRJS, we chose the HASP scheme of compression because of its\n   ubiquity and plausibility.\n\n   However, certain details of the HASP bit formats are inappropriate or\n   sub-optimal for FTP.  Therefore, our proposal for compressed mode of\n   FTP is only an adaptation of the HASP compression scheme.\n\n   It should be clear from Appendix A that the compression scheme of\n   HASP, even if used literally, is a very minor and incidental part of\n   that system.  Although we ought to properly credit the intellectual\n   origin of FTP's compressed mode, it seems a little strange to call\n   the compressed mode in FTP the \"HASP mode\".  I trust this will be\n   rectified by the forthcoming FTP meeting.\n\nII.  PROPOSED FTP COMPRESSED DATA MODE\n\n   Byte size is B bits.  Figures above boxes are field lengths in bits.\n\n                                  n bytes of data\n                               /--------/\\--------\\\n              1    B-1        /   B              B \\\n             +---+------+    +--------+     +--------+\nByte String: | 0 |  n   |    |   d    |. . .|   d    |\n             |   |      |    |    1   |     |    n   |\n             +---+------+    +--------+     +--------+\n                  String of n data bytes d(1),...,d(n)\n                  Count n must be positive\n\n                     2     B-2            B\n                   +----+------+    +---------+\nReplicated Byte:   | 1 0|   n  |    |    d    |\n                   +----+------+    +---------+\n                 String consisting of n replications of the data byte d\n\n                     2    B-2\n                  +----+------+\nFiller String:    | 1 1|   n  |\n                  +----+------+\n                 String of n filler bytes.  The filler byte is a \"space\"\n                 character for ASCII or EBCDIC type, or a binary zero\n                 byte for Image or Local Byte Type.\n\n                                B            B\n                          +----------+ +----------+\nControl Escape Sequence:  | 0......0 | |      C   |    (see below)\n                          +----------+ +----------+\n\n\n\nBraden                                                          [Page 3]\n\f\nRFC 468                   FTP Data Compression                March 1973\n\n\n   The control byte \"C\" which is the second byte of a control escape\n   sequence is to have the same coding as the descriptor byte in Block\n   Mode.  This includes end-of-file and end-of-record indications.  I\n   will not specify this further because there is some question at\n   present about the exact coding of the Block Mode descriptor byte.\n\n   Following the example of APL*, we have let the meaning of the filler\n   (blank or 0) be determined by the type: character (ASCII|EBCDIC) vs.\n   binary (Image|Local Byte).  If byte size is equal to the word size of\n   the transmitting host, the compressed mode allows one to send sparse\n   notices with reasonable efficiency.\n\n   * Compare 1 (take) 0 1\\`A' with 1 (take) 0 1\\2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBraden                                                          [Page 4]\n\f\nRFC 468                   FTP Data Compression                March 1973\n\n\nAPPENDIX A: HASP MULTILEAVING\n\n   HASP (Houston Automatic Spooling Program) is a subsystem which\n   essentially runs within OS/360 as a job but takes over the batch\n   processing management functions from the operating system.  That is,\n   HASP handles spooling of card input and printer and punch output,\n   queueing and scheduling of job execution, and the operator control\n   interface.  It is a tightly-written and efficient system for running\n   a large and varied job load through a large-scale machine.  The name\n   results from the historical fact that HASP was originally by a local\n   IBM group for one particular customer, NASA Houston.\n\n   HASP has always been an anomaly in the IBM scheme of things.  The\n   system was written around 1965 by two programmers; the HASP group has\n   probably averaged three programmers during most of its life.  The\n   leader of the group has been \"Mr. HASP\", Tom Simpson.  The HASP\n   system spread rapidly through (more or less) underground channels to\n   many of the medium and large scale 360's.  At least once, only\n   intense customer pressure prevented IBM from killing the HASP effort.\n   HASP generated an astonishing emotional mystique among its users.\n   The HASP sessions at SHARE Meetings were reminiscent of revival\n   meetings.  For years every SHARE Meeting has included HASP song\n   sessions around the piano during the nightly open bar.  HASP forms a\n   fascinating chapter in the history of IBM's large machine business.\n\n   The core concepts in HASP are pseudo-devices, and the general\n   technique of intercepting supervisor calls to augment operating\n   system functions without changing the operating system itself.  A\n   generation of OS/360 system programmers learned these techniques from\n   HASP.  (These important techniques are hardly ever described in the\n   literature, and \"practical\" programmers don't read the literature\n   anyway).\n\n   When HASP starts up (in supervisor state), it overlays an instruction\n   in the I/O Supervisor with a branch to its own code.  A user program\n   is written as if it were doing real I/O to card readers and printers.\n   HASP intercepts and interprets these I/O operations to handle job I/O\n   in a manner transparent to OS/360.  It similarly intercepts and\n   interprets operator console I/O.\n\n   HASP includes batch remote job entry using binary synchronous\n   communication.  The HASP communication protocol and message formats\n   use a scheme developed by Simpson's group called \"Multileaving\n   Protocol\".  The HASP rje system, by far the best rje package IBM has\n   produced, finally replaced two competitive IBM packages and has\n   effectively become the IBM standard for rje.  CCN's RJS system not\n   only adopted the Multileaving Protocol but essentially copied its\n   binary synchronous communication line handler directly form HASP.\n\n\n\nBraden                                                          [Page 5]\n\f\nRFC 468                   FTP Data Compression                March 1973\n\n\n   The Multileaving Protocol is described in the HASP manual(1) as the\n   \"fully synchronized, pseudo-simultaneous, bidirectional transmission\n   of a variable number of data streams between two or more computers\n   using binary synchronous communications facilities\".  It allows a\n   remote batch terminal to operate a variable number of card readers\n   and printers simultaneously at different speeds over one\n   communication line.  It is not surprising that HASP Multileaving\n   contains in miniature many of the features of IMP-IMP Protocol and a\n   little host-host protocol.  Specifically, Multileaving includes the\n   following general features:\n\n      (1) \"Conversational\" transmission line protocol using transparency\n          (DLE STX, etc.).\n\n      (2) \"Strong\" error control and retransmission using a 16-bit CRC\n          and a modulo-16 block sequence number.\n\n      (3) Flow control for multiple streams in both directions.  This\n          includes the interchanging of matching control records\n          (\"RFC's\") to open a stream, and a set of flow control bits in\n          each block.  Each flow control bit is logically equivalent to\n          an ALLOcate command for one \"message\" (buffer) for a\n          particular stream.\n\n      (4) Optional Special Control Information for remote devices.  This\n          includes printer carriage control, switching card reader\n          hoppers, etc.\n\n      (5) Multiplexing (\"multileaving\") multiple streams into a single\n          block for transmission.\n\n      (6) Marking end of file and ends of records within each stream.\n\n      (7) Compressing transmitted text by encoding repeated blanks and\n          repeated single characters.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBraden                                                          [Page 6]\n\f\nRFC 468                   FTP Data Compression                March 1973\n\n\n   Finally, we have reached the (only) aspect of HASP relevant to FTP:\n   its compression scheme.  HASP uses the following encoding:\n\n                       8\n                  +---------+\n   End of Record: | 0 ... 0 |\n                  +---------+\n                    2     6             8              8\n                  +---+---------+   +-------+     +--------+\n   Data String:   |1 1|     N   |   |    d  | ... |   d    |\n                  |   |         |   |     1 |     |    N   |\n                  +---+---------+   +-------+     +--------+\n                         3      5\n                       +---+--------+\n   N Duplicate Blanks  |100|     N  |\n                       +---+--------+\n                               3       5           8\n                             +---+---------+  +---------+\n   N Replicated Characters D |101|    N    |  |    D    |\n                             +---+---------+  +---------+\n\n   HASP is concerned only with 8-bit bytes.  However, there is a\n   provision (which was never implemented) in the Multileaving Protocol\n   to set the unit of the counts N as 1 byte, 2 bytes, or 4 bytes.\n\n   Reference:\n\n   (1) HASP II System Manual, IBM Corporation (February 26, 1971)\n\n\n\n\n\n\n         [ This RFC was put into machine readable form for entry ]\n         [ into the online RFC archives by Via Genie         4/00]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBraden                                                          [Page 7]\n\f\n"
}