{
  "series": "Request for Comments",
  "number": "58",
  "howpublished": "RFC 58",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0058",
  "url": "https://www.rfc-editor.org/info/rfc58",
  "title": "Logical Message Synchronization",
  "pagetotal": "2",
  "year": "1970",
  "month": "jun",
  "body": "\n\n\n\n\n\nNetwork Working Group                                      T. P. Skinner\nRequest for Comments: 58                                 MIT Project MAC\n                                                               June 1970\n\n                    Logical Message Synchronization\n\n\nAt the last network meeting, the question of logical and physical\nmessage distinctions was raised.  An argument was made in favor of\nnever running two logical messages together as one or more physical\nmessages.  Another method of stating this is that a logical message\nmust begin on a physical message boundary.  This did not, however,\nsolve the problem of locating the end of a logical message.  A rather\npoor technique was suggested by myself which consisted of using the\nfirst partial physical message as an indication of the last physical\nmessage of the logical message.  This technique was thrown out for a\nnumber of very valid reasons.  The solution that seemed most pleasing\nwas the inclusion of some sort of a bit count or data type\nspecification to precede the logical message.  Most everyone seemed to\nlike this even though it was stated in a very general way.\n\nAs of this writing it appears that it is desired to completely sever\nthe relation between physical and logical messages.  This certainly is\naesthetically pleasing.  However, we are now forced to view the\nnetwork as a virtually infinite bit stream with no physical\ndelineations.  It may well do to transmit a logical header and bit\ncount for each message as long as there are no errors along the line.\nIf, however, a bit is dropped, the problem of synchronization is\ncompounded by the fact that we have no ability to search for the\nbeginning of a logical message other than brute force.  An error of\nthis type could be introduced by faulty host or user software/hardware\nas well as the imp itself.  This would involve the shifting of the\nmessage bit by bit and seeing if the data looked reasonable.  This\ncould certainly be time-consuming as well as introducing the\npossibility of false synchronism.\n\nI can think of several solutions to the problem at the moment.  None\nof them seems to be very good.  Upon losing synchronism, a user could\nsend some form of error message to the other host.  The other host\ncould then in return cease sending and wait for a message to continue\nfrom the troubled user.  This would allow the troubled user to flush\nout all waiting input.  He would then be assured that the next bit\nstarted a logical message.  The problems here are in assuring\nsynchrony due to input/output buffering in the network and at both\nhosts.  How, for example, can the troubled host be assured he has all\nthe pending data?  Once he is sure, he can then resume input assuming\nall is OK.\n\n\n\n\n                                                                [Page 1]\n\f\nAnother partial solution requires the original restriction that\nlogical messages always start on physical boundaries.  A user then\nmerely has to examine the beginning of each physical message to see if\nit fits the pattern of a logical message header.  This technique is a\nlot safer than examining the entire input stream as well as being\nquite a bit faster.\n\nI have not intended to suggest a solution to the problem, but merely\nbring it to light.  If we want to restrict logical messages to begin\non physical boundaries we must plan this early in the game.  (It\nprobably works out that way in most cases anyway.)  Other schemes can\nbe tried later.  We must, however, face up to this problem fairly\nsoon.\n\n\n\n       [ This RFC was put into machine readable form for entry ]\n        [ into the online RFC archives by Carl Alexander 7/97 ]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                                [Page 2]\n\f\n"
}