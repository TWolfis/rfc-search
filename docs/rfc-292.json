{
  "series": "Request for Comments",
  "number": "292",
  "howpublished": "RFC 292",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0292",
  "url": "https://www.rfc-editor.org/info/rfc292",
  "title": "Graphics Protocol: Level 0 only",
  "pagetotal": "10",
  "year": "1972",
  "month": "jan",
  "body": "\n\n\n\n\n\nNetwork Working Group                                     12 January 1972\nRequest for Comment: 292                                Jim Michener, MAC\nNIC 8302                                                Ira Cotton, MITRE\nReferences: 282, 285                              Karl Kelley, U. of Ill.\nUpdates: None                                     Dave Liddle, Owens Ill.\nObsoletes: None                                             Ed Meyer, MAC\n\n\n                   GRAPHICS PROTOCOL - LEVEL 0 ONLY\n\nINTRODUCTION\n\n   This document reflects opinions expressed and decisions reached at\n   the second meeting of the Network Graphics Group, held at the\n   Stanford Artificial Intelligence Laboratory in late November 1971.\n   It describes part of a proposed Network Standard Graphics Protocol\n   for transmitting graphics data within the ARPA network.  The\n   particular aspects of the protocol covered in this document relate to\n   the form and content of graphics information sent from a source of\n   graphical information (an application program, say, in the \"Serving\n   Host\") to a display package for output to a graphics console (at the\n   \"Using Host\").  This will take the form of a sequence of 8-bit bytes,\n   and will be called the graphics output byte stream.  In particular,\n   only the simplest forms of graphics data will be covered in this, the\n   first version of this document.  The next version, already in\n   preparation, will be much more complete.  In any case this is not\n   intended to describe a finished protocol; rather it should serve as a\n   basis for graphics experimentation on the network.\n\n   This document does not include form or content of graphics input\n   (data sent from the Using Host to the Serving Host) nor does it cover\n   how the connection is established between the hosts.  A proposal for\n   the former will be generated eventually by this committee; the latter\n   is the job of the Connection Committee (of the Network Graphics\n   Group).\n\n   This RFC describes the commands which are available in the protocol\n   in terms of the effect they would have at the receiving (Using Host)\n   end.  Clearly, some subroutine package is desirable at the Serving\n   Host for use by applications package in transmitting graphics data,\n   but on this topic this RFC does not intend to comment.\n\n   It may be observed by the reader that no facility is specified in\n   this protocol allowing the Using Host to report logical errors in the\n   graphics output byte stream to the Serving Host.  Such a facility\n   would have to be intergrated with the graphics _input_ byte stream,\n   since it involves most of the problems related to synchrony of\n   independent hosts.\n\n\n\nMichener                                                        [Page 1]\n\f\nRFC 292                Graphics Protocol Level 0            January 1972\n\n\nBACKGROUND\n\n   The reader should probably peruse RFC 282: \"Graphics Meeting Report\"\n   by Mike Padlipsky to obtain some of the framework surrounding this\n   discussion of network graphics.  Also it might be valuable to make\n   note of the model described in RFC 285: \"Network Graphics\" by Donald\n   Huff.\n\nLEVEL AND GROUND RULES PERTAINING THERETO\n\n   Functions within the graphics protocol will be classified into a\n   number of levels depending partly on how difficult it is to implement\n   those functions.  It is intended that any host which claims to\n   implement the functions of level N must implement all lower levels as\n   well.  Thus, it is envisioned that sites will implement levels\n   incremently.  Implementations will be improved as a continuing\n   process to include more and more functions, and it is intended that\n   each implementation will be able to identify its own level to a\n   graphics protocol at a remote site which is requesting a graphics\n   interchange.  A side result is that each site will be able to\n   determine its own priorities in committing programmers to the\n   graphics protocol as opposed to other efforts.\n\n   It is also our intention that implementation of level N will require\n   no knowledge of level N+1.  Thus a site can implement a level in the\n   (reasonably) firm knowledge that no changes at higher levels will\n   alter the level implemented.  At some time it may be decided by the\n   Network Graphics Group to redefine a level which has previously been\n   firmed up.  It is not our intention that this shall happen but one\n   must recognize that the proposed Graphics Protocol is experimental\n   and may have to be changed.\n\n   One further ground rule:  a stream of commands and data which is\n   valid at a given level, K, shall produce \"identical\" results on any\n   interpreter of level K or higher.  By this we mean that as defined\n   operations, similar pictures should result.  Aspects of the protocol\n   which are not strictly defined (at this time) include character size,\n   character position relative to the beam, how control characters in\n   text output affect the terminal and what happens when the beam is\n   moved or a line drawn outside of the logical screen boundary.  This\n   rule forces upwards compatibility, so that an application written\n   using features of low numbered level will still work at sites which\n   have moved on to implement higher levels.  Additionally, any aspects\n   of this protocol which are explicitly \"left unspecified\" in the\n   detailed operations descriptions below _shall_ be explicitly\n   specified in any public description of an actual implementation.\n\n   We now describe the framework which will be common to all levels.\n\n\n\nMichener                                                        [Page 2]\n\f\nRFC 292                Graphics Protocol Level 0            January 1972\n\n\nBASIC DATA FORMS\n\n   Information in the Network Standard Graphics Protocol will be\n   expressed as a sequence of 8-bit bytes.  A command will consist of a\n   command byte followed by zero or more arguments.  The same command\n   byte will always take the same number of arguments in the same form.\n   The length of each argument may be fixed or variable depending on the\n   argument.\n\n   A simple type of argument is a \"value,\" which is an 8-bit integer.\n   Another type of argument is a \"string\" which is a count followed by\n   (count)number of 8-bit bytes.  If the count is between 0 and 127, it\n   is sent in a single byte.  If the count is between 128 and 2**15-1\n   (** means exponentiation), it is sent in two bytes with the high\n   order bit of the first byte set to one.  The first byte contains the\n   seven high order bits of the number, and the second byte contains the\n   eight low order bits.  A string is the only type of argument of a\n   command which can vary in length.\n\n   Coordinate data engendered considerable discussion at the second\n   Network Graphics Group meeting.  It was decided that a two-\n   dimensional Logical Coordinate System was required, and each\n   interpreter for the graphic command byte stream would be responsible\n   for mapping this coordinate system to physical device coordinates.\n   It was decided that data in the logical coordinate system would be in\n   twos-complement notation, that it would be fractional, that each edge\n   of the screen would have unit length, and that the origin would\n   correspond to the center of the screen on the output device.  The\n   vertical (horizontal) edges of the screen of the  output device\n   correspond to the lines X (Y) = -1/2 or X=+1/2-e where e is a small\n   positive number determined by the precision of the fractional data.\n   Particularly the points (-1/2,-1/2) (-1/2,1/2-e), (1/2-e, -1/2) and\n   (1/2-e, 1/2-e) shall be visible points at the corners of the logical\n   screen.  (In the case of a non-square display surface, the\n   implementer may make his own decision, but it is recommended that the\n   largest possible _square_ area be utilized.)  Thus we shall say that\n   the Logical Coordinate System contains points whose coordinates range\n   from -1/2 to a little less than +1/2.\n\n   Commands which take coordinate data will be available in various\n   modes.  In absolute mode, a position is specified by giving its\n   coordinates in the Logical Coordinate System.  In relative mode, the\n   _difference_ between the coordinates of the position and the\n   coordinates of the current position must be specified.  Thus a\n\n\n\n\n\n\n\nMichener                                                        [Page 3]\n\f\nRFC 292                Graphics Protocol Level 0            January 1972\n\n\n   coordinate datum which is an argument for an absolute mode operation\n   should be in the range -1/2 to +1/2-e, while one for a relative mode\n   operation should be in the range -1+e to +1-e.\n\n   Interest was expressed at the second Graphics Group Meeting in\n   eventually allowing a very large coordinate space (many bits of\n   precision in each fractional coordinate).  This is to be done by\n   permitting the length, in 8-bit bytes, of each coordinate datum to be\n   set (as a mode).  It was decided at the meeting that two bytes per\n   coordinate would suffice for now.  Thus \"e\" in the above discussion\n   is 2**(15) (one in the least significant bit of a 15-bit plus sign\n   fractional coordinate).\n\n   Text data will be transmitted as an argument of various commands for\n   display on the output device.  Network ASCII will be used to\n   represent characters.  At the lowest-levels of the protocol only one\n   character size will be available -- whatever is \"normal\" on the\n   display device.  If the device had no \"normal\" size, 72 characters\n   per line would be desirable.  Later, variable character size may be\n   introduced.\n\n   Also, at the lowest levels, control characters will be passed along\n   to the device for it to do the best it can.  However, the consensus\n   of the graphics meeting was that at some reasonably low (but non-\n   zero) level carriage return, line feed, and backspace should be\n   interpreted to do the right thing.\n\nCOMMAND CODES\n\n   Each command in the graphics protocol will be assigned a non-negative\n   value which will represent this command in the byte stream.  The\n   algorithm whereby values and commands are associated is, it turns\n   out, a very touchy subject.  There are five or ten different criteria\n   for a \"best\" algorithm, each criterion different in emphasis.  This\n   Gordian knot will be cut, in this proposal, by ordering the commands\n   approximately according to level, and then just numbering them.  In\n   addition, if several closely related commands occur at the same\n   level, some attempt will be made to encode variations of meanings in\n   terms of bit configurations.  Even if some later consideration causes\n   a change in ordering to be proposed, it is this committee's feeling\n   that the numbering should not be altered.  However, until this matter\n   is firmly settled, it is strongly advised that any implementation\n   take into account the possibility of reassignment of command codes.\n\n\n\n\n\n\n\n\nMichener                                                        [Page 4]\n\f\nRFC 292                Graphics Protocol Level 0            January 1972\n\n\nPARTICULAR PROPOSAL FOR LEVEL 0 PROTOCOL\n\n   It is proposed that level 0 be kept very simple.  This is so that\n   implementation can be quickly accomplished and experimentation with\n   the protocol begun.  Another reason is that the least powerful hosts\n   and even programmable terminals should be able to implement it.  In\n   accordance with this, the \"rule\" was made that a command be\n   implemented only if the output is a function solely of the current\n   command and the \"beam position\" current at the start of the command.\n   In other words the interpreter for level 0 need have no internal\n   storage for \"modes\" or pushdown stacks.  With this restriction it is\n   hoped that a very simple implementation will be possible for level 0.\n   In particular, perhaps one could eventually build a hardware\n   translator from level 0 code to one's own particular terminal's code.\n\n   Note that in the opcode assignment for level 0, bits 4, 2, and 1 have\n   special meaning for the move, line and dot commands.  In particular,\n   the 1 bit encodes absolute versus relative data mode, the 4 bit\n   encodes whether any visible output occurs, and the 2 bit determines\n   whether the visible output is a line or a dot.\n\nLEVEL 0: COMMAND SUMMARY\n\n   The following is a list of commands (and their syntax)in level zero.\n   Detailed descriptions of these commands follow in the next section.\n   Commands dealing with protocol may be added by the Connection\n   Committee.  (They currently request opcodes in the range 128 to 255.)\n\n   (As described in Basic Data Forms, above, \u003cx\u003e, \u003cy\u003e, \u003cx delta\u003e and \u003cy\n   delta\u003e are two-byte coordinate values,  \u003cstring\u003e is a count followed\n   by (count) many bytes and \u003cvalue\u003e is an eight bit number.)\n\n   Decimal    Octal        Binary        Format\n\n   0             0         00000000   Null\n   1             1         00000001   Erase screen and reset beam\n   2             2         00000010   Move Absolute \u003cx\u003e \u003cy\u003e\n   3             3         00000011   Move Relative \u003cx\u003e \u003cy\u003e\n   4             4         00000100   Draw Absolute \u003cx\u003e \u003cy\u003e\n   5             5         00000101   Draw Relative \u003cx delta\u003e \u003cy delta\u003e\n   6             8         00000110   Dot Absolute \u003cx\u003e \u003cy\u003e\n   7             7         00000111   Dot Relative \u003cx delta\u003e \u003cy delta\u003e\n   8            10         00001000   Text \u003cstring\u003e\n   9            11         00001001   TextR \u003cstring\u003e\n   10           12         00001010   End of Picture\n   11           13         00001011   Escape \u003cvalue\u003e \u003cstring\u003e\n\n\n\n\n\nMichener                                                        [Page 5]\n\f\nRFC 292                Graphics Protocol Level 0            January 1972\n\n\nLEVEL 0:  COMMAND DESCRIPTIONS\n\n      0     Null Statement (\"null\")\n      This statement has no arguments and no effect, either.\n\n      1     Erase screen and reset beam to origin (\"Erase\").\n      This command indicates that a new picture is about to be drawn.\n      It should always be (eventually) paired with a following End of\n      Picture command.\n\n      2     Move beam invisibly to absolute position\n      (\"Move Absolute\") \u003cx coordinate\u003e \u003cy coordinate\u003e.\n      Nothing is drawn; the beam is positioned to the specified absolute\n      x,y position.\n\n      3     Move beam invisibly by relative amount\n      (\"Move Relative\") \u003cx delta\u003e \u003cy delta\u003e.\n      Nothing is drawn; the beam is shifted by the specified amount in x\n      and y.\n\n      4     Draw line to absolute position\n      (\"Draw Absolute\") \u003cx coordinate\u003e \u003cy coordinate\u003e.\n      A line is drawn from the current beam position to the specified\n      absolute x, y position.\n\n      5     Draw line to relative position\n      (\"Draw Relative\") \u003cx delta\u003e \u003cy delta\u003e.\n      A line is drawn from the current beam position to the position\n      delta x and delta y away.\n\n      6     Display a Dot at absolute position\n      (\"Dot Absolute\") \u003cx coordinate\u003e \u003cy coordinate\u003e.\n      The beam is moved invisibly to absolute position x, y and a dot is\n      displayed there.\n\n      7     Display a Dot at Relative position\n      (\"Dot Relative\") \u003cx delta\u003e \u003cy delta\u003e.\n      The beam is moved invisibly by the specified amount in x and y and\n      a dot is displayed there.\n\n      8     Display text (\"Text\") \u003cstring\u003e.\n      At the current beam position, display some characters at the\n      normal size for the device being operated.  \u003cstring\u003e consists of a\n      \u003ccount\u003e followed by count many characters.  If there is no \"normal\n      size,\" choose the size so that seventy-two characters are\n      displayed per line.  The characters in the string are coded in\n      network ASCII: all codes between 0 and 127 (decimal) inclusive are\n      permitted.  (At level zero, what happens to control characters is\n\n\n\nMichener                                                        [Page 6]\n\f\nRFC 292                Graphics Protocol Level 0            January 1972\n\n\n      left unspecified.)  Where the beam is, following execution of this\n      command, is left unspecified, except that another Display Text\n      command immediately following will append its text to the previous\n      string.  (The use of the TEXT command is _discouraged_; use TextR\n      instead.)  The position of the first character relative to the\n      initial beam position is left unspecified.\n\n      9     Display text and restore beam (\"TextR\") \u003cstring\u003e.\n      At the current beam position, display a string of characters at\n      the normal size for the device being operated then reposition the\n      beam to where it was before the command.  \u003cstring\u003e consists of a\n      \u003ccount\u003e followed by count many characters.  If there is no \"normal\n      size,\" choose the size so that seventy-two characters are\n      displayed per line.  The characters in the string are coded in\n      network ASCII; all codes between 0 and 127 (decimal) inclusive are\n      permitted.  (At level zero, what happens to control characters is\n      left unspecified.)  The position of the first character relative\n      to the initial beam position is left unspecified.\n\n      10     End of Picture (\"Endpic\").\n      This command denotes the end of a new picture.  It must be paired\n      with a preceding Erase command.\n\n      11     Escape to device specifics (\"Escdev\") \u003cvalue\u003e \u003cstring\u003e.\n      If \"value\" is the code assigned (by the Protocol Committee) to the\n      device being operated, then transmit the eight-bit bytes in\n      \u003cstring\u003e (which starts with a \u003ccount\u003e indicating the number of\n      bytes) to the device without examining them.  Otherwise ignore\n      this command.  If the device does not accept 8-bit information,\n      reformat the data in some device specific way; an example would be\n      throwing away the high order bit for a seven bit device, or\n      gathering 5 8-bit bytes into one 36-bit word, again discarding the\n      high order bits, perhaps.  The action of the bytes in the string\n      should leave alone (or at least restore) any hardware beam\n      position registers in the device which the interpreter might\n      conceivably depend on.\n\n      This command really should not be used; it was included at level 0\n      so that specific applications can do mode setting and other device\n      specific manipulations.  For example ARDS terminals may optionally\n      have several, independently addressable output scopes.  The\n      selection mechanism changes state only when a particular sequence\n      of ASCII characters reaches the terminal.  Thus ESCDEV would be\n      used to select which scopes(s) is/are to be affected by following\n      commands.  (The current state is invisible to the graphics package\n      at the Using Host.)\n\n      Further, suppose that another make of terminal has a similar\n\n\n\nMichener                                                        [Page 7]\n\f\nRFC 292                Graphics Protocol Level 0            January 1972\n\n\n      option, which responds to a different code sequence.  This\n      possibility is the motivation for conditionally ignoring the\n      ESCDEV command based on the \"\u003cvalue\u003e\" specified.  Given that a\n      particular application will only be used to output to either an\n      ARDS or this second make (with the multiple scope option), then\n      the application could always send two ESCDEV commands, one\n      applicable only to ARDS terminals, and the other applicable only\n      to the second make.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMichener                                                        [Page 8]\n\f\nRFC 292                Graphics Protocol Level 0            January 1972\n\n\n            APPENDIX 1:  BNF FOR THE GRAPHICS PROTOCOL BYTE STREAM\n\n   Key to below:\n   Non-terminals are represented in \u003c\u003e.\n   Terminals which are keywords standing for particular eight-bit values\n   are in capitals.\n   Terminals whose meaning should be clear to the reader are in lower\n   case.  Note that \"empty_string\" means \"zero bytes,\" and not \"a\n   \u003cstring\u003e whose \u003ccount\u003e is zero\".\n\n   \u003cgraphics output byte stream\u003e ::= empty_string\n                      | \u003cpicture\u003e \u003cgraphics output byte stream\u003e\n   \u003cpicture\u003e ::= \u003cnew picture stt\u003e \u003csttgroup\u003e \u003cend stt\u003e\n   \u003cstt group\u003e ::= empty_string | \u003cstt\u003e \u003cstt group\u003e.\n   \u003cstt\u003e ::= \u003ccontrol stt\u003e | \u003cdisplay stt\u003e\n   \u003ccontrol stt\u003e ::= \u003cescape to device stt\u003e\n                      | \u003cnull stt\u003e\n   \u003cdisplay stt\u003e ::= \u003cmove absolute stt\u003e\n                      | \u003cmove relative stt\u003e\n                      | \u003cdraw absolute stt\u003e\n                      | \u003cdraw relative stt\u003e\n                      | \u003cdot absolute stt\u003e\n                      | \u003cdot relative stt\u003e\n                      | \u003ctext and restore beam stt\u003e\n                      | \u003ctext stt\u003e\n\n   \u003cnew picture stt\u003e ::= ERASE\n   \u003cescape to device stt\u003e ::=ESCDEV \u003cdevice code\u003e \u003cstring\u003e\n   \u003cnull stt\u003e::= NULL\n   \u003cend stt\u003e::= ENDPIC\n   \u003cmove absolute stt\u003e ::= MOVEA \u003cx coordinate\u003e \u003cy coordinate\u003e\n   \u003cmove relative stt\u003e ::= MOVER \u003cx delta\u003e \u003cy delta\u003e\n   \u003cdraw absolute stt\u003e ::= DRAWA \u003cx coordinate\u003e \u003cy coordinate\u003e\n   \u003cdraw relative stt\u003e ::= DRAWR \u003cx delta\u003e \u003cy delta\u003e\n   \u003cdot absolute stt\u003e ::= DOTA \u003cx coordinate\u003e \u003cy coordinate\u003e\n   \u003cdot relative stt\u003e ::= DOTR\u003cx delta\u003e \u003cy delta\u003e\n   \u003ctext and restore beam stt\u003e ::= TEXTR \u003cstring\u003e\n   \u003ctext stt\u003e ::= TEXT \u003cstring\u003e\n   \u003cx coordinate\u003e ::= \u003ccoordinate\u003e\n   \u003cy coordinate\u003e ::= \u003ccoordinate\u003e\n   \u003cx delta\u003e ::= \u003cdouble coordinate\u003e\n   \u003cy delta\u003e ::= \u003cdouble coordinate\u003e\n   \u003ccoordinate\u003e ::= singed,_two's-complement,_fraction_in_range\n                     -1/2_to_less_than_+1/2\n   \u003cdouble coordinate\u003e ::= signed,_two's_complement,_fraction,\n                     range_strictly_between_-1_and_+1\n\n\n\n\n\nMichener                                                        [Page 9]\n\f\nRFC 292                Graphics Protocol Level 0            January 1972\n\n\n   \u003ccount ::= 7-bit_non-negative_integer\n                     | 15-bit_non-negative_integer_represented_in\n                     \"excess_2**15\"_notation\n   \u003cstring\u003e ::= \u003ccount\u003e count_8-bit_bytes\n   \u003cdevice code\u003e ::= \u003cvalue\u003e\n   \u003cvalue\u003e ::= 8-bit_integer\n\n\n\n\n\n\n\n\n\n\n\n          [This RFC was put into machine readable form for entry]\n      [into the online RFC archives by Kelly Tardif, Viag\ufffdnie 10/99]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMichener                                                       [Page 10]\n\f\n"
}