{
  "series": "Request for Comments",
  "number": "442",
  "howpublished": "RFC 442",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0442",
  "url": "https://www.rfc-editor.org/info/rfc442",
  "title": "Current flow-control scheme for IMPSYS",
  "pagetotal": "7",
  "year": "1973",
  "month": "jan",
  "body": "\n\n\n\n\n\nNetwork Working Group                                            V. Cerf\nRequest for Comments: 442                                24 January 1973\nNIC: 13774\n\n\n               The Current Flow-Control Scheme for IMPSYS\n\n   BB\u0026N quarterly report #13 outlines part of the current flow control\n   scheme in the IMP operating system.  A meeting held March 16, 1972,\n   at BB\u0026N was devoted to the description of this new scheme for the\n   benefit of interested network participants.\n\n   This note represents my understanding of the flow control mechanism.\n   The essential goal is to eliminate unnecessary retransmissions when\n   the load is heavy, eliminate the retransmission time-out period when\n   the load is light, increase bandwidth, prevent re-assembly lock-up,\n   control traffic from HOSTS into the net more strictly than the\n   earlier link blocking method, and secure the rights of life, liberty,\n   and the pursuit of happiness for ourselves and our posterity,...oops.\n\nSource IMP-to-Destination IMP Protocol\n\n   There are two different protocols depending on message length (i.e.\n   single or multi-packet).  We illustrate first the single packet case.\n\n          Source Imp                        Destination Imp\n          ----------                        ---------------\n\ncase 1)   message (1) + implicit req (1)---\u003e\n                                        \u003c--- RFNM (arrived ok)\n          [discard copy of msg]\n\ncase 2)   message (1) + implicit req (1)---\u003e no room, don't respond\n                                        \u003c--- All (1)  (room available)\n          message (1)                   ---\u003e\n          [discard copy of msg]         \u003c--- RFNM (arrived ok)\n\n   In the first case, a single packet message is sent to the destination\n   IMP.  This message acts as an implicit request for single packet\n   buffer space.  If there is room, as in case 1, the destination IMP\n   responds with a RFNM.  The source IMP, which has retained a copy of\n   the message, deletes its copy and goes on.\n\n   The second case illustrates what happens when the source IMP sends a\n   message to a destination IMP at which there is no room for the one-\n   packet message.  The arrival of the single packet message constitutes\n   a request for single packet buffer space, and is recorded as such by\n   the destination IMP in a first-come-first-served buffer reservation\n\n\n\nCerf                                                            [Page 1]\n\f\nRFC 442        The Current Flow-Control Scheme for IMPSYS   January 1973\n\n\n   request queue.  When space is available, the destination IMP will\n   transmit an ALL (1) to the requesting source IMP which can then send\n   the single packet message again, this time knowing that space has\n   been reserved at the destination.\n\n   For multi-packet messages, the procedure is somewhat different.  When\n   a message enters an IMP from a HOST, and the \"last bit\" flag is not\n   set when the number of bits in a maximum length single packet have\n   arrived, the IMP halts the HOST-\u003eIMP transmission line while it\n   determines whether space has been reserved at the dest. IMP.  If\n   space (8 packets worth) has been reserved, the HOST-\u003eIMP line is re-\n   opened, and the message is sent out normally.  If space has not been\n   reserved, the HOST-\u003eIMP line is kept closed while the source IMP\n   makes a request for multi-packet buffer storage at the destination\n   IMP.  When 8 buffers are available, the destination IMP responds with\n   an ALL (8).  The source IMP then transmits the message, and waits for\n   a combination RFNM and ALL (8) from the destination IMP.  The\n   destination IMP will delay its RFNM, if necessary, until it has\n   another 8 buffers available for the next multipacket message.\n\n   This sequence is illustrated below:\n\n            Source IMP                   Destination IMP\n            ----------                   ---------------\n\nH-\u003e I line\n----------\u003e First packet of multipacket\n            arrives. Halt H-\u003eI line and\n            send REQ (8)  --------------\u003e\n            start 30 sec. Time-out\n\n            If time-out, resend\n            REQ (8) and restart --------\u003e\n            time-out.\n                                \u003c--------ALL (8) when available. Start\n                                         long term (2 min.) time-out.\n                                         On time-out, reset all\n                                         outstanding reservations.\n\n            Send the message:\n                        |   -----------\u003e\n            Start 30 sec. time-out\n            for INComplete transmission.\n            If time-out, send INC?-----\u003e\n\n\n\n\n\n\n\nCerf                                                            [Page 2]\n\f\nRFC 442        The Current Flow-Control Scheme for IMPSYS   January 1973\n\n\n                                  \u003c------On recept of message, send\n                                         RFNM + implicit ALL (8). On\n                                         receipt of INC? send RFNM +\n                                         ALL(8) if MSG(8) received,\n                                         or send INC! if MSG(8) not\n                                         received. Start 2 min. time-out\n                                         on ALL(8).\n\n            Queue ALL(8); start 125 ms.\n            time-out when it reaches\n            head of queue. If time-out\n            on ALL(8), send GVB(8)-----\u003e\n                                  \u003c----- Ack.\n            else send next message -----\u003e\n\n\n   A key point in this protocol is that a source IMP, after receipt of a\n   RFNM and implicit ALL(8) from the destination IMP, has 125 msec. in\n   which to initiate the transfer of at least the first packet of a\n   multi-packet message to the destination IMP.  The source IMP may have\n   several allocate responses queued up in which case these time-outs\n   occur one after the other (one has to time-out before the next 125\n   msec time-out starts).\n\n   Time-outs exist in the source IMP which cause it to send INC?\n   messages to the destination IMP if it has received no response from\n   some earlier message.\n\nBuffer Allocation\n\n   A total of 40 buffers are available for store/forward and re-assembly\n   purposes.  At most 32 can be allocated for re-assembly, and at most\n   24-25 can be allocated for store and forward use.  This prevents\n   either kind of traffic from completely shutting out the other kind.\n\nMessage Ordering (Source IMP-to-Destination IMP).\n\n   As an aid to congestion control, an IMP can have at most 4 messages\n   outstanding (un-RFNMed) for each other IMP.  Link numbers in the\n   message leader are ignored by the IMPs.  Instead, IMPs mark messages\n   leaving for other destinations with an 8-bit message number.  In\n   addition, a 2-bit priority number is also used in case a HOST has\n   marked a message as a priority message.  The key notion here is that\n   the IMPs treat all HOSTs on a given IMP as if they were a single\n   HOST.  A single sequence of message and priority numbers is used in\n   each direction between each pair of sites.\n\n\n\n\n\nCerf                                                            [Page 3]\n\f\nRFC 442        The Current Flow-Control Scheme for IMPSYS   January 1973\n\n\n   The receiving IMP remembers the message number of the last message\n   delivered, as well as the priority number of the last priority\n   message delivered.  It uses this information to correctly sequence\n   messages out the IMP-HOST line (s).  Since there is only one sequence\n   of numbers for each pair of sites, messages for one HOST at a site\n   may get in the way of messages for another HOST at the same site.  In\n   fact, if some message, m, is the next in line to go to some HOST, and\n   that HOST delays receipt for 30 seconds, any messages for another\n   HOST may be delayed that long also.  However, only the first message\n   is lost, since the second one could not even start into its\n   destination HOST until the first one had been delivered.  There is a\n   tighter coupling between HOSTs sharing an IMP than before, but not\n   much tighter.\n\n   An example of the use of message and priority numbers is given below.\n\nOrder sent by           Order received by       Order received by\nSource IMP              Dest. IMP               HOST\n----------              ---------               ----\n\n11,12P(1),13P(2),14 --\u003e 13P(2),12P(1),14,11 --\u003e 12P(1),13P(2),11,14\n\n11,12P(1),13P(2),14 --\u003e 13P(2),11,14,12P(1) --\u003e 11,12P(1),13P(2),14\n\n\nwhere 13P(2) is interpreted to mean message #13, priority number(2).\n\n   Note that there are only 2 classes of messages, priority and non-\n   priority, and that the priority numbers simply allow ordering at the\n   destination of multiple outstanding priority transmissions from the\n   same site.\n\n   If HOSTs use link numbers to de-multiplex messages to processes, then\n   it would be a mistake to arbitrarily assign short messages priority.\n   If a file transmission were carried out such that the last short\n   message had priority, the file might not enter the receiving HOST in\n   the same order it was sent!\n\nACK Mechanism\n\n   IMPs treat their physical channels (phone lines) as if they were\n   pairs of simplex communications paths.  Each IMPSYS has a sender and\n   receiver module for each full duplex channel.  Each module has an\n   \"ODD/EVEN\" bit which is used to keep track of the state of the last\n   packet on the line.  The object is for the sender module to \"block\" a\n   channel until the corresponding receiver has received a packet\n   indicating that the send packet was received on the other end (i.e.\n   an acknowledgment).\n\n\n\nCerf                                                            [Page 4]\n\f\nRFC 442        The Current Flow-Control Scheme for IMPSYS   January 1973\n\n\n   In the present system, acknowledgments are separate IMP-IMP packets.\n   In the new system, they are a single bit in a packet flowing in the\n   opposite direction on the reverse path of a full duplex channel.\n\n   Every packet sent between IMPs has an ACK bit and an OE bit, as shown\n   below.\n\n\n                         P                              A\n                          O                              C\n                           E                              K\n               +-------+-----+------------------------+-----+----------+\ntypical packet |       |     |                        |     |          |\n               |       |     |                        |     |          |\n               +-------+-----+------------------------+-----+----------+\n\n   We need some terminology: Let POE be the packet OE bit, and SOE, ROE\n   be the send module OE bit and Receive module OE bit respectively.\n   For two IMPs, A and B, we distinguish SOE/A and SOE/B as the two send\n   module OE bits at IMPs A and B respectively.\n\n   The rules of operation are as follow:\n\n   Sender\n   ------\n   if ACK != SOE then do nothing\n   --\n   else SOE \u003c- !SOE (i.e. flip SOE bit) and free channel.\n   ----\n\n   Receiver\n   --------\n   if POE = ROE then packet is a duplicate so throw it away.\n   --\n   else ROE \u003c- !ROE\n   ----\n\n   Whenever a packet is sent by the sent module, its two bits, POE and\n   ACK are set up by:\n\n                        POE \u003c- SOE\n                        ACK \u003c- ROE\n\n   The mechanism is designed to use real traffic to accomplish the\n   acknowledgment protocol by piggy-backing the ACK bits in the header\n   of real packets.  If there is no real packet waiting for transmission\n   in the opposite direction, a fake packet is assembled which carries\n   the ACK, but which is not acknowledged by the receiving side.\n\n\n\nCerf                                                            [Page 5]\n\f\nRFC 442        The Current Flow-Control Scheme for IMPSYS   January 1973\n\n\n   We give an example of the operation of this mechanism between two\n   IMPs.\n\n                     IMP A                           IMP B\n                     -----                           -----\n                   ROE | SOE                       ROE | SOE\n                       |           POE   ACK           |\n                       |         +-----------+         |\nIMP A blocks send    1 | 0    (1)|  0      1 |-\u003e     1 | 0 IMP B NOPS,\nchannel.               |         +-----------+         |   flips ROE\n                       |                               |\n                       |           POE   ACK           |\n                       |         +-----------+         |\nIMP A frees send     0 | 1     \u003c-|  0      0 |(2)    0 | 0 IMP B blocks\nchannel,               |         +-----------+         |   channel for\nFlips SOE              |                               |   new traffic\n                       |           POE   ACK           |\nIMP A blocks send      |         +-----------+  crashes|\nchannel                |      (3)|  1      0 |-\u003eor gets|\n                       |         +-----------+  lost   |\n                       |                               |\n                       |           POE   ACK           |\nIMP A detects packet   |         +-----------+         |\nduplicate (POE=ROE)  0 | 1     \u003c-|  0      0 |(2)    0 | 0 IMP B\nso does not change     |         +-----------+         |  retransmits no\nSOE bit.               |                               |  ACK received\n                       |           POE   ACK           |\nIMP A retransmits      |         +-----------+         |   IMP B flips\npacket 3               |      (3)|  1      0 |-\u003e     1 | 1 SOE, unblocks\n                       |         +-----------+         |   channel, and\n                       |                               |   flips ROE.\n                       |           POE   ACK           |\nIMP A flips ROE,       |         +-----------+         |\n      flips SOE      1 | 0     \u003c-|  1      1 |(4)      |\n                       |         +-----------+         |\n                       |                               |\n\n   In fact each send/receive module has 8 OE bits, so up to 8 packets\n   can be outstanding in either direction.\n\nHow things really work\n\n   Actually, a single send module is responsible for trying to transmit\n   packets out on the 8 pseudo-channels.  Each channel has a two-bit\n   state (in addition to an OE bit).  Each channel is either FREE or IN\n   USE and if IN USE, it may be sending OLD or NEW packet.\n\n\n\n\n\nCerf                                                            [Page 6]\n\f\nRFC 442        The Current Flow-Control Scheme for IMPSYS   January 1973\n\n\n start state                                      F = free\n        |                                         I = in use\n        V                                         X = don_t care\n       +-----+                 +------+           N = new packet\n       |  FX | --------------\u003e | I, N |           O = old packet\n       +-----+                 +------+\n          ^                       |\n          |                       |\n          |                       |\n          |                       |\n   ACK    |                       |\n received |                       |\n          |                       V\n          |                   +------+\n          +-------------------| I, O |---+\n                              +------+   |\n                                  ^      | re-transmissions\n                                  +------+\n\n   Between IMPs, packets are sent repeatedly, until they are\n   acknowledged.  However, the choice of what to send is ordered by\n   priority as follows:\n\n      1. Priority Packets (as marked by HOST)\n\n      2. Non-Priority Packet\n\n      3. Unacknowledged packets (on I,O state channels)\n\n      4. Others\n\n   It was pointed out that a heavy load of type (1) and (2) traffic\n   might prevent retransmissions from occurring at all, and W. Crowther\n   responded that the bug would be fixed by a 125 ms time-out which\n   forces retransmission of old packets in class (3).\n\n   Note that each packet must carry a \"pseudo-channel\" number to\n   identify the POE-to-channel association, and 8 ACK bits (which are\n   positionally associated with the pseudo-channels).  Thus a single\n   packet can ACK up to 8 packets at once.\n\n\n\n\n          [This RFC was put into machine readable form for entry]\n     [into the online RFC archives by Helene Morin, Via Genie, 12/99]\n\n\n\n\n\nCerf                                                            [Page 7]\n\f\n"
}