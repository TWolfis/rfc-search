{
  "series": "Request for Comments",
  "number": "55",
  "howpublished": "RFC 55",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0055",
  "url": "https://www.rfc-editor.org/info/rfc55",
  "title": "Prototypical implementation of the NCP",
  "pagetotal": "23",
  "year": "1970",
  "month": "jun",
  "body": "\n\n\n\n\n\nNetwork Working Group                                          J. Newkirk\nRequest for Comments: 55                                        M. Kraley\n                                                                  Harvard\n                                                                J. Postel\n                                                               S. Crocker\n                                                                     UCLA\n                                                             19 June 1970\n\n                A Prototypical Implementation of the NCP\n\n\n   While involved in attempting to specify the formal protocol, we also\n   attempted to formulate a prototypical NCP in an Algol-like language.\n   After some weeks of concentrated effort, the project was abandoned as\n   we realized that the code was becoming unreadable.  We still,\n   however, felt the need to demonstrate our conception of how an NCP\n   might be implemented; we felt that this would help suggest solutions\n   for problems that might arise in trying to mold the formal\n   specifications into an existing system.  This document is that\n   attempt to specify in a prose format what an NCP could look like.\n\n   There are obvious limitations on a project of this nature.  We do\n   not, and cannot, know all of the quirks of the various systems that\n   must write an NCP.  We are forced to make some assumptions about the\n   environment, system calls, and the like.  We have tried to be as\n   general as possible, but no doubt many sites will have completely\n   different ways of conceptualizing the NCP.  There is great difficulty\n   involved in conveying our concepts and the mechanisms that deal with\n   these concepts to people who have wholly different ways of looking at\n   things.  We have, however, benefited greatly by trying to actually\n   code this program for our fictitious machine.  Many unforeseen\n   problems surfaced during the coding, and we hope that by issuing this\n   document we can help to alleviate similar problems which may arise in\n   individual cases.\n\n   There is, of course, absolutely no requirement to implement anything\n   which is contained in this document.  The only rigid rules which an\n   NCP _must_ conform to are stated in NWG/RFC#54.  This description is\n   intended only as an example, _not_ as a model.\n\n   In the discussion which follows we first describe the environment to\n   be assumed and postulate a set of system calls.  We discuss the\n   overall architecture of the NCP and the tables that will be used to\n   hold relevant information.  Narratives of network operations follow.\n   A state diagram is then presented as a convenient method for\n   conceptualizing the cause-effect sequencing of events.  The detailed\n   processing of each type of network event (system calls or incoming\n   network messages) is then discussed.\n\n\n\nNewkirk, et al.                                                 [Page 1]\n\f\nRFC 55             Prototypical Implementation of NCP          June 1970\n\n\nII. Environment\n\n   We assume that the host will have a time-sharing operating system in\n   which the CPU is shared by processes.\n\n   We envision that each process is tagged with a user number.  There\n   may be more than one process with the same user number; if so, they\n   should all be cooperating with respect to using the network.\n\n   We envision that each process contains a set of ports which are\n   unique to the process.  These ports are used for input to or output\n   from the process, from or to files, devices, or other processes.\n\n   We also envision that a process is not put to sleep (i.e., blocked or\n   dismissed) when it attempts to LISTEN or CONNECT.  Instead it is\n   informed when some action is complete.  Of course, a process may\n   dismiss itself so that it wakes up only on some external event.\n\n   To engage in network activity, a process attaches a local socket to\n   one of its ports.  Sockets are identified by user number, host and\n   AEN; a socket is local to a process if the user numbers of the two\n   match and they are in the same host.  Thus, a process need only\n   specify an AEN when it is referring to a local socket.\n\n   Each port has a status which is modified by system calls and\n   concurrent events outside the process (e.g., a 'close connection'\n   command from a foreign host).  The process may look at a port's\n   status as any time (via the STATUS system call).\n\n   We assume a one-to-one correspondence between ports and sockets.\n\nIII. System Calls\n\n   These are typical system calls which a user process might execute.\n\n         We use the notation\n\n                  SYSCALL (ARG1, ARG2....)\n\n         where\n                  SYSCALL is the name of the system call\n         and\n                  ARGk, etc. are the parameters of the system call.\n\n\n\n\n\n\n\n\nNewkirk, et al.                                                 [Page 2]\n\f\nRFC 55             Prototypical Implementation of NCP          June 1970\n\n\n   CONNECT (P, AEN, FS, CR)\n\n         P        specifies a port of the process\n         AEN      specifies a local socket; the user number and host are\n                  implicit\n         FS       specifies a socket with any user number in any hose,\n                  and with any AEN\n         CR       the condition code returned\n\n      CONNECT attempts to attach the local socket specified by AEN to\n      the port P and to initiate a connection with a specific foreign\n      socket, FS.  Possible values of CR are:\n\n         CR=OK          The CONNECT was legal and the socket FS is being\n                        contacted.  When the connection is established\n                        or refused the status will be updated.\n\n         CR = BUSY      The local socket is in use (illegal command\n                        sequence).\n\n         CR = BADSKT    The socket specification was illegal.\n\n         CR = NOROOM    Local host's resources are exhausted.\n\n         CR = HOMOSEX   Incorrect send/receive pair\n\n         CR = IMP DEAD  Our imp has died\n\n         CR = LINK DEAD The link to the foreign host is dead because:\n                        1. the foreign Imp is dead,\n                        2. the foreign host is dead, or\n                        3. the foreign NCP does not respond.\n\n   LISTEN (P, AEN, CR)\n\n         P             specifies a port of the process\n         AEN           specifies a local socket\n         CR            the condition code returned\n\n      The local socket specified by AEN is attached to port P.  If there\n      is a pending call, it is processed; otherwise, no action is taken.\n      When a call comes in, the user will be notified.  After examining\n      the call, he may either accept or refuse it.  Possible values of\n      CR are:\n\n         CR = OK         Connection begun, listening\n\n         CR = BUSY\n\n\n\nNewkirk, et al.                                                 [Page 3]\n\f\nRFC 55             Prototypical Implementation of NCP          June 1970\n\n\n         CR = NOROOM\n\n         CR = IMP DEAD\n\n         CR = LINK DEAD\n\n   ACCEPT (P, CR)\n\n         P       specifies a port of the process\n         CR      the condition code returned\n\n      Accept implies that the user process has inspected the foreign\n      socket to determine who is calling and will accept the call.\n      (Note: an interesting alternative defines ACCEPT as the implicit\n      default condition.  Thus any incoming RFC automatically satisfies\n      a LISTEN.)  Possible values of CR are:\n\n         CR = BADSKT\n\n         CR = NOROOM\n\n         CR = IMP DEAD\n\n         CR = LINK DEAD\n\n         CR = BADCOMM   Illegal command sequence. (E.g., Accept issued\n                        before a LISTEN.\n\n         CR = PREMCLS   Foreign user aborted connection after RFC was\n                        locally received but before Accept was executed.\n\n   TRANSMIT (P, BUFF, BITSRQST, BITSACC, CR)\n\n         P        specifies a port of the process\n         BUFF     specifies the text buffer for transmission\n         BITSRQST specifies the length to be transmitted in bits\n         BITSACC  returns the number of bits actually transmitted\n         CR       the condition code returned\n\n       Transmission takes place.   Possible values for CR are:\n\n         CR = OK\n\n         CR = IMP DEAD\n\n         CR = LINK DEAD\n\n\n\n\n\nNewkirk, et al.                                                 [Page 4]\n\f\nRFC 55             Prototypical Implementation of NCP          June 1970\n\n\n         CR = NOT OPEN  Connection is not open (illegal command\n                        sequence).\n\n         CR = BAD BOUND BITSRQST out of bounds (e.g., for a receive\n                        socket BUFF was shorter than BITSRQST\n                        indicated).\n\n   INT (P, CR)\n\n         P       specifies the local socket of this process\n         CR      the condition code returned\n\n      The process on the other (foreign) side of this port is to be\n      interrupted.  Possible values of CR are:\n\n         CR = OK\n\n         CR = BADSKT\n\n         CR = BADCOMM\n\n         CR = IMP DEAD\n\n         CR = LINK DEAD\n\n   STATUS (P, RTAB, CR)\n\n         P       specifies a port of this process\n         RTAB    the returned rendezvous table entry\n         CR      the condition code returned\n\n      The relevant fields of the rendezvous table entry associated with\n      this port are returned in RTAB.  This is the mechanism a user\n      process employs for monitoring the state of a connection.\n      Possible values of CR are:\n\n         CR = OK\n\n         CR = BADSKT\n\n\n\n\n\n\n\n\n\n\n\n\nNewkirk, et al.                                                 [Page 5]\n\f\nRFC 55             Prototypical Implementation of NCP          June 1970\n\n\n   CLOSE (P, CR)\n\n         P       specifies a port of this process\n         CR      the condition code returned\n\n      Activity on the connection attached to this port stops, the\n      connection is broken and the port becomes free for other use.\n      Possible values of CR are:\n\n         CR = OK\n\n         CR = BADSKT\n\n         CR = BADCOMM\n\n         CR = IMP DEAD\n\n         CR = LINK DEAD\n\n\n\nIV.  The NCP - Gross Structure\n\n   We view the NCP as having five component programs, several\n   associative tables, and some queues and buffers.\n\n      The Component Programs (see Fig. 4.1)\n\n      1. The Input Handler\n\n         This is an interrupt-driven routine.  It initiates Imp-to-Host\n         transmission into a resident buffer and wakes up the input\n         interpreter when transmission is complete.\n\n      2. The Output Handler\n\n         This is an interrupt-driven output routine.  It initiates Host-\n         to-Imp transmission out of a resident buffer and wakes up the\n         output scheduler when transmission is complete.\n\n      3. The Input Interpreter\n\n         This program decides whether the input is a regular message\n         intended for a user, a network control message, an Imp-to Host\n         message, or an error.  For each class of message this program\n         invokes a subroutine to take the appropriate action.\n\n\n\n\n\nNewkirk, et al.                                                 [Page 6]\n\f\nRFC 55             Prototypical Implementation of NCP          June 1970\n\n\n      4. The Output Scheduler\n\n         Three classes of messages are sent to the Imp\n\n            (a) Host-to-Imp messages\n            (b) Control messages\n            (c) Regular messages\n\n         We believe that a priority should be imposed among these\n         classes.  The priority we suggest is the ordering above.  The\n         output scheduler selects the highest priority message and\n         passes it to the output handler.\n\n         Host-to-Imp messages are processed first come first served.\n         Control messages are processed individually by host, each host\n         being taken in turn.  A control message queue for each foreign\n         host is provided.  When any particular host is scheduled for\n         output, as many control commands for that host as will fit are\n         concatenated into a single message.  Regular messages are\n         processed in groups by host and link, each unique combination\n         being taken in turn.\n\n      5. The System Call Interpreter\n\n         This program interprets requests from the user.  Each system\n         call has a corresponding routine which takes the appropriate\n         action.\n\n      The two interesting components are the input interpreter and the\n      system call interpreter.  These are similar in that the input\n      interpreter services foreign requests and the system call\n      interpreter services local requests.\n\n      The diagram in Figure 4.1  is our conception of the Network\n      Control Program.  Squishy amoeba-like objects represent component\n      programs, cylinders represent queues, and the arrows represent\n      data paths.  In this simplified diagram tables are not shown.\n      [\"Amoeba-like\" objects in original hand drawing are now firm\n      rectangular boxes: Ed.]\n\n      The abbreviated labels in the figure have the following meanings:\n\n            HIQ       -     Host-to-Imp Queue\n            OCCQ      -     Output Control Command Queue\n            DQ        -     Data Queue\n            IHBUF     -     Input Handler Buffer\n            OHBUF     -     Output Handler Buffer\n\n\n\n\nNewkirk, et al.                                                 [Page 7]\n\f\nRFC 55             Prototypical Implementation of NCP          June 1970\n\n\n             ____________\n            |    USER    |    STRUCTURE OF THE NETWORK CONTROL PROGRAM\n            |____________|\n               ^      |                      Fig. 4.1\n          _____|______V____\n         |                 |\n         |     System      |\n         |      Call       |\n         |   Interpreter   |\n         |_________________|              _____________\n            ^  |      |                  |             |\n            |  |      |  +---------------|    Input    |\n            |  |      |  |         +-----| Interpreter |\n            |  |      |  |         |     |             |\n            |  V      V  V         V      -------------\n          |======| |=========| |=======|     |      ^\n          | D Q  | | O C C Q | | H I Q |     |      |\n          |======| |=========| |=======|     |      |\n            |  ^        |          |         |      |\n            |  |        |          |         |      |\n            |  +--------)----------)---------+      |\n            |           |          |                |\n            +-------+   |   +------+                |\n                  __V___V___V__                     |\n                 |             |                    |\n                 |   Output    |                    |\n                 |  Scheduler  |                    |\n                 |_____________|                    |\n                        |                           |\n                        V                           |\n                  (===========)               (===========)\n                  ( O H B U F )               ( I H B U F )\n                  (===========)               (===========)\n                        |                           ^\n                  ______V______               ______|______\n                 |             |             |             |\n                 |   Output    |             |    Input    |\n                 |   Handler   |             |   Handler   |\n                 |             |             |             |\n                  -------------               -------------\n                        |                           ^\n                        |                           |\n                        +----------+    +-----------+\n                                   |    |\n                               ____V____|____\n                              |              |\n                              |     I M P    |\n                              |______________|\n\n\n\nNewkirk, et al.                                                 [Page 8]\n\f\nRFC 55             Prototypical Implementation of NCP          June 1970\n\n\nV. Tables in the NCP\n\n   We envision that the bulk of the NCP's data base is in associative\n   tables.  By \"associative\" we mean that there is some lookup routine\n   which is presented with a key and either returns successfully with a\n   pointer to the corresponding entry, or fails if no entry corresponds\n   to the key.  The major tables are as follows:\n\n      1. The Rendezvous Table\n\n         This table holds the attributes of a connection.  The table is\n         accessed by the local socket, but other tables may have\n         pointers to existing entries.\n\n         The components of an entry are:\n\n            (a) Local Socket\n            (b) Foreign Socket\n            (c) Link\n            (d) Connection State\n            (e) Flow State\n            (f) Data Queue\n            (g) Call Queue\n            (h) Port Pointer\n            (i) Their Buffer Size (only needed on the send side)\n            (j) Error State\n\n         An entry is created when either a CONNECT or a LISTEN system\n         call is executed or when a request for connection is received.\n         Various fields remain unused until after the connection is\n         established.\n\n      2. The Input Link Table\n\n         The input interpreter uses the concatenation of the foreign\n         host and link as a key into the input table.  The table is used\n         in processing a user-destined message on an incoming link by\n         providing a pointer into the rendezvous table.\n\n      3. The Output Link Table\n\n         The input interpreter uses the output link table to access the\n         flow state as RFNM's return from transmitted messages.  The\n         output link table is keyed by host and link and provides a\n         pointer into the rendezvous table.\n\n\n\n\n\n\nNewkirk, et al.                                                 [Page 9]\n\f\nRFC 55             Prototypical Implementation of NCP          June 1970\n\n\n      4. The Port Table\n\n         The system call interpreter uses the concatenation of the\n         process identification and the port identification as a key to\n         obtain a pointer into the rendezvous table.\n\n      5. The Output Control Command Table\n\n         The system call interpreter and the input interpreter use this\n         table to make entries in the appropriate output control command\n         queues.  Commands are queued in separate table entries\n         corresponding to foreign hosts.  Before output the contents of\n         the queue are concatenated into a large control message.  The\n         components of an entry are:\n\n            (a)  Host\n            (b)  Output Control Command Queue\n\n      6. The Output Request Queue\n\n         This queue contains an entry for each connection which has data\n         requiring transmission to the net.  There is only one entry per\n         connection, which is deleted when the last packet of data is\n         transmitted and is entered whenever a user makes a system\n         request for data transmission.\n\n         The entry is re-inserted if transmission is not completed\n         (message too long) or is prevented by the flow control\n         mechanism.  The only component of an entry is a local socket.\n\n      7. The Host Live Table\n\n         This is a simple table listing the hosts which are alive.  This\n         table is checked before establishing a connection and before\n         sending any data to ensure that the destination host actually\n         exists.  At present the protocol does not define the procedure\n         to be followed for the Host up/Host down conditions.  See\n         NWG/RFC#57.\n\n      8. The Link Assignment Table\n\n         Link numbers are assigned by the receiver.  This table records\n         which links are free and can, therefore, be assigned.\n\n\n\n\n\n\n\n\nNewkirk, et al.                                                [Page 10]\n\f\nRFC 55             Prototypical Implementation of NCP          June 1970\n\n\nVI.  Informal Description of Network Operations\n\n   We present here narratives describing the operation conducted during\n   the three major phases of network usage: opening, flow control, and\n   closing.\n\n   A. Opening\n\n      In order to establish a connection for data transmission, a pair\n      of RFC's must be exchanged.  An RTS must go from the receive-side\n      to the send-side, and an STR must be issued by the send-side to\n      the receive-side.  In addition, the receive-side, in its RTS, must\n      specify a link number.  These RFC's (RFC is a generic term\n      encompassing RTS and STR) may be issued in any time sequence.  A\n      provision must also be made for queuing pending calls (i.e., RFC's\n      which have not been dealt with by the user program).  Thus, when a\n      user is finished with a connection, he may choose to examine the\n      next pending call from another process and decide to either accept\n      or refuse the request for connection.  A problem develops because\n      the user may not choose to examine his pending calls; thus they\n      will merely serve to occupy queue space in the NCP.  Several\n      alternative solutions to this problem will be mentioned later.\n\n      Utilizing the framework of the prototype system calls described\n      above, we envision at least four temporal sequences for obtaining\n      a successfully opened connection:\n\n         1. The user may issue a LISTEN, indicating he is willing to\n            consider connecting to anyone who sends him an RFC.  When an\n            RFC comes in the user is notified.  The user then decides\n            whether he wishes to connect to this socket and issues an\n            ACCEPT or a CLOSE on the basis of that decision.  A CLOSE '\n            refuses' the connection, as discussed under \"Closing.\"  An\n            ACCEPT indicates he is willing to connect; an RFC is issued,\n            and the connection becomes fully opened.\n\n         2. Upon processing a user request for a LISTEN, the NCP\n            discovers that a pending call exists for that local socket.\n            The user is immediately notified, and he may ACCEPT or\n            CLOSE, as above.\n\n         3. The user issues a CONNECT, specifying a particular foreign\n            socket that he would like to connect to.  An RFC is issued.\n            If the foreign process accepts the request, it answers by\n            returning an RFC.  When this acknowledging RFC is received,\n            the connection is opened.\n\n\n\n\n\nNewkirk, et al.                                                [Page 11]\n\f\nRFC 55             Prototypical Implementation of NCP          June 1970\n\n\n         4. When presented with a CONNECT, the NCP may discover that a\n            pending call exists from the specified foreign socket to the\n            local socket in question.  An acknowledging RFC is issued\n            and the connection is opened.\n\n      In all of the above cases the user is notified when the connection\n      is opened, but data flow cannot begin until buffer space is\n      allocated and an ALL command is transmitted.\n\n      Any of these connection scenarios will be interrupted if a CLS\n      comes in, as discussed under \"Closing.\"\n\n         1. Pending Call Queues\n\n            It is essential that some form of queuing for pending RFC's\n            be implemented.  A simple way to see this is to examine a\n            typical LISTEN-CONNECT sequence.  One side issues a LISTEN,\n            the other a CONNECT.  If the LISTEN is issued before the RFC\n            coming from the remote CONNECT arrives, all is fine.\n            However, due to the asynchronous nature of the net, we can\n            never guarantee that this sequence of events will occur.  If\n            calls are not queued, and the RFC comes in before the LISTEN\n            is issued, it will be refused; if it arrives later, it will\n            be accepted.  Thus we have an extremely ambiguous situation.\n\n            Unless one has infinite queue space, it is desirable that\n            some mechanism for purging the queues of old RFC's which the\n            user never bothered to examine.  An obvious but informal\n            method is to note the time when each RFC is entered into the\n            queue, and then periodically refuse all RFC's which have\n            exceeded some arbitrary time limit.  Another thought, which\n            probably should be included within the context of any\n            scheme, is for the NCP to send a CLS on all outstanding\n            connections or pending calls when a user logs out or blows\n            up.\n\n            The scheme which is utilized in this description may seem at\n            first blush to be non-intuitive; but we feel it is more\n            realistic than other proposals.  Basically, when a CONNECT\n            is issued, the NCP assumes that this socket wishes to talk\n            to the specified foreign socket and to that socket only.  It\n            therefore purges from the pending call queue all non-\n            matching RFC's by sending back CLS's.  Similarly, when the\n            connection is in the RFC-SEND state (a CONNECT has been\n            issued), all non-matching RFC's are refused.  If a LISTEN-\n            ACCEPT or LISTEN- CLOSE sequence is executed, the remainder\n\n\n\n\n\nNewkirk, et al.                                                [Page 12]\n\f\nRFC 55             Prototypical Implementation of NCP          June 1970\n\n\n            of the pending calls are not removed from the queue, in the\n            expectation that the user may wish to accept these requests\n            in the future.\n\n            Although the latter method may seem to be arbitrary and/or\n            unnecessarily restrictive, we have not yet concocted a\n            scenario which would be prohibited by this method, assuming\n            that we are dealing with a competent programmer (i.e., one\n            who is wary of race conditions and the asynchronous nature\n            of the net).  Of course whatever scheme or schemes a\n            particular site chooses is highly implementation dependent;\n            we suggest that some provision for the queuing of RFC's be\n            provided for a period of time at least of the order of\n            magnitude that they are retained in the CONNECT-clear scheme\n            mentioned above.\n\n   B. Flow Control\n\n      Meaningful data can only flow on a connection when it is fully\n      opened (i.e., two RFC's have been exchanged and closing has not\n      begun).  We assume that the NCP's have a buffer for receiving\n      incoming data and that there is some meaningful quantity which\n      they can advertise (on a per connection basis) indicating the size\n      message they can handle.  We further assume that the sending side\n      regulates its transmission according to the advertisements of that\n      size.\n\n      When a connection is opened, a cell (called 'Their Size') is set\n      to zero.  The receive-side will decide how much space it can\n      allocate and send an ALL message specifying that space.  The\n      send-side will increment 'Their Size' by the allocated space and\n      will then be able to send messages of length less than or equal to\n      'Their Size' When messages are transmitted, the length of the\n      message is subtracted from 'Their Size'.  When the receive-side\n      allocates more buffer space (e.g. when a message is taken by the\n      user, thus freeing some system buffer space), the number of bits\n      released is sent to the send-side via an ALL message.\n\n      Thus, 'Their Size' is never allowed to become negative and no\n      transmission can take place if 'Their Size' equals zero.\n\n      Notice that the lengths specified in ALL messages are increments\n      not the absolute size of the receiving buffer.  This is\n      necessitated  by the full duplex nature of the flow control\n      protocol.  The length field of the ALL message can be 32 bits long\n      (note: this is an unsigned integer), thus providing the facility\n      for essentially an infinite \"bit sink\", if that may ever be\n      desired.\n\n\n\nNewkirk, et al.                                                [Page 13]\n\f\nRFC 55             Prototypical Implementation of NCP          June 1970\n\n\n   C. Closing\n\n      Just as two RFC's are required to open a connection, two CLS's are\n      required to close a connection.  Closing occurs under various\n      circumstances and serves several purposes.  To simplify the\n      analysis of race conditions, we distinguish four cases: aborting,\n      refusing, termination by receiver, termination by sender.\n\n      A user \"aborts\" a connection when he issues a CONNECT and then a\n      CLOSE before the CONNECT is acknowledged.  Typically a user will\n      abort following an extended wait for the acknowledgment; his\n      system may also abort for him if he blows up.\n\n      A user \"refuses\" a connection when he issues a LISTEN and, after\n      being notified of a prospective caller, issues a CLOSE.  Any\n      requests for connection to a socket which is expecting a call from\n      a particular socket are also refused.\n\n      After a connection is established, either side may terminate.  The\n      required sequence of events suggests that attempts to CLOSE by the\n      receive-side should be viewed as \"requests\" which are always\n      honored as soon as possible by the send-side.  Any data which has\n      not yet been passed to the user, or which continues over the\n      network, is discarded.  Requests to CLOSE by the send-side are\n      honored as soon as all data transmission is complete.\n\n         1. Aborting\n\n            We may distinguish three cases:\n\n            a) In the simplest case, we send an RFC followed later by a\n               CLS.  The other side responds with a CLS and the attempt\n               to connect ends.\n\n            b) The foreign process may accept the connection\n               concurrently with the local process aborting it.  In this\n               case, the foreign process will believe the local process\n               is terminating an open connection.\n\n            c) The foreign process may refuse the connection\n               concurrently with the local process aborting it.  In this\n               case, the foreign process will believe the local process\n               is acknowledging its refusal.\n\n\n\n\n\n\n\n\nNewkirk, et al.                                                [Page 14]\n\f\nRFC 55             Prototypical Implementation of NCP          June 1970\n\n\n         2. Refusing\n\n            After an RFC is received, the local host may respond with an\n            RFC or a CLS, or it may fail to respond.  (The local host\n            may have already sent its own RFC, etc.)  If the local host\n            sends a CLS, the local host is said to be \"refusing\" the\n            request for connection.\n\n            We require that CLS commands be exchanged to close a\n            connection, so it is necessary for the local host to\n            maintain the rendezvous table entry until an acknowledging\n            CLS is returned.\n\n         3. Terminating by the Sender\n\n            When the user on the send side issues a CLOSE system call,\n            his NCP must accept it immediately, but may not send out a\n            CLS command until all the data in the local buffers has been\n            passed to the foreign host.  It is thus necessary to test\n            for both 'buffer-empty' and\n            'RFNM-received' before sending the CLS command.  As usual,\n            the CLS must be acknowledged before the entry may be\n            deleted.\n\n         4. Terminating by the Receiver\n\n            When the user on the receive side issues a CLOSE system\n            call, his NCP accepts and sends the CLS command immediately.\n            Data may still arrive, however, and this data should be\n            discarded.  The send side, upon receiving the CLS, should\n            immediately terminate the data flow.\n\nVII. Connection Status\n\n   An excellent mechanism for describing the sequence of events required\n   to establish and terminate a connection involves a state diagram.  We\n   may assume that each socket can be associated with a state machine,\n   and that this state machine may, at any time, be in one of ten\n   possible states.  In any state, certain network events cause the\n   connection status to enter another state; other events are ignored;\n   still others are error.  A transition may also involve the local NCP\n   performing some action.  Figure 7.1 depicts the state machine.\n   Circles [now boxes: Ed] represent states (described below); arrows\n   show legal transitions between states.  The labels on the arrows\n   identify the event which caused them (note that CLOSE is a system\n   call, CLS is a control command).  Phrases after slashes denote the\n   action which should  be performed while traveling over that arrow.\n   The arrow labeled '[E]RFC' (found between states 0 and 1) represents\n\n\n\nNewkirk, et al.                                                [Page 15]\n\f\nRFC 55             Prototypical Implementation of NCP          June 1970\n\n\n   the condition that whenever a connection enters the CLOSED state, the\n   pending call queue for that connection is checked [Original was\n   backwards \"E\": Ed.]\n\n   If any pending calls exist in the queue, the connection moves to the\n   PENDING state.  If an RFC is received for a socket in the CLOSED\n   state, it is also moved along this path to the PENDING state.  Events\n   and the actions they cause are described in sections VIII and IX\n   below.  Descriptions of the ten states follow:\n\n      (0) CLOSED\n\n          The local socket is not attached to any port and no user has\n          requested a connection with it.  (The table entry is non-\n          existent).\n\n      (1) PENDING CALL\n\n          The socket is not attached to any port but one or more\n          requests for connection have been received.  A LISTEN system\n          call will be satisfied immediately by the first entry in the\n          pending call queue for a matching request; all other pending\n          calls are deleted.\n\n      (2) LISTENING\n\n          The socket is attached to a port.  We are waiting for a user\n          to request connection with this socket.\n\n      (3) RFC-RCVD\n\n          We are listening and an RFC was received.  The local user has\n          been informed of the pending call.  He must respond with\n          either a CLOSE or an ACCEPT.\n\n      (4) ABORT\n\n          We have notified the user that his LISTEN has been satisfied\n          but he has not yet responded; if during this time the foreign\n          user aborts the connection by sending a CLS, we send a CLS to\n          acknowledge the abort and mark the fact with this state.  When\n          the user accepts or refuses the call, we can inform him the\n          connection has been prematurely terminated.\n\n\n\n\n\n\n\n\nNewkirk, et al.                                                [Page 16]\n\f\nRFC 55             Prototypical Implementation of NCP          June 1970\n\n\n      (5) RFC-SENT\n\n          This state is entered when:\n\n          a)  The local user has attached this socket to a port by\n              issuing a CONNECT.\n          b)  An RFC has been sent, and\n          c)  No reply has been received.\n\n          When the user issues a CONNECT the pending call queue is\n          searched.\n\n          If a matching RFC is not found, the queue is deleted and this\n          state is entered.  As new RFC's arrive they are compared with\n          our user's request.  If they do not match, the RFC is\n          immediately refused.  If the RFC matches, it completes the\n          initialization process and the connection enters the OPEN\n          state.\n\n      (6) OPEN\n\n          RFC's have been exchanged and the connection is securely\n          established.  Transmission may begin following receipt of an\n          ALL command from the receive side, and will then proceed\n          subject to flow control.\n\n      (7) CLS-WAIT\n\n          After the local user has executed a CLOSE, and we have issued\n          a CLS, we must wait for an acknowledging CLS before the\n          connection can be completely closed.   If the appropriate CLS\n          has not already been received, this state is entered.\n\n      (8) DATA-WAIT\n\n          If we are on the send side and the local user executes a CLOSE\n          system call, a CLS cannot be issued if our data buffer is not\n          empty or if a RFNM for the last data message is outstanding.\n          The connection enters this state to wait for these conditions\n          to be fulfilled.  Upon completion and acknowledgement of\n          output a CLS may be issued and the connection enters the CLS-\n          WAIT state, waiting for the acknowledging CLS.   If a CLS\n          arrives while in the DATA-WAIT state we clear our buffer (the\n          CLS came from a receive socket, indicating it is no longer\n          interested in our data) and enter the RFNM-WAIT state to wait\n          for the network to clear.\n\n\n\n\n\nNewkirk, et al.                                                [Page 17]\n\f\nRFC 55             Prototypical Implementation of NCP          June 1970\n\n\n      (9) RFNM-WAIT\n\n          If we are on the send side and a CLS command arrives, we\n          cannot issue an acknowledging CLS if we have not received the\n          RFNM for our last data message.  We enter this state to await\n          the RFNM, and cease all further data transmission.  When the\n          RFNM comes in, a CLS may then be issued, and the connection\n          will be closed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNewkirk, et al.                                                [Page 18]\n\f\nRFC 55             Prototypical Implementation of NCP          June 1970\n\n\n                      ______________\n                     |              |       CLOSE\n      CONN/          |    CLOSED    |\u003c---------------------------+\n      send RFC       |     (0)      |       LISTEN               |\n    +----------------|              |-----------------------+    |\n    |                |______________|                       |    |\n    |                     |    ^                            |    |\n    |              [E]RFC |    |  CLS/send CLS              |    |\n    |                  ___V____|____                     ___V____|____\n    |  non-matching   |             |                   |             |\n    |  CONN/send RFC  |   PENDING   | LISTEN        RFC |  LISTENING  |\n    |   +-------------|    (1)      |----------+   +----|     (2)     |\n    |   |             |_____________|          |   |    |_____________|\n    |   |       matching     |                 |   |\n ___V___V_____  CONN/send RFC|               __V___V______\n|             |              |     ACCEPT/  |             | CLS/\n|   RFC-SENT  | RFC          |     send RFC |   RFC-RECD  | send CLS\n|     (5)     |----------+   |   +----------|     (3)     |---------+\n|_____________|          |   |   |          |_____________|         |\n   |   |                 |   |   |               |                  |\n   |   |              ___V___V___V___  SND\u0026CLOSE |   ____________   |\n   |   |    RCV\u0026CLS/ |               |-----------)-\u003e|            |  |\n   |   |    send CLS |      OPEN     | SND\u0026CLS   |  |  DATA-WAIT |  |\n   |   |   +---------|      (6)      |--------+  |  |    (8)     |  |\n   |   |   |         |_______________|        |  |  |____________|  |\n   |   |   |      RCV\u0026CLOSE/ |                |  |   |              |\n   |   |   |       send CLS  |                |  |   |              |\n   |   |   |                 |                |  |   | CLS          |\n   |   |   |           ______V______          |  |   |              |\n   |   |   |   CLOSE/ |             |CLOSE/   |  |   |              |\n   |   |   |  send CLS|   CLS-WAIT  |send CLS |  |   |              |\n   |   +---)---------\u003e|     (8)     |\u003c--------)--+   |              |\n   |       |          |_____________|         |      |              |\n   |       |                 |             ___V______V_       ______V___\n   |       |                 |            |            |     |          |\n   |       |                 |            |  RFNM-WAIT |     |   ABORT  |\n   |       |             CLS |            |     (9)    |     |    (4)   |\n   |       |                 |            |____________|     |__________|\n   |       |                 |                   |                 |\n   |       |           ______V_______  RFNM/     |                 |\n   |       |          |              | send CLS  |                 |\n   |  CLS/ +---------\u003e|    CLOSED    |\u003c----------+                 |\n   | send CLS         |     (0)      |                ACCEPT|CLOSE |\n   +-----------------\u003e|              |\u003c----------------------------+\n                      |______________|\n\n                         Figure 7.1\n                  Connection State Diagram\n\n\n\nNewkirk, et al.                                                [Page 19]\n\f\nRFC 55             Prototypical Implementation of NCP          June 1970\n\n\nVIII.  Algorithms for the Input Interpreter\n\n   The following is a concise description of the NCP's responses to\n   incoming network commands.  CS always indicates Connection State.\n   Note, CLOSE is a system call executed by the local user process, and\n   CLS is a network command.\n\n   NOP\n\n      Discard.\n\n   RFC (RTS or STR)\n\n      If no entry exists, create one with status = PENDING CALL, and\n      queue the message.\n\n      If CS = LISTENING, then queue the entry, enter the RFC-RCVD state,\n      and inform the user of the request.\n\n      If CS = RFC-SENT but the new RFC does not match the request,\n      refuse the RFC.\n\n      In all other cases, check the RFC for a match.  If none exists,\n      queue the RFC.  If the RFC matches, then if:\n\n         CS = RFC-SENT, we enter the OPEN state.\n\n         CS = CLOSE-WAIT, the RFC is ignored.\n\n         otherwise, the request is illegal in all states which indicate\n         it has already been received (these states are 1,3,4,6,8,9).\n\n      In any case, if processing the RFC causes an overflow condition\n      (resources are exhausted), refuse the connection (send a CLS).\n\n   CLS\n\n      The pending call queue is searched.  If the CLS doesn't match the\n      current request, but does match some other request, then delete\n      that request and issue a CLS.  If there is no match, the CLS is\n      ignored.\n\n      If the CLS matches the current request, and CS =\n\n         PENDING, then delete the current request.  If the request queue\n            is empty, delete the entry; otherwise, leave the entry\n            alone.\n\n\n\n\nNewkirk, et al.                                                [Page 20]\n\f\nRFC 55             Prototypical Implementation of NCP          June 1970\n\n\n         RFC-RCVD, Issue a CLS and enter the ABORT state.\n         ABORT, ignore.\n\n         RFC-SENT, issue a CLS.  If the pending call queue is empty\n            delete the entry, else enter the PENDING state.\n\n         OPEN, If we are on the receive side, response is identical to\n            the response for RFC-SENT.  If we are on the send side,\n            clear the data queue, and if a RFNM is still pending enter\n            the RFNM-WAIT state.  Otherwise response is identical to the\n            response for RFC-SENT.\n\n         CLS-WAIT, Issue a CLS and if the pending call queue is empty,\n            delete the entry, otherwise CS = PENDING.\n\n         DATA-WAIT, clear the data queue and enter the RFNM-WAIT state.\n            A matching CLS cannot occur in the CLOSED or LISTENING\n            states.\n\n   ERR\n\n      Errors are queued for later attention by system programmers, and\n      are considered to be a system error in the host that originated\n      the exchange.  (Not associated with any state).\n\n   ECO\n\n      The op code is changed to ERP and retransmitted (Not associated\n      with any state).\n\n   ERP\n\n      Upon receipt of an ERP, the system passes the text of the command\n      back to the process which issued the ECO.\n\n   INR, INS\n\n      These commands are enabled only in the OPEN state.  Upon receiving\n      an INTERRUPT, the system causes an event to be sent to the\n      associated process.  An INTERRUPT is ignored in the CLS-WAIT,\n      DATA-WAIT, and RFNM-WAIT states.  In any other state it is an\n      error.\n\n\n\n\n\n\n\n\n\nNewkirk, et al.                                                [Page 21]\n\f\nRFC 55             Prototypical Implementation of NCP          June 1970\n\n\n   ALL\n\n      ALLOCATE is valid only in the OPEN state, and may be sent only to\n      a send socket.  The NCP increments the 'Their Size' field in the\n      associated rendezvous table entry by the size specified in the\n      ALLOCATE command.\n\n      In the CLS-WAIT and DATA-WAIT states this command is ignored; in\n      any other state it is an error.\n\n   Data-RFNM\n\n      If in the OPEN state, mark the Flow Control Status field in the\n         appropriate rendezvous table entry as RFNM-RECVD, and send more\n         data if required.\n\n      If in the DATA-WAIT state, maintenance the Flow Control Status.\n         If the data queue is empty issue a CLS and enter the CLS-WAIT\n         state; otherwise, transmit the next message.\n\n      If in the RFNM-WAIT state, maintenance the Flow Control Status and\n         issue a CLS.  If the Pending Call queue is empty delete the\n         rendezvous table entry, otherwise CS = PENDING.\n\n      A Data-RFNM is an error in all other states.\n\nIX.  Algorithms for the System Call Interpreter\n\n   Each System Call is discussed, giving the state changes it may\n   effect:\n\n   CONNECT\n\n      If there is no entry, create one, issue an RFC, and enter the\n         RFC-SENT state.\n\n      If CS = PENDING, search the queue and reject all non-matching\n         requests.  If no match is found issue an RFC and enter the\n         RFC-SENT state.  If a match is found, issue an RFC and enter\n         the OPEN state.  Transmission can commence as soon as buffer\n         space has been allocated.\n\n      In any other state this command is illegal.\n\n   LISTEN\n\n      If an entry doesn't exist, create one, and enter the LISTENING\n         state.\n\n\n\nNewkirk, et al.                                                [Page 22]\n\f\nRFC 55             Prototypical Implementation of NCP          June 1970\n\n\n      If CS = PENDING, inform the user and enter the RFC-RCVD state.\n\n      In any other state this command is illegal.\n\n   ACCEPT\n\n      If CS = RFC-RCVD, then issue an RFC and enter the OPEN state.\n         Data transmission can occur as soon as buffer space is\n         allocated.\n\n      If CS = ABORT, inform the user of the premature termination of the\n         connection.  If the pending call queue is empty, delete the\n         entry; otherwise, enter the PENDING state.\n\n      This command cannot be legally executed in any other state.\n\n   CLOSE\n\n         If CS =\n\n      LISTENING, then delete the entry.\n\n      RFC-RCVD, then issue a CLS and enter the CLS-WAIT state.\n\n      ABORT, inform the user of the premature termination of the\n         connection.  If the pending call queue is empty, delete the\n         entry; otherwise, enter the PENDING state.\n\n      RFC-SENT, then issue a CLS and enter the CLS-WAIT state.\n\n      OPEN, if we are on the send side, and the data queue is not empty,\n         or if a Data-RFNM is still outstanding, enter the DATA-WAIT\n         state; otherwise, issue a CLS and enter the CLS-WAIT state.\n\n      CLS-WAIT, issuing a CLOSE in this state is a USER ERROR.\n\n      DATA-WAIT, issuing a CLOSE in this state is also an illegal\n         sequence.\n\n      RFNM-WAIT, ignore the CLOSE.\n\n      A valid CLOSE cannot be issued if an entry does not exist, or if a\n         socket is in the PENDING state.\n\n\n           [ This RFC was put into machine readable form for entry   ]\n           [ into the online RFC archives by Anthony Anderberg 5/00 ]\n\n\n\n\nNewkirk, et al.                                                [Page 23]\n\f\n"
}