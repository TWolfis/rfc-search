{
  "series": "Request for Comments",
  "number": "184",
  "howpublished": "RFC 184",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0184",
  "url": "https://www.rfc-editor.org/info/rfc184",
  "title": "Proposed graphic display modes",
  "pagetotal": "7",
  "year": "1971",
  "month": "jul",
  "body": "\n\n\n\n\n\nNetwork Working Group                                        Karl Kelley\nRequest for Comments 184                          University of Illinois\nNIC 7128                                                     6 July 1971\nCategory:  D.6\n\n\n                     Proposed Graphic Display Modes\n\n   The ARPA Network node at the University of Illinois' Center for\n   Advanced Computation is somewhat different from other nodes in that\n   we are not simply attaching an existing computer center to the net.\n   We are in the process of establishing the computer system\n   specifically for use of the ILLIAC IV and the Network.  In this mode\n   we are establishing operating systems, network interface and utility\n   routines, and ILLIAC IV routines to be used over the network.\n\n   In the field of computer graphics we are in the process of building a\n   system essentially from scratch.  The building blocks of this\n   capability comprise a small -- but growing -- collection of display\n   hardware and a small cadre of persons with experience on separate and\n   unique graphics equipment at the University of Illinois.  Starting as\n   we are with little-or-no system type software for computer graphics,\n   we have a once-only opportunity to provide the system with computer\n   graphics applications and utility programs which encompass all the\n   features and capabilities that have heretofore been available only in\n   bits and pieces at various separate installations.\n\n   It is apparent at the outset that the design for this system will be\n   heavily weighted toward a network-type usage.  For this reason we are\n   eager to ensure that our system data structures, files, etc., be as\n   nearly compatible the Network Graphics Protocol as is practicable.\n   Our initial planning and first-version system will be pointed at the\n   network type of operation and we hope to stay flexible enough to\n   employ the Network Protocol on a local basis (between our PDP-11 and\n   the B6500) as the protocol is developed.\n\n   We have been considering (in the planning of our system and pondering\n   the protocol problem) just what display modes we would want to have\n   available and thus would want the protocol to include.  The purpose\n   of this RFC is to outline our initial thoughts on the matter and to\n   interact with other nodes about how they can/should be included in\n   the protocol.  We intend here not to belabor display modes which are\n   certain to be needed everywhere, such as vectors, points, and\n   characters, but rather to summarize those and outline in more detail\n   only those which are slightly different.\n\n\n\n\n\n\nKelley                                                          [Page 1]\n\f\nRFC 184              Proposed Graphic Display Modes          6 July 1971\n\n\n   The display system, and the network protocol, will require something\n   like the following list of display types:\n\n                                         /\n   1. Points                            | Including normal points,\n                                       \u003c  plot a symbol at a point, plot\n                                        | a point with intensity\n                                        \\\n\n                                        /\n   2. Lines(two-point)                  | These two (2 and 3) include\n                                       \u003c  visible and not visible, dotted,\n   3. Vectors (from present beam        | dashed, overbright, and ?\n               location to a point)     \\\n\n   4. Character Streams\n\n   5. Viewport and Window\n      Specifications (ala LDS-1)\n\n   6. Transformations (scaling and\n      rotation) of Instances\n\n   7. Equipment-Specific Byte Streams\n\n   8. Read-Back of Keyboards,\n      Function Buttons, Cursors, Etc.\n\n   It seems clear that some type of list or ring structure will be\n   needed to handle our display files.  Whether that structure need be a\n   part of the protocol is not evident (after all, you could just send\n   the equipment byte-stream), but it is our feeling that it will be\n   needed.  It is evident that the protocol must anticipate the needs of\n   various popular display devices as CalComp, Computek, and similar\n   storage displays, interactive displays such as Adage, LDS-1, Vector\n   General, IDIOM, grey-level displays like the PEP-1 and raster-\n   oriented gadgets like the Gould, Versatec, and garden-variety line\n   printers.\n\n   The standard display element types given above are assumed to be in\n   common use.  A point, for example, is a pen-down command followed by\n   a pen-up command on a plotter.  On an interactive device it is merely\n   an intensification of the beam.  To plot a symbol at a point the pen\n   (beam) is moved to the point with pen up (beam off) and then the\n   symbol is plotted incrementally with the pen down (beam on).\n   Graphics devices with beam intensity control will be expected to\n   handle the \"plot-point-with-intensity\" format.\n\n\n\n\nKelley                                                          [Page 2]\n\f\nRFC 184              Proposed Graphic Display Modes          6 July 1971\n\n\n   In terms of the standard display types the only difference between\n   lines of the two-point form and vectors is that in the former, four\n   data items are needed for each segment while in the latter, only two\n   data items are needed.  In either case, the user should be able to\n   reposition the pen (beam) absolutely by drawing an invisible line.\n   He should also be able to plot dotted or dashed lines without having\n   to separately specify each point or short vector.  In instances where\n   emphasis is needed it is useful to be able to selectively intensify a\n   line, or in the case of interactive displays, make it blink.\n\n   Character streams are used either for text or for labeling drawings.\n   In most applications the character stream is specified by its\n   starting location in screen coordinates, the number of characters,\n   and the location of a buffer of characters to be used.  In some\n   purely output graphics systems the character stream is specified via\n   a format similar to printer output, with the characters being placed\n   in the specified area on the display.\n\n   Items 5 and 6 of the above list primarily apply to displays like\n   Sketchpad and the Evans and Sutherland display.  Viewport is taken to\n   be synonymous with \"observer parameters in the object space\" while a\n   window means \"selected portion of the display surface\".\n   Transformations of instances refers to a feature of Sketchpad which\n   allows multiple uses of the same \"pattern\" for a graphical element.\n\n   Because new equipment is constantly coming into use, and special-\n   purpose equipment is available at some nodes, it is prudent to have\n   available a capability for sending equipment-specific information\n   over the net as a part of the protocol.  Such information would be in\n   the form of byte streams formatted according to the equipment\n   specifications and pointed at the proper node and equipment.  It\n   would not be expected that each node be able to interpret the\n   nonstandard byte stream.  Also very equipment specific is the\n   information passed from an interactive device back to the originating\n   program.  Elements such as joystick or cursor position, lightpen\n   hits, function buttons pressed, etc., are inherently dependent upon\n   the device employed.  Although these devices are widely used, their\n   general dependence upon display buffers, display lists, or interrupts\n   is of special concern to the network graphics protocol.\n\n   We are interested in expanding upon the uses of grey-scale display\n   modes for representation of computer-generated data and for three-\n   dimensional object representation.  To facilitate this, our system\n   will have available at least four, program-callable display element\n   types for production of pictures on grey-level display devices.  The\n   initial names for these modes are the procedure names: GRIDAREA,\n   MATRIXAREA, SCANLINE, and SCANPOINT.  The following paragraphs will\n   outline how the modes operate both from a user and a data-\n\n\n\nKelley                                                          [Page 3]\n\f\nRFC 184              Proposed Graphic Display Modes          6 July 1971\n\n\n   communications point of view.  The specific hardware involved is not\n   specified, nor do we ignore the possibility that hardware can be\n   designed to operate this way directly.  For example, the SCANLINE is\n   precisely the way one display does operate.  In the interim, however,\n   software sits between these procedures and actual devices.\n\n   GRIDAREA              The user specifies, in an initial call, the size\n   --------              grid he wishes to use and the number of intensity\n                         levels he will need.  Subsequent calls send, as\n                         data items, the i, j locations of an area and a\n                         byte for intensity.\n\n   The initializing call is GRIDSET(N, M, IRNGE)\n                                              |\u003c--- I ------\u003e|\n   where N is the number of spaces       ---  +--+--+--+--+--+--+--+--+\n   across, M is the number down,          ^   |--|--|--|--|--|--|--|--|\n   and IRNGE tells how many grey          |   |--|--|--|--|--|--|--|--|\n   levels to use.  This is primarily      J   |--|--|--|--|--|--|--|--|\n   for grey-scale displays or             |   |--|--|--|--|--|--|--|--|\n   pseudogrey-scale displays.             v   |--|--|--|--|--|--|--|--|\n                                         ---  |--|--|--|--|--|--|--|--|\n                                              |--|--|--|--|--|--|--|--|\n                                              +--+--+--+--+--+--+--+--+\n\n   On a Gould Electrostatic Printer-Plotter, for example, the system\n   would expect to have dot patterns with which to fill areas in order\n   to simulate the greys.  For purposes of other displays, a SETSQUARES\n   procedure should be available so that the user can specify various\n   kinds of cross- hatching and character filling to apply to the grid\n   areas.\n\n   To enter an item of data the procedure is\n\n                                              1 \u003c= I \u003c= N\n                  GRIDAREA(I, J, LEVEL)       1 \u003c= J \u003c= M\n                                              1 \u003c= LEVEL \u003c= IRNGE\n\n   where I and J select an area on the grid, and LEVEL tells how to fill\n   it.  Obviously, for this kind of display mode some provision must be\n   made to end the picture because the servicing routine will have to\n   work on it from either the top or the bottom in a sweep mode.  A\n   procedure call of GRIDAREA(0, 0, 0) will terminate it.  The GRIDAREA\n   mode is very similar to the following, MATRIXAREA, with the primary\n   difference being that the specification of areas is random and areas\n   which are not specified will be left blank.\n\n\n\n\n\n\nKelley                                                          [Page 4]\n\f\nRFC 184              Proposed Graphic Display Modes          6 July 1971\n\n\n   MATRIXAREA            The user specifies an area size and a \"pseudo-\n   ----------            character\" set, then writes from left to right,\n                         top to bottom, much like a line printer, using\n                         bytes to specify which of his \"pseudo-character\"\n                         set to use.\n\nThe initializing call is MATRIXSET(N, M, DEFINITION, CODE)\n\nThe display mode is raster                ________________________\noriented, and each \"pseudo-              |  _   _   _   _   _   _ |\ncharacter\" will be on a N x M            | |_| |_| |_| |_| |_| |_||\nmatrix of dots.  (A later                |  _   _   _             |\nembellishment for printers               | |_| |_| |_| . . .      |\nwould include matrix of characters.)     |  _   _                 |\nParameters DEFINITION and CODE           | |_| |_| . . .          |\nare both arrays, used together to        | .    \\ \\               |\nspecify the \"pseudo-character\" set.      | .     \\  \\             |\nDEFINITION is packed with bits           |________\\___\\___________|\naccording to the following scheme:                \\     \\\n                                                   \\      \\\n                                                    \\    __\\_______\n                                                     \\  /           \\\n                                                      \\/  ________   \\\n                                                      /   |_|_|_|_|   \\\n                                                     /    |_|_|_|_|    \\\n                                                     |    |_|_|_|_|    |\n                                                     |    |_|_|_|_|    |\n                                                     \\    |_|_|_|_|    /\n                                                      \\   |_|_|_|_|   /\n                                                       \\             /\n                                                        \\___________/\n\n     n - bits\n    +--+--+--+--+\n    |XX|  |  |XX|\n    |--|--|--|--|\ns   |  |XX|XX|  |\nt   |--|--|--|--|\ni   |XX|  |  |XX|\nb   |--|--|--|--        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--\\\n    |  |XX|XX|  |  \u003c=== |1|0|0|1|0|1|1|0|1|0|0|1|0|1|1|0|1|0|0|1|0|1|1|0|\\\n-   |--|--|--|--|       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\\\nm   |XX|  |  |XX|        \\--v--/ \\--v--/ \\--v--/ \\--v--/ \\--v--/ \\--v--/\n    |--|--|--|--|           n       n       n       n       n       n\n    |  |XX|XX|  |\n    +--+--+--+--+        \\-------------------------v---------------------/\n                                                   m-groups\n\n\n\n\nKelley                                                          [Page 5]\n\f\nRFC 184              Proposed Graphic Display Modes          6 July 1971\n\n\n   The bit stream for the definition is irrespective of word boundaries.\n   We leave it up to the MATRIXSET routine to be able to undo this.\n   Obviously, for user convenience we have some standard sets they can\n   use to save having to define their own, and if they want to define\n   their own, we make routines to ease the pain.\n\n   The array CODE, on the other hand, is a byte-stream, i.e., a stream\n   of eight-bit groups of bits which will correspond to each of the\n   groups of (N x M)-bits.  This allows 256 pseudocharacters for one\n   set.\n\n   To enter an item of data in this mode the procedure is\n\n                  MATRIXAREA(ARRAY, LENGTH)\n\n   ARRAY is a buffer location and length is the number of code bytes\n   which are to be put out.  Each call will put out one row of the\n   display.  Unused bytes at the end of the stream (bytes left over in\n   the last word) should be zero.  Any codes in excess of the maximum\n   number allowed on a line will be discarded.\n\n   It should be noted that this routine is nominally used for special\n   character sets, or for that matter, any character sets that are\n   software generated on dot-raster devices.  In addition, however, it\n   can be used for photomosaic displays, area filling on maps, and\n   development of capability of producing audiovisual aids for\n   presentations.\n\n\n   SCANLINE               A raster-scanning display mode for which the\n   --------               user specifies a raster size, number of grey\n                          levels needed, and direction of scan.  The\n                          subsequent data items specify only the location\n                          and character of a change in the scanning\n                          beam (or program).\n\n   The initializing procedure is SCANLINESET(DELTA, LEVELS, ORGMODE)\n\n   DELTA is an integer specifying the number of display points to be\n   included in each step.  LEVELS denotes the number of intensity levels\n   to be used, and the sign of ORGMODE specifies whether the scan is to\n   be from the bottom up (plus) or top down (minus) on the display.  For\n   both cases we will assume left-to-right.  The absolute value of\n   ORGMODE gives the starting Y position.\n\n   All subsequent calls to this routine are of the form\n\n                          SCANLINE(X, INTENSITY)\n\n\n\nKelley                                                          [Page 6]\n\f\nRFC 184              Proposed Graphic Display Modes          6 July 1971\n\n\n   The first such call denotes the origin in X and the initial\n   intensity.  Subsequent calls denote the X value of the next point on\n   the scan where the intensity is to change, and that new intensity.\n   The program (or device) takes care of the stepping of the scan by\n   DELTA across the page, with the current intensity.  Thus, the program\n   (device) only needs a data item for each change in the scan, not for\n   each position.  When the next X is less than the previous X, or the X\n   position has been stepped to its limit, the Y position in the\n   incremented or decremented to continue the scan on the next line.\n\n   We see the device which accepts such a display as accepting a stream\n   of triplets of bytes, where the first two bytes (16 bits) specify the\n   X and the third (8 bits) specifies the level.  The end of the stream\n   would be specified by three bytes of deletes (all ones).  This\n   display mode is implemented in hardware on the display at the\n   Coordinated Science Laboratory at this University.  It is the same\n   one which was used for the grey-scale work which has been reported by\n   Bouknight.\n\n\n   SCANPOINT            A point with intensity scanning mode in which\n   ---------            the scan is handled automatically and only the\n                        intensity of each point needs to be transmitted\n                        to the program (device).\n\n   The initializing call for this procedure is\n\n           SCANPOINTSET(DELTA, LEVELS, ORGMODE)\n\n   The arguments are the same as for SCANLINE.  The difference is in the\n   meaning of subsequent calls.  The origin for the scan is at the left\n   end of the line corresponding to the absolute value of ORGMODE.  The\n   stepping is done from left to right and at the end of each line, the\n   Y position is incremented or decremented by DELTA, according to the\n   sign of ORGMODE.\n\n   Subsequent calls to this procedure are of the form SCANPOINT(LEVEL)\n   where LEVEL denotes the intensity level at which the next point is to\n   be displayed.  In this mode every point must have its intensity\n   specified by a separate call to the routine (byte to the device).\n   However, beyond the starting point no position information is\n   required.\n\n\n       [ This RFC was put into machine readable form for entry ]\n        [ into the online RFC archives by Hamid Dastkar 09/99 ]\n\n\n\n\n\nKelley                                                          [Page 7]\n\f\n"
}