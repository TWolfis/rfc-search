{
  "series": "Request for Comments",
  "number": "61",
  "howpublished": "RFC 61",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0061",
  "url": "https://www.rfc-editor.org/info/rfc61",
  "title": "Note on Interprocess Communication in a Resource Sharing Computer Network",
  "pagetotal": "18",
  "year": "1970",
  "month": "jul",
  "body": "\n\n\n\n\n\nNetwork Working Group                                        Dave Walden\nRequest for Comments: 61                         Bolt Beranek and Newman\n                                                           July 17, 1970\n\n                  A Note on Interprocess Communication\n                in a Resource Sharing Computer Network\n\n\n   The attached note is a draft of a study I am still working on.  It\n   may be of general interest to network participants.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWalden                                                          [Page 1]\n\f\nRFC 61      Interprocess Communication in a Computer Network   July 1970\n\n\n                        Interprocess Communication\n                                   in a\n                     Resource Sharing Computer Network\n\nINTRODUCTION\n\n   \"A resource sharing computer network is defined to be a set of\n   autonomous, independent computer systems, interconnected so as to\n   permit each computer system to utilize all of the resources of each\n   other computer system.  That is, a program running in one computer\n   system should be able to call on the resources of the other computer\n   systems much as it would normally call a subroutine.\"  This\n   definition of a network and the desirability of such a network is\n   expounded upon by Roberts and Wessler in [1].\n\n   The actual act of resource sharing can be performed in two ways: in a\n   pairwise ad hoc manner between all pairs of computer systems in the\n   network or according to a systematic network wide standard.  This\n   paper develops one possible network wide system for resource sharing.\n\n   I believe it is natural to think of resources as being associated\n   with processes [2] and therefore view the fundamental problem of\n   resource sharing to be the problem of interprocess communication.  I\n   also share with Carr, Crocker, and Cerf [3] the view that\n   interprocess communication over a network is a subcase of general\n   interprocess communication in a multiprogrammed environment.\n\n   These views pervade this study and have led to a two part study.\n   First, a model for a time-sharing system having capabilities\n   particularly suitable for enabling interprocess communication is\n   constructed.  Next, it is shown that these capabilities can be easily\n   used in a generalized manner which permits interprocess communication\n   between processes distributed over a computer network.\n\n   This note contains ideas based on many sources.  Particularly\n   influential were -- 1) an early sketch of a Host protocol for the\n   ARPA Network [1][3][4] by W. Crowther of Bolt Beranek and Newman Inc.\n   (BBN) and S. Crocker of UCLA; 2) Ackerman and Plummer's paper on the\n   MIT PDP-1 time sharing system [5]; and 3) discussion with R. Kahn of\n   BBN about Host protocol, message control, and routing for the ARPA\n   Network.  Hopefully, there are also some original ideas in this note.\n   I alone am responsible for the collection of all of these ideas into\n   the system described herein, and I am therefore responsible for any\n   inconsistencies or bugs in this system.\n\n   It must be emphasized that this note does not represent an official\n   BBN position on Host protocol for the ARPA Computer Network.\n\n\n\n\nWalden                                                          [Page 2]\n\f\nRFC 61      Interprocess Communication in a Computer Network   July 1970\n\n\nA MODEL FOR A TIME-SHARING SYSTEM\n\n   This section describes a model time-sharing system which I think is\n   particularly suitable for performing interprocess communication.  The\n   basic structure of this model time-sharing system is not original\n   [5][9].\n\n   The model time-sharing system has two pieces: the monitor and the\n   processes.  The monitor performs several functions, including\n   switching control from process to process as appropriate (e.g., when\n   a process has used \"enough\" time or when an interrupt occurs),\n   managing core and the swapping medium, controlling the passing of\n   control from one process to another (i.e., protection mechanisms),\n   creating processes, caring for sleeping processes, etc.\n\n   The processes perform most of the functions normally thought of as\n   being supervisor functions in a time-sharing system (system\n   processes) as well as the normal user functions (user processes).  A\n   typical system process is the disc handler or the file system.  For\n   efficiency reasons it may be useful to think of system processes as\n   being locked in core.\n\n   A process can call on the monitor to perform several functions: start\n   another, equal, autonomous process (i.e., load a program or find a\n   copy of a program somewhere that can be shared, start it, and pass it\n   some initial parameters); halt the running process; put the current\n   process to sleep pending a specified event; send a message to a\n   specified process; become available to receive a message from a\n   specified process; become available to receive a message from any\n   process; send a message to a process able to receive from any\n   process; and request a unique number.  There undoubtedly should also\n   be other monitor functions.  It is left as an exercise to the reader\n   to convince himself that the monitor he is saddled with can be made\n   to provide these functions -- most can.\n\n   I will not concern myself with protection considerations here, but\n   instead will assume all of the processes are \"good\" processes which\n   never make any mistakes.  If the reader needs a protection structure\n   to keep in mind while he reads this note, the _capability_ system\n   described in [5][6][7][8] should be satisfying.\n\n   We now look a little closer at the eight operations listed above that\n   a process can ask the monitor to perform.\n\n\n\n\n\n\n\n\nWalden                                                          [Page 3]\n\f\nRFC 61      Interprocess Communication in a Computer Network   July 1970\n\n\n   START.  This operation starts another process.   It has two\n   parameters -- some kind of identification for the program that is to\n   be loaded and a parameter list for that program.   Once the program\n   is loaded, it is started at its given entry point and passed its\n   parameter list in some well known manner.  The process will continue\n   to exist until it halts itself.\n\n   HALT.  This operation puts the currently running process to sleep\n   pending the completion of some event.  The operation has one\n   parameter, the event to be waited for.  Sample events are arrival of\n   a hardware interrupt, arrival of a message from another process, etc.\n   The process is restarted at the instruction after the SLEEP command.\n   The monitor never unilaterally puts a process to sleep except when\n   the process overflows its quantum.\n\n   RECEIVE.  This operation allows another process to send a message to\n   this process.  The operation has four parameters: the port (defined\n   below) awaiting the message, the port a message will be accepted\n   from, a specification of the buffer available to receive the message,\n   and a location of transfer to when the transmission is complete.  [In\n   other words, an interrupt location.  Any message port may be used to\n   allow interrupts, event channels, etc.  The user programs what he\n   wants.]\n\n   SEND.  This operation sends a message to some other process.  [I\n   suppose a process could also send a message to itself.]  It has four\n   parameters: a port to send the message to, the port the message is\n   being sent from, the message, and a location to transfer to when the\n   transmission is complete.\n\n   RECEIVE ANY.  This operation allows any process to send a message to\n   this process.  The operation has four parameters: the port awaiting\n   the message, the buffer available to receive the message, a location\n   to transfer to when the message is received, and a location where the\n   port which sent the message may be noted.\n\n   SEND FROM ANY.  This operation allows a process to send a message to\n   a process able to receive a message from any process.  It has the\n   same four parameters as SEND.  The necessity for this operation will\n   be discussed below.\n\n   UNIQUE.  This operation obtains a unique number from the monitor.\n\n   A _port_ is a particular data path to or from a process.  All ports\n   have an associated unique number which is used to identify the port.\n   Ports are used in transmitting messages from one process to another\n   in the following fashion.  Consider two processes, A and B, wishing\n   to communicate.  Process A executes a RECEIVE at port N from port M.\n\n\n\nWalden                                                          [Page 4]\n\f\nRFC 61      Interprocess Communication in a Computer Network   July 1970\n\n\n   Process B executes a SEND to port N from port M.  The monitor matches\n   up the port numbers and transfers the message from process B to\n   process A.  As soon as the buffer has been fully transmitted out of\n   process B, process B is restarted at the location specified in the\n   SEND operation.  As soon as the message is fully received at process\n   A, process A is restarted at the location specified in the RECEIVE\n   operation.  Just how the processes come by the correct port numbers\n   with which to communicate with other processes is not the concern of\n   the monitor -- this problem is left to the processes.\n\n   An example.  Suppose that our model time-sharing system is\n   initialized to have several processes always running.  Additionally,\n   these permanent processes have some universally known and permanently\n   assigned ports.  [Or perhaps there is only one permanently known port\n   which belongs to a directory-process which keeps a table of\n   permanent-process/well-known-port associations.]  Suppose that two of\n   the permanently running processes are the logger-process and the\n   teletype-scanner-process.  When the teletype-scanner-process first\n   starts running, it puts itself to sleep awaiting an interrupt from\n   the hardware teletype scanner.  The logger-process initially puts\n   itself to sleep awaiting a message from the teletype-scanner-process\n   via well-known permanent SEND and RECEIVE ports.  The teletype-\n   scanner-process keeps a table indexed by teletype number containing\n   in each entry a port to send characters from that teletype to, and a\n   port at which to receive characters for that teletype.  If a\n   character arrives (waking up the teletype-scanner-process) and the\n   process does not have any entry for that teletype, it gets a pair of\n   unique numbers from the monitor (via UNIQUE) and sends a message\n   containing this pair of numbers to the logger-process using the ports\n   that the logger-process is known to have a RECEIVE pending for.\n   [Actually, the scanner process could always use the same pair of port\n   numbers for a particular teletype as long as they were passed on to\n   only one copy of the executive at a time.]  The scanner-process also\n   enters the pair of numbers in the teletype table, and sends the\n   characters and all future characters from this teletype to the port\n   with the first number from the port with the second number.  The\n   scanner-process probably also passes a second pair of unique numbers\n   to the logger-process for it to use for teletype output and does a\n   RECEIVE using these numbers.  The logger-process when it receives the\n   message from the scanner-process, starts up a copy of what SDS 940\n   TSS [12] users call the executive (that program which prints file\n   directories, tells who is on other teletypes, runs subsystems, etc.)\n   and passes this copy of the executive, the port numbers so this\n   executive-process can also do its in's and out's to the teletype\n   using these ports.  If the logger-process wants to get a job number\n   and password from the user, it can temporarily use the port numbers\n   to communicate with the user before it passes them on to the\n   executive.\n\n\n\nWalden                                                          [Page 5]\n\f\nRFC 61      Interprocess Communication in a Computer Network   July 1970\n\n\n   _Port numbers_ are often passed among processes.  More rarely, a port\n   is transferred to another process.  It is crucial that once a process\n   transfers a _port_ to some other process that the first process no\n   longer use the port.  We could add a mechanism that enforces this.\n   The protected object system of [8] is one such mechanism.  [Of\n   course, if the protected object system is available to us, there is\n   really no need for two port numbers to be specified before a\n   transmission can take place.  The fact that a process knows an\n   existing RECEIVE port number is prima facie evidence of the process'\n   right to send to that port.  The difference between RECEIVE and\n   RECEIVE ANY ports then depends solely on the number of copies of a\n   particular port number that have been passed out.  A system based on\n   this approach would clearly be preferable to the one described here\n   if it was possible to assume all of the autonomous time-sharing\n   system in a network would adopt this protection mechanism.  If this\n   assumption cannot be made, it seems more practical to require both\n   port numbers.]\n\n   Note that somewhere in the monitor there must be a table of  port\n   numbers associated with processes and restart locations.  The table\n   entries are cleared after each SEND/RECEIVE match is made.  Also note\n   that if a process is running (perhaps asleep), and has RECEIVE ANY\n   pending, then any process knowing the receive port number can talk to\n   that process without going through loggers or any of that.  This is\n   obviously essential within a local time-sharing system and seems very\n   useful in a more general network if the ideal of resource sharing is\n   to be reached.\n\n   When a SEND is executed, nothing happens until a matching RECEIVE is\n   executed.  If a proper RECEIVE is not executed for some time the SEND\n   is timed out after a while and the SENDing process is notified.  If a\n   RECEIVE is executed but the matching SEND does not happen for a long\n   time, the RECEIVE is timed out and the RECEIVing process is notified.\n\n   A RECEIVE ANY never times out, but may be taken back.  A SEND FROM\n   ANY message is always sent immediately and will be discarded if a\n   proper receiver does not exist.  An error message is not returned and\n   acknowledgment, if any, is up to the processes.  If the table where\n   the SEND and RECEIVE are matched up ever overflows, a process\n   originating a further SEND or RECEIVE is notified just as if the SEND\n   or RECEIVE timed out.\n\n   Generally, well known, permanently assigned ports are used via\n   RECEIVE ANY and SEND FROM ANY.  The permanent ports will most often\n   be used for starting processes going and consequently little data\n   will be sent via them.\n\n\n\n\n\nWalden                                                          [Page 6]\n\f\nRFC 61      Interprocess Communication in a Computer Network   July 1970\n\n\n   Still another example, this time a demonstration of the use of the\n   FORTRAN compiler.  We have already explained how a user sits down at\n   his teletype and gets connected to an executive.  We go on from\n   there.  The user is typing in and out of the executive which is doing\n   SENDs and RECEIVEs.  Eventually the user types RUN FORTRAN and the\n   executive asks the monitor to start up a copy of the FORTRAN compiler\n   and passes to FORTRAN as start up parameters the two ports the\n   executive was using to talk to the teletype.  FORTRAN is of course\n   expecting these parameters and does SENDs and RECEIVEs to these ports\n   to discover what input and output files the user wants to use.\n   FORTRAN types INPUT FILE? to the user who responds F001.  FORTRAN\n   then sends a message to the file-system-process which is asleep\n   waiting for something to do.  The message is sent via well-known\n   ports and it asks the file system to open F001 for input.  The\n   message also contains a pair of ports that the file-system-process\n   can use to send its reply.  The file-system looks up F001, opens it\n   for input, makes some entries in its open file tables, and sends a\n   message back to FORTRAN which contains the ports which FORTRAN can\n   use to read the file.  The same procedure is followed for the output\n   file.  When the compilation is complete, FORTRAN returns the teletype\n   port numbers back to the executive which has been asleep waiting for\n   a message from FORTRAN, and then FORTRAN halts itself.  The file-\n   system-process goes back to sleep when it has nothing else to do.\n\n   [The reader should have noticed by now that I do not like to think of\n   a new process (consisting of a new conceptual copy of a program)\n   being started up each time another user wishes to use the program.\n   Rather, I like to think of the program as a single process which\n   knows it is being used simultaneously by many other processes and\n   consciously multiplexes among the users or delays service to users\n   until it can get around to them.]\n\n   Again, the file-system-process can keep a small collection of port\n   numbers which it uses over and over if it can get file system users\n   to return the port numbers when they are done with them.  Of course,\n   when this collection of port numbers has eventually dribbled away,\n   the file system can get some new unique numbers from the monitor.\n\n   Note that when two processes wish to communicate they set up the\n   connection themselves, and they are free to do it in a mutually\n   convenient manner.  For instance, they can exchange port numbers or\n   one process can pick all the port numbers and instruct the other\n   process which to use.  Of course, in a particular implementation of a\n   time-sharing system, the builders of the system might choose to\n   restrict the processes' execution of SENDs and RECEIVEs and might\n   forbid arbitrary passing around of port numbers, requiring instead\n   that the monitor be called (or some other special program) to perform\n   these functions.\n\n\n\nWalden                                                          [Page 7]\n\f\nRFC 61      Interprocess Communication in a Computer Network   July 1970\n\n\n   Flow control is provided in this system by the simple method of never\n   starting a SEND from one process until a RECEIVE is executed by the\n   receiver.  Of course, interprocess messages may be sent back and\n   forth suggesting that a process stop sending or that space be\n   allocated, etc.\n\nINTERPROCESS COMMUNICATION BETWEEN REMOTE PROCESS\n\n   The system described in the previous section easily generalizes to\n   allow interprocess communication between processes at geographically\n   different locations as, for example, within a computer network.\n\n   Consider first a simple configuration of processes distributed around\n   the points of a star.  At each point of the star there is an\n   autonomous time-sharing system.  A rather large, smart computer\n   system, called the Network Controller, exists at the center of the\n   star.  No processes can run in this center system, but rather it\n   should be thought of as an extension of the monitor of each time-\n   sharing system in the network.\n\n   It should be obvious to the reader that if the Network Controller is\n   able to perform the operations SEND, RECEIVE, SEND FROM ANY, RECEIVE\n   ANY, and UNIQUE and that if all of the monitors in all of the time-\n   sharing systems in the network do not perform these operations\n   themselves but rather ask the Network Controller to perform these\n   operations for them, then we have solved the problem of interprocess\n   communication between remote processes.  We have no further change to\n   make.\n\n   The reason everything continues to work when we postulate the\n   existence of the Network Controller is that the Network Controller\n   can keep track of which RECEIVEs have been executed and which SENDs\n   have been executed and match them up just as the monitor did in the\n   model time-sharing system.  A networkwide port numbering scheme is\n   also possible with the Network Controller knowing where (i.e., at\n   which site) a particular port is at a particular time.\n\n   Next, consider a more complex network in which there is no common\n   center point making it necessary to distribute the functions\n   performed by the Network Controller among the network nodes.  In the\n   rest of this section I will show that it is possible to efficiently\n   and conveniently distribute the functions performed by the star\n   Network Controller among the many network sites and still enable\n   general interprocess communication between remote processes.\n\n   Some changes must be made to each of the four SEND/RECEIVE operations\n   described above to adapt them for use in a distributed network.  To\n   RECEIVE is added a parameter specifying a site to which the RECEIVE\n\n\n\nWalden                                                          [Page 8]\n\f\nRFC 61      Interprocess Communication in a Computer Network   July 1970\n\n\n   is to be sent.  To SEND FROM ANY and SEND is added a site to send the\n   SEND to although this is normally the local site.  Both RECEIVE and\n   RECEIVE ANY have added the provision for obtain the source site of\n   any received message.  Thus, when a RECEIVE is executed, the RECEIVE\n   is sent to the site specified, possibly a remote site.  Concurrently\n   a SEND is sent to the same site, normally the local site of the\n   process executing the SEND.  At this site, called the rendezvous\n   site, the RECEIVE is matched with the proper SEND and the message\n   transmission is allowed to take place to the site from whence the\n   RECEIVE came.\n\n   A RECEIVE ANY never leaves its originating site and therein lies the\n   necessity for SEND FROM ANY.  It must be possible to send a message\n   to a RECEIVE ANY port and not have the message blocked waiting for\n   RECEIVE at the sending site.  Of course, it would be possible to\n   construct the system so the SEND/RECEIVE rendezvous takes place at\n   the RECEIVE site and eliminate the SEND FROM ANY operation, but in my\n   judgment the ability to block a normal SEND transmission at the\n   source site more than makes up for the added complexity.\n\n   Somewhere at each site a rendezvous table is kept.  This table\n   contains an entry for each unmatched SEND or RECEIVE received at that\n   site and also an entry for all RECEIVE ANYs given at that site.  A\n   matching SEND/RECEIVE pair is cleared from the table as soon as the\n   match takes place or perhaps when the transmission is complete.  As\n   in the similar table kept in the model time-sharing system, SEND and\n   RECEIVE entries are timed out if unmatched for too long and the\n   originator is notified.  RECEIVE ANY entries are cleared from the\n   table when a fulfilling message arrives.\n\n   The final change necessary to distribute the Network Controller\n   functions is to give each site a portion of the unique numbers to\n   distribute via its UNIQUE operation.  I'll discuss this topic further\n   below.\n\n   To make it clear to the reader how the distributed Network Controller\n   works, an example follows.  The details of what process picks port\n   numbers, etc.  are only exemplary and are not a standard specified as\n   part of the system.\n\n   Suppose there are two sites in the network: K and L.  Process A at\n   site K wishes to communicate with process B at site L.  Process B has\n   a RECEIVE ANY pending at port M.\n\n\n\n\n\n\n\n\nWalden                                                          [Page 9]\n\f\nRFC 61      Interprocess Communication in a Computer Network   July 1970\n\n\n                    SITE K              SITE L\n                  ________            ________\n                 /        \\          /        \\\n                /          \\        /          \\\n               /            \\      /            \\\n              |  Process A   |    |   Process B  |\n              |              |    |              |\n              |              |    |              |\n               \\            /      \\            /\n                \\          /        \\   port M /\n                 \\________/          \\____^___/\n                                          |\n                                      RECEIVE ANY\n\n   Process A, fortunately, knows of the existence of port M at site L\n   and sends messages using the SEND FROM ANY operation from port N to\n   port M.  The message contains two port numbers and instructions for\n   process B to SEND messages to process A to port P from port Q.  Site\n   K's site number is appended to this message along with the message's\n   SEND port N.\n\n                   SITE K                        SITE L\n                 ________                      ________\n                /        \\                    /        \\\n               /          \\                  /          \\\n              /            \\                /            \\\n             |  Process A   |              |   Process B  |\n             |              |              |              |\n             |              |              |              |\n              \\            /                \\            /\n               \\  port N  /---\u003eSEND FROM ---\u003e\\  port M  /\n                \\________/       ANY          \\________/\n\n                           to port M, site L\n                           containing K, N, P, \u0026 Q\n\n\n   Process A now executes a RECEIVE at port P from port Q.  Process A\n   specifies the rendezvous site to be site L.\n\n\n\n\n\n\n\n\n\n\n\n\nWalden                                                         [Page 10]\n\f\nRFC 61      Interprocess Communication in a Computer Network   July 1970\n\n\n                    SITE K                         SITE L\n                  ________                 R    ________\n                 /        \\                e   /        \\\n                /          \\               n T/          \\\n               /            \\              d a            \\\n              |              |             e b  Process B |\n              |  Process A   |             z l            |\n              |              |             v e            |\n               \\            /              o \\            /\n                \\  port P  /  RECEIVE ---\u003e u  \\          /\n                 \\________/   MESSAGE      s   \\________/\n\n                                to site L\n                                containing P, Q, \u0026 K\n\n\n   A RECEIVE message is sent from site K to site L and is entered in the\n   rendezvous table at site L.  At some other time, process B executes a\n   SEND to port P from port Q specifying site L as the rendezvous site.\n\n\n                    SITE K                         SITE L\n                  ________                 R    ________\n                 /        \\                e   /        \\\n                /          \\               n T/          \\\n               /            \\              d a            \\\n              |              |             e b  Process B |\n              |  Process A   |             z l            |\n              |              |             v e            |\n               \\            /              o \\            /\n                \\  port P  /               u \u003c--- port Q /\n                 \\________/    SEND        s   \\________/\n                                to site L\n                                containing P \u0026 Q\n\n\n   A rendezvous is made, the rendezvous table entry is cleared, and the\n   transmission to port P at site K takes place.  The SEND site number\n   (and conceivably the SEND port number) are appended to the messages\n   of the transmission for the edification of the receiving process.\n\n\n\n\n\n\n\n\n\n\n\nWalden                                                         [Page 11]\n\f\nRFC 61      Interprocess Communication in a Computer Network   July 1970\n\n\n                SITE K                                SITE L\n              ________                              ________\n             /        \\                            /        \\\n            /          \\                          /          \\\n           /            \\                        /            \\\n          |   Process A  |                      |  Process B   |\n          |              |                      |              |\n          |              |                      |              |\n           \\  port P    /                        \\  port Q    /\n            \\          / \u003c---- transmission \u003c---- \\          /\n             \\________/    to port T, site K       \\________/\n                            containing data and L\n\n   Process B may simultaneously wish to execute a RECEIVE from port N at\n   port M.\n\n   Note that there is only one important control message in this system\n   which moves between sites, the type of message that is called a\n   Host/Host protocol message in [3].  This control message is the\n   RECEIVE message.  There are two other possible intersite control\n   messages: an error message to the originating site when a RECEIVE or\n   SEND is timed out, and the SEND message in the rare case when the\n   rendezvous site is not the SEND site.\n\n   Of course there must also be a standard format for messages between\n   ports.  For example, the following:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWalden                                                         [Page 12]\n\f\nRFC 61      Interprocess Communication in a Computer Network   July 1970\n\n\n    +-----------------+  +-----------------+  +-----------------+\n    | rendezvous site |  | destination site|  |  source site    |\n    +-----------------+  +-----------------+  +-----------------+\n    | RECEIVE port    |  | RECEIVE port    |  |  RECEIVE port   |\n    +-----------------+  +-----------------+  +-----------------+\n    | SEND port       |  | SEND port       |  |   SEND port     |\n    +-----------------+  +-----------------+  +-----------------+\n    |                 |  | source port     |  |                 |\n    |                 |  +-----------------+  |                 |\n    |                 |  |                 |  |                 |\n    |                 |  |                 |  |                 |\n    |                 |  |                 |  |                 |\n    |                 |  |                 |  |                 |\n    |                 |  |                 |  |                 |\n    |     data        |  |      data       |  |     data        |\n    |                 |  |                 |  |                 |\n    |                 |  |                 |  |                 |\n    |                 |  |                 |  |                 |\n    |                 |  |                 |  |                 |\n    |                 |  |                 |  |                 |\n    |                 |  |                 |  |                 |\n    +-----------------+  +-----------------+  +-----------------+\n       transmitted           transmitted          received\n       by SEND               by Network           by RECEIVE\n       process               Controller           process\n\n   Note: for a SEND FROM ANY message, the rendezvous site is the\n   destination site.\n\n   In the model time-sharing system it was possible to pass a port from\n   process to process.  This is still possible with a distributed\n   Network Controller.  [The reader unconvinced of the utility of port\n   passing is directed to read the section on reconnection in [11].]\n\n   Remember that for a message to be sent from one process to another, a\n   SEND to port M from port N and a RECEIVE at port M from port N must\n   rendezvous, normally at the SEND site.  Both processes keep track of\n   where they think the rendezvous site is and supply this site as a\n   parameter of appropriate operations.  The RECEIVE process thinks it\n   is the SEND site and the SEND process normally thinks it is the SEND\n   site also.  Since once a SEND and a RECEIVE rendezvous, the\n   transmission is sent to the source of the RECEIVE and the entry in\n   the rendezvous table is cleared and must be set up again for each\n   further transmission from N to M, it is easy for a RECEIVE port to be\n   moved.  If a process sends both the port numbers and the rendezvous\n   site number to a new process at some other site which executes a\n   RECEIVE using these same old port numbers and rendezvous site\n   specification, the SENDer never knows the RECEIVEr has moved.  It is\n\n\n\nWalden                                                         [Page 13]\n\f\nRFC 61      Interprocess Communication in a Computer Network   July 1970\n\n\n   slightly harder for a SEND port to move.  However, if it does, the\n   pair of port numbers that has been being used for a SEND and the\n   original rendezvous site number are passed to the new site.  The\n   process at the new SEND site specifies the old rendezvous site with\n   the first SEND from the new site.  The RECEIVE process will also\n   still think the rendezvous site is the old site, so the SEND and\n   RECEIVE will meet at the old site.  When they meet, the entry in the\n   table at that site is cleared, the rendezvous site number for the\n   SEND message is changed to the site which originated the SEND message\n   and both the SEND and RECEIVE messages are sent to the new SEND site\n   just as if they had been destined for there in the first place.  The\n   SEND and RECEIVE then meet again at the new rendezvous site and\n   transmission may continue as if the port had never moved.  Since all\n   transmissions contain the source site number, further RECEIVEs will\n   be sent to the new rendezvous site.  It is possible to discover that\n   this special manipulation must take place because a SEND message is\n   received at a site which did not originate the SEND message.\n   Everything is so easily changed because there are no permanent\n   connections to break and move as in the once proposed reconnection\n   scheme for the ARPA network [10][11] that is, connections only exist\n   fleetingly in the system described here and can therefore be remade\n   between any pair of processes which at any time happen to know each\n   other's port numbers and have some clue where they each are.\n\n   Of course, all of this could have been done by the processes sending\n   messages back and forth announcing any potential moves and the new\n   site numbers.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWalden                                                         [Page 14]\n\f\nRFC 61      Interprocess Communication in a Computer Network   July 1970\n\n\nREFERENCES\n\n   [1]  L. Roberts and B. Wessler, Computer Network Development to\n        achieve Resource Sharing, Proceedings 1970 SJCC.\n\n   [2]  V. Vyssotsky, F. F.  Corbato, and R. Graham, Structure of the\n        MULTICS Supervisor, Proceedings 1965 FJCC.\n\n   [3]  C. Carr, S. Crocker, and V. Cerf, Host/Host Communication\n        Protocol in the ARPA Network, Proceedings 1970 SJCC.\n\n   [4]  F. Heart, et al, The Interface Message Processor for the ARPA\n        Computer Network, Proceedings 1970 SJCC.\n\n   [5]  W. Ackerman and W. Plummer, An Implementation of Multi-\n        processing Computer System, Proceedings Gatlinburg Symposium on\n        Operating System Principles.\n\n   [6]  J. Dennis and E. Van Horn, Programming Semantics for\n        Multiprogramming Computation, Proceedings of the San Dimes\n        Conference on Programming Language and Pragmatics.\n\n   [7]  B. Lampson, Dynamic Protection Structures, Proceedings FJCC\n        1969.\n\n   [8]  B. Lampson, An Overview of the CAL Time-Sharing System, Computer\n        Center, University of Calif., Berkeley.\n\n   [9]  P. Hansen, The Nucleus of a Multiprogramming System, CACM, April\n        1970.\n\n   [10] S. Crocker, ARPA Network Working Group Note #36.\n\n   [11] J. Postel and S. Crocker, ARPA Network Working Group Note #48.\n\n   [12] B. Lampson, 940 Lectures.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWalden                                                         [Page 15]\n\f\nRFC 61      Interprocess Communication in a Computer Network   July 1970\n\n\nAPPENDIX: AN APPLICATION\n\n   Only one resource sharing computer network currently exists, the\n   aforementioned ARPA network.  In this Appendix, I hope to show that\n   the system that was described in this note can be applied to the ARPA\n   network.  A significant body of work exists on interprocess\n   communication within the ARPA network.  This work comes in several\n   almost distinct pieces: the Host/IMP protocol, IMP/IMP protocol, and\n   the Host/Host protocol.  I assume familiarity with this work in the\n   subsequent discussion.  [See references [1][3][4][10][11];\n   Specifications for the Inter-connection of a Host to an IMP, BBN\n   Report No. 1822; and ARPA Network Working Group Notes #37, 38, 39,\n   42, 44, 46, 47, 48, 49, 50, 54, 55, 56, 57, 56, 59.]\n\n\n   In the ARPA network, the IMP's have sole responsibility for correctly\n   transmitting bits from one site to another.  The Hosts have sole\n   responsibility for making interprocess connections.  Both the Host\n   and IMP are concerned and take a little responsibility for flow\n   control and message sequencing.  Application of the interprocess\n   communication system I have described leads me to different\n   allocation of responsibility.  The IMP still continues to correctly\n   move bits from one site to another, but the Network Controller also\n   resides in the IMP, and flow control is completely in the hands of\n   the processes running in the Hosts although perhaps they use\n   mechanisms provided by the IMPs.\n\n   The IMPs provide the SEND, RECEIVE, SEND FROM ANY, RECEIVE ANY, and\n   UNIQUE operations in slightly altered forms for the Hosts and also\n   maintain the rendezvous tables including moving of SEND ports when\n   necessary.\n\n   It is perhaps easiest to step through the five operations again.\n\n   SEND.  The Host gives the IMP a SEND port number, a RECEIVE port\n   number, the rendezvous site, and a buffer specification=20 (e.g.,\n   start and end, beginning and length).  The SEND is sent to the\n   rendezvous site, normally the local site.  When the matching RECEIVE\n   arrives, the Host is notified of the RECEIVE port of the just arrived\n   receive message.  This port number is sufficient to identify the\n   SENDing process although a given time-sharing system may have to keep\n   internal tables mapping this port number into useful internal process\n   identifiers.  Simultaneously, the IMP will begin to ask the Host for\n   specific chunks of the data buffer.  These chunks will be sent off to\n   the destination as the IMP's RFNM control allows.  If a RFNM is not\n   received for too long, implying a message has been lost in the\n   network, the Host is asked for the same chunk of data again [which\n   also allows messages to be completely thrown away by the IMP network\n\n\n\nWalden                                                         [Page 16]\n\f\nRFC 61      Interprocess Communication in a Computer Network   July 1970\n\n\n   if that should ever be useful], but the Host has the option to abort\n   the transmission at this time.  While a transmission is taking place,\n   the Host may ask the IMP to perform other operations including other\n   SENDs.  A second SEND over a pair of ports already in the act of\n   transmission is noted and the SEND becomes active as soon as the\n   first transmission is complete.  A third identical SEND results in an\n   error message to the Host.  If a SEND times out, an error is returned\n   also.\n\n   RECEIVE.  The Host gives the IMP a SEND port, a RECEIVE port, a\n   rendezvous site, and a buffer description.  The RECEIVE message is\n   sent to the rendezvous site.  When chunks of a transmission arrive\n   for the RECEIVE port they are passed to the Host along with RECEIVE\n   port number (and perhaps the SEND port number), and an indication to\n   the Host where to put the data in its input buffer.  When the last of\n   the SEND buffer is passed into the Host, it is marked accordingly and\n   the Host can then detect this.  A second RECEIVE over the same port\n   pair is allowed.  A third results in an error message to the Host.\n   The mechanism described in this and the previous paragraphs allows a\n   pair of processes to always have both a transmission in progress and\n   the next one pending.  Therefore, no efficiency is lost.  On the\n   other hand, each transmission must be preceded by a RECEIVE into a\n   specified buffer, thus providing complete flow control.  (It is\n   conceivable that the RECEIVE message could allocate a piece of\n   network bandwidth while making its network traverse to the rendezvous\n   site.)\n\n   RECEIVE ANY.  The Host gives the IMP a RECEIVE port and a buffer\n   descriptor.  This works the same as RECEIVE but assumes the local\n   site to be the rendezvous site.\n\n   SEND FROM ANY.  The Host gives the IMP RECEIVE and SEND ports, the\n   destination site, and a buffer descriptor.  The IMP requests and\n   transmits the buffer as fast as possible.  A SEND FROM ANY for a\n   non-existent port is discarded at the destination site.\n\n   RFNM's are tied to the transmission of a particular chunk of buffer\n   just as acknowledgments are now tied to packets and they perform the\n   same function.  If the Hosts allow the IMPs to reassemble buffers in\n   the Hosts by the IMP telling the Host where it should put a buffer\n   chunk as described above, chunks of a single buffer can be\n   transmitted in parallel and several RFNMs can be outstanding\n   simultaneously.  Packet reassembly is still done in the IMPs.\n\n   A final operation must be provided by the IMP -- the UNIQUE\n   operation.  There are many ways to maintain unique numbers and three\n   are presented here.  The first possibility is for the Hosts to ask\n   the IMPs for the unique numbers originally and then guarantee the\n\n\n\nWalden                                                         [Page 17]\n\f\nRFC 61      Interprocess Communication in a Computer Network   July 1970\n\n\n   integrity of any unique numbers currently owned by local processes\n   and programs using whatever means the Host has at its disposal.  In\n   this case the IMPs would provide a method for a unique number to be\n   sent from one host to another and would vouch for the number's\n   identity at the new site.\n\n   The second method is to simply give the unique numbers to the\n   processes that are using them, depending on the non-malicious\n   behavior of the processes to preserve the unique numbers, or if an\n   accident should happen, the two passwords (SEND and RECEIVE ports)\n   that are required to initiate a transmission.  If the unique numbers\n   are given out in a non-sequential manner and are reasonably long (say\n   32 bits) there is little danger.\n\n   In the final method, a user identification is included in the port\n   numbers and the individual time-sharing systems guarantee the\n   integrity of these identification bits.  Thus a process, while not\n   able to be sure that the correct port is transmitting to him, can be\n   sure that some port of the correct user is transmitting.  This is the\n   so-called virtual net concept suggested by W. Crowther [3].\n\n   Random Contents.  Putting these operations in the IMP requires the\n   Host/Host protocol program to be written only once, rather than many\n   times as is currently being done in the ARPA Network.  The IMPs can\n   stop a specific host transmission (by not asking for the next chunk\n   for a while) if that should seem necessary to alleviate congestion\n   problems in the communications subnet.  And the IMP might know the\n   approximate time it takes for a RECEIVE to get to a particular other\n   site and warn the Host to wake up a process shortly before it becomes\n   imminent that a message for that process will be arriving.\n\n\n\n\n\n\n\n\n\n\n\n         [ This RFC was put into machine readable form for entry ]\n         [ into the online RFC archives by Katsunori Tanaka 4/99 ]\n\n\n\n\n\n\n\n\nWalden                                                         [Page 18]\n\f\n"
}