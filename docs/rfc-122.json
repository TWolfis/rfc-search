{
  "series": "Request for Comments",
  "number": "122",
  "howpublished": "RFC 122",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0122",
  "url": "https://www.rfc-editor.org/info/rfc122",
  "title": "Network specifications for UCSB's Simple-Minded File System",
  "pagetotal": "21",
  "year": "1971",
  "month": "apr",
  "day": "1",
  "body": "\n\n\n\n\n\nNetwork Working Group                                     James E. White\nRequest for Comments: 122                               UC Santa Barbara\nNIC 5834                                                   26 April 1971\n\n\n                   NETWORK SPECIFICATIONS FOR UCSB's\n\n                       SIMPLE-MINDED FILE SYSTEM\n\n\n                                CONTENTS\n                                                               Page\n\n          I.   Preface........................................   3\n\n         II.   Implementation.................................   3\n\n        III.   Login..........................................   3\n\n         IV.   Service Offered................................   4\n\n          V.   Primitive File Operations......................   6\n\n               V.A.  Allocate File (ALF)......................   6\n\n               V.B.  Update File (UDF)........................   7\n\n               V.C.  Replace File (RDF).......................   8\n\n               V.D.  Retrieve File (RTF)......................   9\n\n               V.E.  Space File (SPF).........................   9\n\n               V.F.  Delete File (DLF)........................  10\n\n               V.G.  Rename File (RNF)........................  10\n\n               V.H.  File No Operation (FNO)..................  10\n\n               V.I.  No Operation (NOP).......................  11\n\n         VI.   Input Stream Format............................  11\n\n        VII.   Output Stream Format...........................  16\n\n\n\n\n\n\n\nJ. White                                                        [Page 1]\n\f\nRFC 122                Simple-Minded file System              April 1971\n\n\n        FIGURES\n                                                               Page\n\n        Figure 1.  Filename/Password Character Sets...........   5\n\n        Figure 2.  Command Op Codes...........................  12\n\n        Figure 3.  Defined Command Fields.....................  13\n\n        Figure 4.  Definition of Command FLAGS Bits...........  14\n\n        Figure 5.  Defined Command Response Fields............  18\n\n        Figure 6.  Completion Codes...........................  19\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nJ. White                                                        [Page 2]\n\f\nRFC 122                Simple-Minded file System              April 1971\n\n\nI.   Preface\n\n   UCSB will provide file storage for Network users.  UCSB's Simple\n   Minded File System (SMFS) is addressed as socket number X'401', site\n   3.  No accounting parameters are required.  This document is intended\n   to provide programmers with the information necessary to communicate\n   with SMFS which conducts all Network transactions trough its NCP\n   which operates under the Host-Host protocol of August 3, 1970.*\n\nII.  Implementation\n\n   The following information is not essential to use of SMFS but may be\n   of interest.  SMFS will store user's files on IBM 2316 disk packs,\n   each with 29M 8-bit bytes of storage capacity.  UCSB has two 2314\n   units, each with eight drives on-line.  Initially, one drive will be\n   allocated for Network storage, and the appropriate pack will always\n   be mounted an that drive, and hence accessible to SMFS without\n   operator intervention.  UCSB estimates that for the next year it will\n   have up to four drives that it can devote to Network use.  The\n   second, third, and fourth drives will be allocated only as the need\n   arises.  SMFS is written to accommodate any number of on-line drives\n   without modification.\n\n   If necessary, UCSB will investigate the possibility of making one of\n   the four drives a come-and-go drive on which one of a number of packs\n   can be mounted as required.  Hence, the potential exists for\n   increased storage capacity with an accompanying increase in access\n   time.\n\n   Files stored with SMFS will be backed up to tape daily.  The back-up\n   tape(s) will be off-line and available only in case the on-line\n   copies are destroyed.\n\n   In no sense does USB expect to become _the_ file storage node of the\n   Network; it hasn't the capacity.  UCSB _is_ equipped, however, to\n   make a limited amount of secondary storage immediately available to\n   the Network community.\n\nIII.  Login\n\n   SMFS can simultaneously service any number of Network users up to\n   some assembly-parameters maximum (currently ten).  A potential user\n   must establish a pair of Network connections\n\n*At the time of this writing, the NCP modifications of RFC #107 have not\nas yet been implemented at UCSB.\n\n\n\n\n\nJ. White                                                        [Page 3]\n\f\nRFC 122                Simple-Minded file System              April 1971\n\n\n   (i.e., one full-duplex connection) to SMFS by executing a standard\n   ICP to socket X'401', site 3.  SMFS always listens on that socket.\n   It will accept any call it receives -- say from the user's receive\n   socket 'm' -- and over the connection thus established transmit a\n   32-bit receive socket number (call it 'n'), and then close the\n   connection.  SMFS will then issue two connection requests -- one\n   involving its receive socket 'n' and the user's send socket 'm+l', in\n   other involving its send socket 'n+l' and the user's receive socket\n   'm'.  Once these two connections have been established, the user will\n   be considered logged in.  A deviation from the Initial Connection\n   Protocol will occur only if SMFS or its NCP has insufficient\n   resources to support another connection.\n\n   SMFS will maintain its connections to the user indefinitely.  It will\n   voluntarily terminate its connections to the user only if (1) a bad\n   op code is encountered in a user command (see Section VI), or (2)\n   closing one of the connections is required to signal end-of-data (see\n   Section V.D.).  Barring such an occurrence, the user should close his\n   connections to SMFS when through, at which time SMFS will consider\n   the user logged out.\n\n   In the discussion to follow, the following terms are used.  The\n   connections on which the user transmits data to and receives data\n   from SMFS are designated the input and output connections,\n   respectively (i.e., SMFS's rather than the user's point of view is\n   adopted).  The string of bits which passes from the user to SMFS over\n   the input connection during the life of that connection is called the\n   _input stream_; the string of bits which passes from SMFS to the user\n   over the output connection during the life of that connection is\n   called the _output stream_.\n\nIV.  Service Offered\n\n   SMFS will provide storage for sequential, binary files of length\n   greater than or equal to an assembly-parameter minimum (currently one\n   bit) and less than or equal to an assembly-parameter maximum\n   (currently 25 million bits).  There is no restriction on the contents\n   of the file.\n\n   Every file stored with SMFS has a _filename_, which may be any string\n   of from one to 36, 8-bit characters chosen from the set:\n\n        { A,...,Z,0,...9,blank }\n\n\n\n\n\n\n\n\nJ. White                                                        [Page 4]\n\f\nRFC 122                Simple-Minded file System              April 1971\n\n\n   Graphic              EBCDIC Code (Hex)    ASCII Code (Hex)\n\n   UC     LC                UC     LC            UC     LC\n\n   A     a                  C1     81            41     61\n   B     b                  C2     82            42     62\n   C     c                  C3     83            43     63\n   D     d                  C4     84            44     64\n   E     e                  C5     85            45     65\n   F     f                  C6     86            46     66\n   G     g                  C7     87            47     67\n   H     h                  C8     88            48     68\n   I     i                  C9     89            49     69\n   J     j                  D1     91            4A     6A\n   K     k                  D2     92            4B     6B\n   L     l                  D3     93            4C     6C\n   M     m                  D4     94            4D     6D\n   N     n                  D5     95            4E     6E\n   O     o                  D6     96            4F     6F\n   P     p                  D7     97            50     70\n   Q     q                  D8     98            51     71\n   R     r                  D9     99            52     72\n   S     s                  E2     A2            53     73\n   T     t                  E3     A3            54     74\n   U     u                  E4     A4            55     75\n   V     v                  E5     A5            56     76\n   W     w                  E6     A6            57     77\n   X     x                  E7     A7            58     78\n   Y     y                  E8     A8            59     79\n   Z     z                  E9     A9            5A     7A\n\n\n   0     -                  F0      -             30     -\n   1     -                  F1      -             31     -\n   2     -                  F2      -             32     -\n   3     -                  F3      -             33     -\n   4     -                  F4      -             34     -\n   5     -                  F5      -             35     -\n   6     -                  F6      -             36     -\n   7     -                  F7      -             37     -\n   8     -                  F8      -             38     -\n   9     -                  F9      -             39     -\n\n   blank -                  40      -             20     -\n\n                                 Figure 1\n\n                     Filename/Password Character Sets\n\n\n\nJ. White                                                        [Page 5]\n\f\nRFC 122                Simple-Minded file System              April 1971\n\n\n   Filenames may be specified by the user in either EBCDIC or ASCII (see\n   Figure 1), and the characters A,...,Z may be either upper- or lower-\n   case.  However, the acceptance by SMFS of both upper- and lower-case,\n   and both EBCDIC and ASCII, is provided only as a convenience to the\n   user.  In particular, such distinctions don't increase the number of\n   unique filenames that can be generated; the filenames 'FILE NUMBER 1'\n   and 'file number 1', in EBCDIC or ASCII, designate the same file.\n\n   Every file stored with SMFS may optionally be protected against\n   unauthorized retrieval and/or modification.  When a file is created,\n   the user may associate with it a _modification password_ and/or an\n   _access password_.  Thereafter, SMFS will demand that the appropriate\n   password be supplied before the file is modified or retrieved,\n   respectively.  Since SMFS protects each file independently against\n   unauthorized modification and retrieval, a group of users can be\n   given access to a file while a single individual retains the\n   exclusive right to modify it.  If no password is defined for a\n   particular type of reference to a file, then such references are\n   unrestricted.  Passwords have the same attributes as filenames --\n   same length restrictions and same character sets.\n\n   Because of the manner in which SMFS writes files onto secondary\n   storage, it must insure that while one user is modifying a file, no\n   other user is simultaneously either modifying or retrieving the same\n   file.  This requirement is effected by a mechanism internal to SMFS\n   and hence transparent to users, with the exception that when a user\n   attempts to retrieve or modify a file currently being modified by\n   another user, SMFS will delay action upon the request until the\n   current modification is complete.  There is no restriction on the\n   number of users which may concurrently retrieve the same file.\n\nV.   Primitive File Operations\n\n   SMFS recognizes and will execute the following primitive file\n   operations:\n\nV.A.  Allocate File (ALF)\n\n   SMFS regards the reservation of filename, the assignment of\n   passwords, and the reservation of secondary storage as an operation\n   distinct from that of transmitting the file's contents.  The\n   operation is called _file allocation_, abbreviated ALF.  In\n   allocating a file, the user specifies the filename to be assigned to\n   it, the access password (if any), and the estimated size of the file\n   in bits.  SMFS checks the proposed filename to insure that it doesn't\n   duplicate that of an existing file.  SMFS also checks to insure that\n   it has sufficient secondary storage available to accommodate the new\n\n\n\n\nJ. White                                                        [Page 6]\n\f\nRFC 122                Simple-Minded file System              April 1971\n\n\n   file.  If both requirements are met, SMFS allocates the file; the\n   filename is reserved, secondary storage is reserved, and the password\n   information is recorded.\n\n   In reserving secondary storage for a file, SMFS adds its estimate of\n   its overhead in storing the file to the user-declared size of the\n   file.  In general, the user should slightly over-estimate the size of\n   his file at allocation.  SMFS allocates a fixed amount of storage on\n   the basis of that estimate, an amount which cannot be increased\n   later.  SMFS's actual overhead in storing a file is a function of the\n   manner in which the contents of the file are transmitted by the user.\n   The overhead is minimal when the file is transmitted in a single\n   series of operations (see Section VI) and increases as the number of\n   operations increases.  It is the overhead associated with single-\n   series transmission that SMFS adds to the file size specified by the\n   user to determine the amount of storage to allocate.  Hence, for\n   multiple-series transmission, the overhead will have been\n   underestimated.\n\nV.B.  Update File (UDF)\n\n   The operation of transmitting part or all of a previously allocated\n   file's contents for storage by SMFS is called _updating_ the _file_\n   (UDF).  The user specifies the filename of the file to be updated,\n   the modification password if required, the amount of data in bits to\n   be added to the file, and finally the data itself.  SMFS locates the\n   file on secondary storage, checks the password for validity, if\n   appropriate, and adds the data to the file.  SMFS considers the\n   update complete when either the specified number of bits have been\n   extracted from the input stream and stored, or when the user\n   terminates transmission by closing the connection.\n\n   The data transmitted in a UDF operation is _concatenated_ to the\n   current contents of the file.  Boundaries between updates are\n   transparent to the user when the file is retrieved.  Hence, for\n   example, the contents of a file might be transmitted to SMFS in two\n   distinct UDF operations, and later retrieved in a single RTF\n   operation (see Section V.D.).  The user should view a file stored\n   with SMFS as a potentially very long bit string which may be\n   transmitted to SMFS in any number of variable-length _segments_, and\n   is retrievable in any number of variable-length segments, with the\n   manner of segmentation chosen during retrieval independent of that\n   selected during the updating process.\n\n   The user may optionally request that SMFS 'remember' the manner in\n   which a file was updated, i.e., along with the data, store sufficient\n   information to reconstruct segment boundaries at retrieval time.\n   Such a file is said to be _formatted_.  In retrieving a formatted\n\n\n\nJ. White                                                        [Page 7]\n\f\nRFC 122                Simple-Minded file System              April 1971\n\n\n   file, the user, rather than requesting that SMFS transmit the next\n   'n' bits of the file as he would do for an unformatted file (see\n   Section V.D.), requests that SMFS transmit the next segment of the\n   file; it is then SMFS's responsibility to supply the length of the\n   segment.  Hence, the notion of a _logical record_ is introduced.\n\n   Of course, since the user may format the contents of a file in any\n   way he chooses, he can embed record-length information in the data\n   itself.  Hence, the user can implement a record structure in a way\n   that's transparent to SMFS.  This scheme, however, requires during\n   retrieval that, for each logical record retrieved, the user fetch\n   first the length field and then, using the length as an operand,\n   fetch the data itself.  In this kind of arrangement, the retrieval\n   rate is apt to suffer.  However, by allowing SMFS knowledge of\n   logical-record boundaries, the feedback loop is effectively shortened\n   (SMFS being closer to the file); hence, the potential exists for an\n   increased retrieval rate.\n\n   If the user intends that a file be formatted, he must so specify in\n   every update and every retrieve operation referencing that file.\n   SMFS in no way flags a file to indicate that it is formatted.  Hence,\n   if the user invokes the option during retrieval without having done\n   so when the file was stored, results will be erroneous.  Furthermore,\n   if an update of a formatted file is terminated before the bit count\n   for the operation is exhausted (i.e., because the user closed the\n   connection), retrieval results will again be erroneous.\n\nV.C.  Replace File (RPF)\n\n   The replace-file (RPF) operation is identical to UDF, except that the\n   new file segment, rather than being concatenated to the existing\n   file, _replaces_ the entire contents of the file.  The previous\n   contents of the file are lost, and the new segment becomes the only\n   segment in the file.\n\n   RPF may be used to rewrite an existing file.  If the rewritten file\n   is to contain just a single segment, that segment may be transmitted\n   to SMFS in an RPF operation.  Otherwise, the first segment of the new\n   file must be transmitted in an RPF operation, and all succeeding\n   segments in UDF operations.  Alternately, a dummy (bit count of zero)\n   RPF operation may be inserted before the first real segment is\n   transmitted; all segments of the file may then be transmitted in UDF\n   operations.\n\n\n\n\n\n\n\n\nJ. White                                                        [Page 8]\n\f\nRFC 122                Simple-Minded file System              April 1971\n\n\nV.D.  Retrieve File (RTF)\n\n   The operation which retrieves all or part of a file's contents is\n   called file retrieval (RTF).  The user specifies the filename of the\n   file to be retrieved, the access password if required, and the amount\n   of data in bits to be fetched from the file.  SMFS locates the file\n   on secondary storage, checks the password for validity (if\n   appropriate), and copies the bit count and the requested file segment\n   into the output stream.  SMFS considers the retrieval complete when\n   either the requested number of bits have been placed in the output\n   stream, or when the contents of the file are exhausted.  In this\n   latter case, SMFS closes the connection to signal end-of-data to the\n   user.\n\n   Successive RTF operations referencing the same file cause successive\n   segments of the file to be transmitted, provided that the operations\n   are juxtaposed in the input stream (however, NOP's may be\n   interspersed anywhere in the input stream).  When a series of RTF\n   operations referencing a particular file is broken by an operation\n   referencing another file, or by a different type of operation\n   involving the same file, the next RTF operation designating the\n   original file will cause the _first_ segment of that file to be\n   transmitted.  The manner in which the user segments a file for a\n   series of retrieve operations need bear no relationship to the\n   segmentation scheme employed when the file was updated, nor to that\n   employed in previous retrievals.\n\n   If the user elected to have his file formatted by SMFS, he should\n   re-invoke the option in the RTF operation, in which case SMFS will\n   supply the length of the segment, and place both it and the segment\n   itself into the output stream.\n\nV.E.  Space File (SPF)\n\n   Files stored with SMFS are sequential in organization.  That is the\n   n+1th segment of the file cannot be retrieved without first\n   processing the nth segment.  The user may, however, upon occasion,\n   wish to retrieve only selected segments of a file.  This he could do,\n   effectively, by retrieving each segment of the file and flushing\n   those with which he was currently unconcerned.  To avoid needless\n   Network traffic, SMFS provides a mechanism for flushing file segments\n   locally.  The operation is called _spacing_ a file (SPF).  It is\n   identical to RTF with the exception that transmission of data (but\n   not bit count) is suppressed.  SPF operations may be freely inserted\n   anywhere within a series of RTF operations designating a particular\n   file, with the desired results.\n\n\n\n\n\nJ. White                                                        [Page 9]\n\f\nRFC 122                Simple-Minded file System              April 1971\n\n\nV.F.  Delete File (DLF)\n\n   A file may be deleted at any time after allocation.  The user\n   specifies the filename of the file to be deleted and the modification\n   password if required.  SMFS locates the file on secondary storage,\n   checks the password for validity (if appropriate), and, if the\n   password is correct, deletes the file.  The filename is made\n   available for reassignment, and the secondary storage allocated to\n   the file is reclaimed by SMFS.  The contents (if any) of the file are\n   lost.\n\nV.G.  Rename File (RNF)\n\n   A file stored with SMFS may be renamed at any time after allocation.\n   The user specifies the current filename of the file to be renamed,\n   the modification password if any, and the proposed new filename.\n   SMFS locates the file on secondary storage, checks the password for\n   validity (if appropriate), and assures that the proposed new filename\n   is not already assigned to another file.  If these requirements are\n   met, the file is renamed, and all subsequent references to the file\n   must be by the newly-assigned filename.\n\n   RNF provides a means for protecting a file that must be rewritten in\n   its entirety against failures in the Net, or in the sending or\n   receiving host.  The strategy is as follows.  Allocate a new file,\n   assigning it some temporary name.  Transmit the revised file contents\n   in one more UDF and/or RPF operations.  Then delete the original file\n   and, using RNF, replace the newly-created file's temporary filename\n   with that of the original file.\n\nV.H.  File no Operation (FNO)\n\n   FNO is a dummy operation which is provided for use in terminating a\n   series of RTF operations.  Should the user desire to retrieve the\n   contents of a file twice in succession, he may do so with a series of\n   RTF/SPF operations, followed by a FNO followed by a second series of\n   RTF/SPF operations.  Each RTF/SPF operation in the first series will\n   retrieve/flush the next segment of the file.  The first operation of\n   the second string, since it _is_ the first of a string, will, as\n   explained in Section V.D., retrieve/flush the _first_ segment of the\n   file.  The remaining operations in the second string will, of course\n   retrieve/flush the 2nd, 3rd, etc., segments of the file.  Hence, the\n   contents of the file are transmitted twice.  FNO, when it terminates\n   such a string of operations, effectively repositions the user to the\n   first segment of the file.\n\n   FNO may appear anywhere within the input stream.\n\n\n\n\nJ. White                                                       [Page 10]\n\f\nRFC 122                Simple-Minded file System              April 1971\n\n\nV.I.  No Operation (NOP)\n\n   This operation is provided _solely_ to aid the user in formatting the\n   input stream, and is discarded without further processing whenever it\n   is encountered.  In particular, a NOP embedded in a series of RTF\n   operations does not terminate the string as FNO does.\n\n\nVI.  Input Stream Format\n\n   The input stream shall consist of a contiguous string of commands to\n   SMFS.  A command type is defined for each of the primitive file\n   operations of Section V. Each command has the following general\n   format:\n\n  8     16                                              32\n ______________//______//_________//__________//_________________//__\n|    |     |        |        |            |         |         |      |\n| OP |     |        | ACCESS |MODIFICATION|   NEW   |         |      |\n|CODE|FLAGS|FILENAME|PASSWORD|  PASSWORD  | FILENAME|BIT COUNT| DATA |\n|____|_____|___//___|__//____|____//______|___//____|_________|__//__|\n\n\n   where the lengths of fixed-length fields have been indicated in bits.\n   Each of the fields 'FILENAME','ACCESS PASSWORD', 'MODIFICATION\n   PASSWORD', and 'NEW FILENAME' is further divided into the following\n   subfields:\n\n      8         8*LENGTH\n   ________________________//___\n  |        |                    |\n  | LENGTH | FILENAME/PASSWORD  |\n  |________|_______________//___|\n\n\n   where the 'LENGTH' subfield contains the length in 8-bit characters\n   of the 'FILENAME/PASSWORD' subfield.\n\n   This is the _general_ format for all SMFS commands.  No one command\n   type requires all of the fields specified above.  A particular subset\n   of these fields is defined for each type of command, and only those\n   fields should appear.  The defined fields for each command type are\n   indicated in Figure 3.\n\n   Furthermore, not all of the fields which are defined for a particular\n   command type need always appear _explicitly_.  The user should\n   envision that SMFS maintains filename, password, and bit-count\n   accumulators.  Every time a filename (or new filename),\n\n\n\nJ. White                                                       [Page 11]\n\f\nRFC 122                Simple-Minded file System              April 1971\n\n\n   access/modification password, or bit count appears explicitly in the\n   input stream, it is saved in the appropriate accumulator (a null\n   password -- designated by setting Bits 0,3 or Bits 8,11 to zero\n   (Figure 4) -- should be thought of as appearing explicitly).  The\n   user may cause a defined field to _default_ to the current contents\n   of the appropriate accumulator by turning on the appropriate bin in\n   the flags field (see Figure 4).  When a field defaults in this\n   manner, that field is said to appear _implicitly_ in the command.\n\n         NOP                        0                 No operation.\n\n         FNO                        1                 File no operation.\n\n         ALF                        2                 Allocate file.\n\n         UDF                        3                 Update File.\n\n         RPF                        4                 Replace File.\n\n         RTF                        5                 Retrieve File.\n\n         SPF                        6                 Space File.\n\n         DLF                        7                 Delete File.\n\n         RNF                        8                 Rename File.\n\n                                Figure 2\n                             Command Op codes\n\n   The three accumulators are initially empty and hence an attempt to\n   default a field in the first command in the input stream illicits an\n   error indication.  A field of the appropriate type must appear once\n   explicitly in the input stream before the corresponding accumulator\n   is considered defined.  Furthermore, whenever SMFS detects an invalid\n   filename or password (i.e., improper length or deviation from the\n   character set) in the input stream, the appropriate accumulator is\n   left empty again.\n\n   SMFS allows operations on several files to be interleaved in the\n   input stream by including in its command formats provision for\n   explicitly specifying filename and password information in each\n   command.  When many operations involving the same file appear\n   sequentially in the input stream, the user need only let the\n   appropriate fields default in all but the first command, avoiding\n   re-transmission of what would otherwise be redundant parameters.\n\n\n\n\n\nJ. White                                                       [Page 12]\n\f\nRFC 122                Simple-Minded file System              April 1971\n\n\n                                          M\n                                          O\n                                          D\n                                          I\n                                          F\n                                          I\n                                  A       C\n                                  C       A\n                                  C       T\n                                  E       I      N\n                                  S       O      E\n                                  S       N      W\n                                                       B\n                            F     P       P      F     I\n            O               I     A       A      I     T\n            P               L     S       S      L\n                    F       E     S       S      E     C\n            C       L       N     W       W      N     O     D\n            O       A       A     O       O      A     U     A\n            D       G       M     R       R      M     N     T\n            E       S       E     D       D      E     T     A\n   _____________________________________________________________\n   ALF      X       X       X     X       X            X\n   _____________________________________________________________\n   UDF      X       X       X             X            X     X\n   _____________________________________________________________\n   RPF      X       X       X             X            X     X\n   _____________________________________________________________\n   RTF      X       X       X     X                    X\n   _____________________________________________________________\n   SPF      X       X       X     X                    X\n   _____________________________________________________________\n   DLF      X       X       X             X\n   _____________________________________________________________\n   RNF      X       X       X             X      X\n   _____________________________________________________________\n   FNO      X\n   _____________________________________________________________\n   NOP      X\n   _____________________________________________________________\n\n\n                               Figure 3\n\n                         Defined Command Fields\n\n        Note: Command fields marked with an 'X' are defined.\n\n\n\n\nJ. White                                                       [Page 13]\n\f\nRFC 122                Simple-Minded file System              April 1971\n\n\n   0   ACCESS PASSWORD        The access password for this\n       DEFAULTS               operation defaults to the access\n                              or modification password which\n                              appeared explicitly most\n                              recently in the input stream;\n                              hence, it does not appear\n                              explicitly in the current\n                              command.\n\n   1   BIT COUNT DEFAULTS     The bit count for this operation\n                              defaults to that which appeared\n                              explicitly most recently in the\n                              input stream; hence it does not\n                              appear explicitly in the current\n                              command.\n\n   2   FILENAME DEFAULTS      The filename for this operation\n                              defaults to the filename or new\n                              filename which appeared explicitly\n                              most recently in the input stream;\n                              hence it does not appear\n                              explicitly in the current command.\n\n   3   ACCESS PASSWORD        The access password for this\n       APPEARS EXPLICITLY     operation appears explicitly in\n                              the current command. (Bits 0,\n                              3 = 0 indicates that no access\n                              password was/is-to-be defined\n                              for the file.)\n\n   4   ECHO OP CODE           SMFS shall echo the op code and\n       AND FILENAME           filename (whether it appears\n                              explicitly or not) by copying\n                              them into the output stream\n                              ahead of any other response to\n                              the current command.\n\n   5-7 undefined              Not examined; should be zeros.\n\n   8   MODIFICATION           Same as Bit 0, but applied to\n       PASSWORD DEFAULTS      the modification password, rather\n                              than the access password.\n\n                         Figure 4\n\n              Definition of Command FLAGS Bits\n\n\n\n\n\nJ. White                                                       [Page 14]\n\f\nRFC 122                Simple-Minded file System              April 1971\n\n\n   9   FILE FORMATTED         FOR UDF/RTF: this segment is part\n                              of a formatted file; hence SMFS\n                              should record the bit count. For\n                              RTF/SPF: the referenced file is\n                              formatted; hence the bit count\n                              does not appear explicitly in the\n                              current command\n\n   10   NEW FILENAME          same as Bit 2, but applied\n        DEFAULTS              to the new filename, rather\n                              than the filename.\n\n   11   MODIFICATION PASSWORD Same as Bit 3, but applied to\n        APPEARS EXPLICITLY    the modification password,\n                              rather than the access\n                              password.\n\n   12-15 undefined            Not examined; should be zeros.\n\n                      Figure 4(continued)\n\n                 Definition of Command FLAGS Bits\n\n      Note: The sixteen bits of FLAGS are numbered 0-15 from\n         left to right.\n\n   When a series of RTF/SPF operations referencing the same file are\n   juxtaposed in the input stream (as discussed in Section V.D.), they\n   cause successive segments of the file to be transmitted _only_ if\n   both filename and access password default (Bits 0,2 = 1) (a null\n   password is also acceptable) in those operations following the first\n   in the series.  If the user specifies either parameter explicitly in\n   a command in the series -- even if the explicitly stated value is the\n   same as what would have been the default value -- SMFS considers the\n   series terminated, as if a FNO had been encountered, and hence the\n   command in question returns, or flushes, the first segment of the\n   file.  Allowing both filename and password to default has the added\n   effect, in both RTF/SPF and UDF series, of decreasing the processing\n   time required by SMFS to execute the operations which comprise the\n   series.  Under such circumstances, SMFS executes such initial\n   functions as file location and password verification only once at the\n   beginning of the series, rather than for each operation.  Hence, a\n   potential for increased transmission rates exists.  Furthermore, in\n   such a series of UDF/RPF operations, SMFS is able to conserve\n   secondary storage by concatenating file segments before they are\n   written out.\n\n\n\n\n\nJ. White                                                       [Page 15]\n\f\nRFC 122                Simple-Minded file System              April 1971\n\n\n   Whenever SMFS aborts the processing of a command in the input stream\n   (e.g., the filename is invalid, an incorrect password is supplied,\n   etc), SMFS flushes the entire command.  Suppose, for example, that\n   the file specified in a UDF operation does not exist (i.e., has not\n   been allocated).  If the data field for the operation is very long,\n   SMFS may well detect the non-existence of the file before the data\n   field has been transmitted by the user.  In such cases, SMFS will\n   accept and flush whatever remains of the aborted command (in this\n   case, including the very long data field) until it reaches the point\n   in the input stream at which it expects to find the next command,\n   which it will process normally.  SMFS will, however, notify the user\n   that the command was aborted by placing an appropriate indicator in\n   the output stream, and it will do this as soon as it detects the\n   error (and hence, in this case, before the erroneous command has been\n   flushed from the input stream).  Hence, the user has the option of\n   aborting the process by closing the connection.\n\n   SMFS considers a command with an invalid op code as an especially\n   severe error, since it has no way of locating the start of the next\n   command.  Accordingly, it places a special character (X'FF') in the\n   output stream, follows it with the invalid op code, and then closes\n   its connections to the user.\n\nVII.  Output Stream Format\n\n   SMFS will respond to each command it extracts from the input stream\n   -- every command except FNO and NOP -- by placing a command response\n   in the output stream.  Command responses have the following general\n   format:\n\n       8                8       32\n     _________//___________________________//____\n    | OP  |          | CMPL |         |          |\n    |CODE | FILENAME | CODE |BIT COUNT|  DATA    |\n    |_____|___//_____|______|_________|____//____|\n\n   where the lengths of fixed-length fields have been indicated in bits.\n   The field 'FILENAME' is further divided into the following subfields:\n\n        8         8*LENGTH\n     _______________//______\n    |        |              |\n    | LENGTH | FILENAME     |\n    |________|______//______|\n\n   where the 'LENGTH' subfield contains the length in 8-bit characters\n   of the 'FILENAME' subfield.\n\n\n\n\nJ. White                                                       [Page 16]\n\f\nRFC 122                Simple-Minded file System              April 1971\n\n\n   This is the general format for SMFS command responses.  For responses\n   to particular commands, not all fields may be present.  A particular\n   subset of these fields is defined for each type of command response;\n   no other fields will appear.  The defined fields for each command\n   response type are indicated in Figure 5.\n\n   The fields 'OP CODE' and 'FILENAME' are the op code and filename\n   extracted by SMFS from the input stream and are echoed by SMFS in the\n   output stream.  The filename is always echoed explicitly, even if it\n   appeared implicitly in the input stream. 'OP CODE' and 'FILENAME' are\n   suppressed and hence do not appear in the command response it Bit 4\n   of the 'FLAGS' field of the corresponding command is set to 0.\n\n   'CMPL CODE' contains an indication of the outcome of the operation.\n   If the operation was completed successfully, 'CMPL CODE' contains a\n   value equal to the op code of the command executed.  Hence, if\n   echoing of 'OP CODE' and 'FILENAME' is not suppressed, the operation\n   was successful if and only if 'OP CODE' and 'CMPL CODE' are\n   identical.  If the operation as unsuccessful, 'CMPL CODE' contains an\n   indication of the error encountered by SMFS in processing the\n   command.  Completion codes are summarized in Figure 6.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nJ. White                                                       [Page 17]\n\f\nRFC 122                Simple-Minded file System              April 1971\n\n\n                              C\n                              O\n                              M\n                              P\n                              L\n                              E\n                    F         T         B\n                    I         I         I\n          O         L         O         T\n          P         E         N\n                                        C\n          C         N         C         O         D\n          O         A         O         U         A\n          D         M         D         N         T\n          E         E         E         T         A\n   _____________________________________________________\n\n   NOP\n   _____________________________________________________\n\n   FNO\n   _____________________________________________________\n\n   ALF    X         X         X\n   _____________________________________________________\n\n   UDF    X         X         X\n   _____________________________________________________\n\n   RPF    X         X         X\n   _____________________________________________________\n\n   RTF    X         X         X         X         X\n   _____________________________________________________\n\n   SPF    X         X         X         X\n   _____________________________________________________\n\n   DLF    X         X         X\n   _____________________________________________________\n\n   RNF    X         X         X\n    _____________________________________________________\n\n                        Figure 5\n             Defined Command Response Fields\n\n   Note: Command response fields marked with an 'X' are defined.\n\n\n\nJ. White                                                       [Page 18]\n\f\nRFC 122                Simple-Minded file System              April 1971\n\n\n   An invalid op code in the input stream constitutes a special type of\n   error.  SMFS's response is as follows.  A special command response is\n   constructed.  It consists of the value X'FF' in an eight-bit field,\n   followed by the erroneous op code, also in an eight-bit field.  The\n   command response is placed in the output stream and connections to\n   the user are closed.\n\n\n      2  ALLOCATION SUCCESSFUL   The file was successfully allocated.\n\n      3  UPDATE SUCCESSFUL       The file was successfully updated.\n\n      4  REPLACE SUCCESSFUL      The file was successfully replaced.\n\n      5  RETRIEVE SUCCESSFUL     The file segment was successfully\n                                 retrieved.\n\n      6  SPACE SUCCESSFUL        The file segment was successfully\n                                 flushed.\n\n      7  DELETION SUCCESSFUL     The file was successfully deleted.\n\n      8  RENAME SUCCESSFUL       The file was successfully renamed.\n\n     20  NO DEFAULT FILENAME     The user attempted to default the\n                                 filename (or new filename), and the\n                                 filename accumulator was empty.\n\n     21  ZERO-LENGTH FILENAME    The length of the filename (or new\n                                 filename) was specified as zero.\n\n     22  FILENAME TOO LONG       The length of the filename (or new\n                                 filename) exceeded 36 characters.\n\n     23  INVALID FILENAME        The filename (or new filename)\n                                 contained character(s) that do not\n                                 appear in the character set.\n\n     24  NO DEFAULT PASSWORD     The user attempted to default either\n                                 the access or modification password,\n                                 and the password accumulator was empty.\n\n     25  ZERO-LENGTH PASSWORD    The length of either the access of\n                                 modification password was specified as\n                                 zero.\n\n                                Figure 6\n                            Completion Codes\n\n\n\nJ. White                                                       [Page 19]\n\f\nRFC 122                Simple-Minded file System              April 1971\n\n\n     26  PASSWORD TOO LONG       The length of either the access or\n                                 modification password exceeded 36\n                                 characters.\n\n     27  NO DEFAULT BIT COUNT    The user attempted to default the bit\n                                 count, and the bit-count accumulator\n                                 was empty.\n\n     28  INVALID PASSWORD        Either the access or modification\n                                 password contained character(s) that do\n                                 not appear in the character set.\n\n     29  DUPLICATE FILENAME      Either the filename (in an ALF\n                                 operation) or new filename (in a RNF\n                                 operation) is already assigned to\n                                 another file.\n\n     30  INSUFFICIENT SPACE      (In an ALF operation) The requested\n                                 amount of secondary storage is\n                                 unavailable.\n\n     31  ALLOCATION I/O ERROR    (In an ALF operation) An irrecoverable\n                                 I/O error was encountered by SMFS while\n                                 attempting to allocate the file.\n\n     32  FILE NOT FOUND          The referenced file does not exist.\n\n     33  SEARCH I/O ERROR        An irrecoverable I/O error was\n                                 encountered by SMFS while attempting to\n                                 locate the referenced file.\n\n     34  FILE FULL               (In a UDF/RPF operation) The secondary\n                                 storage allocated to the file has been\n                                 exhausted.\n\n     35  INCORRECT PASSWORD      The access or modification password\n                                 supplied by the user does not match\n                                 that declared when the file was\n                                 allocated.\n\n     36  FILE SIZE TOO SMALL     (In an ALF operation) The bit count\n                                 specified is less than the minimum file\n                                 size accepted by SMFS.\n\n                          Figure 6 (continued)\n                            Completion Codes\n\n\n\n\n\nJ. White                                                       [Page 20]\n\f\nRFC 122                Simple-Minded file System              April 1971\n\n\n     37  FILE SIZE TOO BIG       (In an ALF operation) The bit count\n                                 specified exceeded the maximum file\n                                 size accepted by SMFS.\n\n     38  WRITE I/O ERROR         An irrecoverable I/O error as\n                                 encountered by SMFS. (In an ALF\n                                 operation) SMFS was attempting to\n                                 record password information, or (in a\n                                 UDF/RPF operation) SMFS as attempting\n                                 to add data to the file.\n\n     39  READ I/O ERROR          An irrecoverable I/O error was\n                                 encountered by SMFS attempting to\n                                 retrieve either password information or\n                                 data.\n\n     40  RENAME I/O ERROR        An irrecoverable I/O error was\n                                 encountered by SMFS while attempting to\n                                 rename the file.\n\n     41  DELETE I/O ERROR        (In a DLF operation) An irrecoverable\n                                 I/O error was encountered by SMFS while\n                                 attempting to delete the file.\n\n     42  END-OF-DATA             (In a RTF/SPR operation) The end of the\n                                 file was reached before the requested\n                                 segment had been transmitted/flushed.\n\n                           Figure 6 (continued)\n                             Completion Codes\n\n\n\n\n         [ This RFC was put into machine readable form for entry ]\n          [ into the online RFC archives by Gottfried Janik 2/98 ]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nJ. White                                                       [Page 21]\n\f\n"
}