{
  "series": "Request for Comments",
  "number": "441",
  "howpublished": "RFC 441",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0441",
  "url": "https://www.rfc-editor.org/info/rfc441",
  "title": "Inter-Entity Communication - an experiment",
  "pagetotal": "7",
  "year": "1973",
  "month": "jan",
  "body": "\n\n\n\n\n\nNetwork Working Group                                       Bob Bressler\nRequest for Comments: 441                                     Bob Thomas\nNIC 13773                                               January 19, 1973\n\n               Inter-Entity Communication - An Experiment\n\n\n   This note is an attempt to be a status report concerning an\n   experiment based on the desire of users, at their consoles, to\n   converse with one another, and perhaps to get some debugging\n   assistance.  The user might ask: \"who can I talk to\"; \"can I show him\n   what I have done\", and \"can I let him run my program?\"  Many time\n   sharing systems provide capabilities such as these, within the bounds\n   of their system.  Almost all systems have a \"WHO\" or \"SYSTAT\", many\n   have commands like \"LINK\" or \"TALK\", and some support more esoteric\n   capabilities like controlling another user's program.  At the last\n   formal meeting of the Network Working Group, in October of 1971 at\n   MIT, a group got together to talk about these features for Inter\n   Entity Communications (IEC), and how they might be extended to span\n   across Host boundaries.\n\n   Subsequent development has proceeded in an ad hoc manner.  The\n   general design philosophy paralleled that of TELNET in terms of\n   having both server and user programs.  The server program would\n   handle commands like \"connect to user FOO\", \"where is user BAR\", or\n   \"who is on your system?\"  An initial implementation of a server and\n   user was brought up at MIT-DMCG, using a completely arbitrary\n   protocol.  Soon after that, in an effort to increase its usefulness,\n   the protocol was modified to be compatible with that being used by\n   the Resource Sharing Executive being developed at BBN-TENEX.\n\n   The MIT user program used the concept of \"ports\" to help identify\n   character streams entering and leaving an object.  A pictorial\n   diagram follows (FIGURE 1) showing a user teletype, his job and two\n   consultants with whom he is conversing.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBressler \u0026 Thomas                                               [Page 1]\n\f\nRFC 441                Inter-Entity Communication           January 1973\n\n\n              +------+\n              | USER |\n              | TTY  |\n              +------+\n                |   |\n   -------------|---|--------------+\n                |   |              |               +-------+\n        +------------------+       |               | HOST  |\n        |     COMMAND      |       |               |   A   |\n        |   INTERPRETER    |       |               +-------+\n        +---+-+-------+-+--+       |                   |\n        TTY |_|       |_| TTY      |                   |\n    OUT-PORT ^         | IN-PORT   |                   |\n             |         |           |                   |\n             |         V           | +--------------+  |\n                                 +-|-+              |  |\n                            \u003c----| |IN-PORT         |--+\n                                 +-|-+              |\n                                   | |  CONSULTANT  |\n                                   | |     #1       |\n                                 +-|-+              |\n               I.E.C.         ----\u003e| |OUT-PORT      |\n                                 +-|-+              |\n                                   | +--------------+\n                                   |\n                                   | +--------------+\n                                 +-|-+              |\n                            \u003c----| |IN-PORT         |--+\n                                 +-|-+              |  |\n                                   | |  CONSULTANT  |  |\n                                   | |     #2       |  |\n                                 +-|-+              |  |\n           ^          |     ----\u003e| |OUT-PORT        |  |\n           |          |          +-|-+              |  |\n   JOB     |          V  JOB       | +--------------+  |\n   IN-PORT+--+       +--+OUT-PORT  |                   |\n     -----|--|-------|--|----------+                   |\n     +----+  +-------+  +---------+                    |\n     |                            |                 +------+\n     |      USER     JOB          |                 | HOST |\n                                                    |  B   |\n                                                    +------+\n\n   The user now has the option of opening or closing any of the ports he\n   wishes.  While in conversation mode, he might turn off the ports\n   leading to the JOB.  If he wished consultant 1 to control the job, he\n   might turn off the input ports from his own TTY and from consultant\n   2.\n\n\n\nBressler \u0026 Thomas                                               [Page 2]\n\f\nRFC 441                Inter-Entity Communication           January 1973\n\n\n   Towards this goal, the user interface provides the following set of\n   commands:\n\n   WHO         user supplies which host, and given a list of [user,\n               teletype, jobs].\n\n   WHERE       user supplies identification of another user, and program\n               tries to find him on all the servers it knows about (for\n               1 server, that code was very easy to write!)\n\n   OPEN or CLOSE     user specifies which port to turn on or turn off.\n\n   PORT MAP    gives the user a picture of all his ports.\n\n   CONNECT     user specifies host, user, and port identification.  If\n               successful, results in an open connection to the\n               specified user.\n\n   DISCONNECT  user specifies port, and connection is cleanly broken.\n\n   The above description applies to the program at MIT-DMCG.  Similar\n   ones will soon be available on the other ITS systems.\n\n   From TENEX, the user interface is through the RSEXEC subsystem.  To\n   the user, the RSEXEC looks much like the standard TENEX EXEC, but not\n   limited to just the local system. With the exception of the concept\n   of PORTS, the command structure is similar to that previously\n   described:\n\n   @ WHERE   (is user) THOMAS\n\n             Lists each \"currently active\" job of user Thomas.  Each job\n             is identified by its network site, job I.D. and attached\n             terminals.\n\n   @ SITES   (of user) BRESSLER\n\n             Lists all of the (currently accessible) network sites where\n             user Bressler has an account.\n\n   @ LINK    (to TTY0 103 (AT SITE) UTAH-10\n\n             Links the user's terminal to terminal 106 at the UTAH PDP-\n             10.\n\n   @ WHO     Lists the users currently logged in at each (accessible)\n             network site. (WHO has options for specifying selected\n             sites.)\n\n\n\nBressler \u0026 Thomas                                               [Page 3]\n\f\nRFC 441                Inter-Entity Communication           January 1973\n\n\n   Supplementing the above services, the TENEX RSEXEC program provides a\n   set of files system tools. It is planned to integrate these services\n   with the FTP type protocols, and make these services available on\n   other non-TENEX systems.\n\n   Socket 245 (decimal) has been assigned to this experiment. As\n   mentioned above, these services are now (or will soon be) available\n   on many ITS and TENEX systems. In addition, at least one of these\n   services will be available on a non login basis. This will enable TIP\n   users to avail themselves of these communication facilities.\n\n   Further participation in this experiment is of course invited. It is\n   hoped that a service like this can play an important role in network\n   development. Sites are invited to experiment with the \"conferencing\"\n   possibilities of this experiment. We would be interested in knowing\n   what drawbacks are encountered. The protocol design will remain\n   flexible, and can be expanded to meet short comings that use will\n   discover. Areas of experimentation include integration with the mail\n   protocol, conference scheduling, and incorporating a picture oriented\n   graphics protocol, for graphics users to share screens.\n\n   Attached is a copy of the protocol currently used. At first glance,\n   it may appear hostile to non PDP-10s, but this was not intentional.\n   A new and more general protocol is being developed, but since this\n   one is operational, it seems useful to try using it.\n\n                             INTERIM PROTOCOL\n\n   There are two parts to the RSEXEC protocol:\n\n   1. an initial connection protocol which specifies how a user program\n      connects to the server program, and\n\n   2. a command protocol which specifies how the user process talks to\n      the server process to get service.\n\n   Initial Connection Protocol\n\n   To connect to the server the user process connects to socket number\n   365 (octal) connection byte size = 32. The server program then\n   transmits two bytes and breaks the connection:\n\n      byte 1 = socket number = X\n\n      byte 2 = transaction number (meaningful to server)\n\n\n\n\n\n\nBressler \u0026 Thomas                                               [Page 4]\n\f\nRFC 441                Inter-Entity Communication           January 1973\n\n\n   The server and user programs complete the ICP by opening two 36 bit\n   \"working\" connections:\n\n      U + 3 --\u003e X\ufffd\n\n      U + 2 --\u003e X + 1\n\n      where U = the socket used by the user program to initiate the ICP.\n\n   After the two working connections are established the server is ready\n   to accept commands.\n\n   Note that the RSEXEC ICP is virtually identical to the official\n   ARPANET ICP, the single difference being transmission of the\n   transaction number.\n\n   Command Protocol\n\n   [Note on terminology:\n\n   ASCII       7 bit characters, packed 5 to a 36 bit word, with the low\n               order bit 0.  In all following examples the contents of a\n               string are delimited with \"/\".\n\n   ASCIZ       ASCII, terminated with a character (7 bits) of zero.\n\n   SIXBIT      6 bit characters, packed 6 to a 36 bit word.  A sixbit\n               character + 60 (octal) = the equivalent ASCII character.\n\n   byte        unless otherwise stated is 36 bits.\n\n   XWD A,B     Half words.  18 high order bits = A, 18 low order bits =\n               B.]\n\n   USINF\n\n   To obtain information about a user at the server's site\n\n   1. user sends:\n\n     byte 1: ASCII /USINF/\n     byte 2-\u003ek: ASCIZ /USERNAME/\n\n\n\n\n\n\n\n\n\nBressler \u0026 Thomas                                               [Page 5]\n\f\nRFC 441                Inter-Entity Communication           January 1973\n\n\n   2. server responds:\n\n     neg ack: 1 byte = XWD 0, error #  ;no such user\n\n     pos ack: byte 1:    -1\n              byte 2-\u003en: XWD job #, tty #\n                            where tty # = -1 if job detached\n              byte n+1:  -1\n\n   SSTAT\n\n   To obtain the active users at the server's site\n\n   1. user sends:\n     byte 1: ASCII /SSTAT/\n\n   2. server responds:\n\n     neg ack: 1 byte =  0\n\n     pos ack: 1 byte =  -1\n              followed by data blocks of the form\n\n              a. 1 byte = -1    ;means end of transmission\n              or\n              b. byte 1:       XWD job #,tty #\n                 byte 2:       SIXBIT /subsys name/\n                 byte 3-\u003en:    ASCIZ /USERNAME/\n\n   LINK\n\n   To link to a user terminal at the server site\n\n   1. user sends:\n\n     byte 1: ASCII /LINK/\n     byte 2: terminal #\n\n   2. server responds:\n\n     neg ack: 1 byte = 0\n\n     pos ack: 1 byte = number N   ;means server will attempt link\n\n   3. if positive acknowledgement server and user try to establish the two\n      8 bit connections:\n\n         N + 1 --\u003e U\n\n\n\nBressler \u0026 Thomas                                               [Page 6]\n\f\nRFC 441                Inter-Entity Communication           January 1973\n\n\n         N     --\u003e U + 1\n\n     where U is the socket used by the user to initiate the ICP.\n\n   These connections are to be used to carry text to and from the linked\n   tty at the server's site.\n\n   4. server responds (a second time):\n\n     neg ack: 1 byte = 0   ;means can't establish connections or\n                           ;couldn't make the link\n\n     pos ack: 1 byte = -1  ;means link to tty established and\n                           ;anything transmitted over the\n                           ;connections will go to linked tty.\n\n   BREAK\n\n   To break a link previously established to a terminal at the server\n   site:\n\n   1. user sends:\n\n     byte 1: ASCII /BREAK/\n\n   2. server responds:\n\n     neg ack: 1 byte = XWD 0,error #\n\n     pos ack: 1 byte = -1   ;link successfully broken\n\n   TERMINATE\n\n   To terminate connection with the server the user can either send a\n   single byte = 0 or just close the connections.  The former is\n   preferred.  The server responds by breaking the connections.\n\n\n\n\n\n\n\n\n\n          [This RFC was put into machine readable form for entry]\n      [into the online RFC archives by H\ufffdl\ufffdne Morin, Viag\ufffdnie, 12/99]\n\n\n\n\nBressler \u0026 Thomas                                               [Page 7]\n\f\n"
}