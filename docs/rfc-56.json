{
  "series": "Request for Comments",
  "number": "56",
  "howpublished": "RFC 56",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0056",
  "url": "https://www.rfc-editor.org/info/rfc56",
  "title": "Third Level Protocol: Logger Protocol",
  "pagetotal": "6",
  "year": "1970",
  "month": "jun",
  "body": "\n\n\n\n\n\nNetwork Working Group                                Ed Belove (Harvard)\nRequest for Comments: 56                            Dave Black (Harvard)\n                                                       Bob Flegel (Utah)\n                                                 Lamar G. Farquar (Utah)\n                                                               June 1970\n\n\n                          Third Level Protocol\n\n                            Logger Protocol\n\n                          General Description\n\n\nIn our view of the world each host has a set of four programs to allow a\nuser teletype to communicate with a foreign monitor. The exact\nimplementation of these programs is highly installation-dependent.  Thus\nall explanations are meant to describe functional characteristics rather\nthan design.\n\nThe four programs come in two male/female pairs. A user employs a send-\nlogger at his site to communicate with receive-logger at the appropriate\nforeign site in order to establish a full duplex link between the user's\nteletype and the foreign machine's monitor. This puts him in the\nequivalent of a pre-logged in state at the other machine.  After the\nlink has been established, the two loggers drop out of the picture, and\nthe user is left talking to a sender in his machine, whose main function\nis to take input from the user's teletype and send it down the link that\nwas established by the loggers to the receiver in the foreign host which\npasses it along to its monitor (making it look like input from a local\nteletype). Replies from the foreign monitor are given by it to the\nreceiver, which transmits them back along the link to the sender, which\noutputs them on the user's teletype. The sender and receiver in each\nmachine must either exist in multiple copies, one for each network user,\nor there must be a single copy which can handle all of the network\nusers. The loggers, however, need be able to handle only one user at a\ntime, since their task is quickly accomplished, leaving them free to\nsatisfy other requests.  However there should be some method of queuing\nrequests that can not be satisfied immediately. A less satisfactory\nalternative would be to give a busy message to any user who tries to use\nthe logger while it is busy. (This, of course, does not preclude the\npossibility of an installation having a re-entrant logger, or of having\nmultiple copies of the logger.)\n\nThe receive-logger should be user zero in every machine and should\nalways be listening to socket zero. (This same thing can be accomplished\nby having the NCP intercept all messages to user zero, socket zero, and\nsend them to the receive-logger; but it is simpler and cleaner to have\n\n\n\n                                                                [Page 1]\n\f\nthe logger actually be user zero and have the NCP handle its messages\nthe same as everyone else's.)\n\nWhen the send-logger is called, it pulls a pair of unused sockets (2N\nand 2N+1) from a pool of free sockets and CONNECT from 2N+1 to User 0,\nSocket 0 in the desired foreign host. This activates the receive-logger,\nwhich accepts the connection if it has an available slot for the foreign\nteletype. He then immediately closes down this connection to allow links\nfrom other sources to be initiated. If, on the other hand, there is no\nroom for the foreign teletype (or if, for some other reason, the\nreceive-logger does not wish to connect) the attempted link to socket\nzero is refused. This notifies the send-logger that he cannot log on the\nforeign host and it then notifies the user of this fact. There is no\nguarantee, however, that the close was actually sent by the foreign\nlogger. It could have been sent by the NCP if, for example, the pending\ncall queue for the socket was overloaded.\n\nIf the link to socket zero has been accepted (thus indicating that the\nreceive-logger can accommodate the request) after closing that link, the\nreceive-logger picks an available pair of sockets (2M and 2M+1) from its\npool, and connects from 2M+1 to 2N. (It found the identity of 2N when\nits listen was answered by the link with 2N+1.)  The send-logger has\nmeanwhile listened to socket 2N and now accepts the link, and CONNECTS\nfrom 2N+1 to 2M. The receive-logger has been listening to this socket\nand accepts the attempted link.\n\nAt this point, there is a full duplex connection between the two\nloggers. They then activate the sender and receiver, which handle all\nother communication between the user and the foreign monitor.  (The\nsenders and receivers can be part of the loggers, or can be called by\nthem, etc.)\n\nWhen the user is finished and escapes back to his monitor, it is up to\nthe sender to close down the links. On the receiving end, it would be\nhighly desirable for the NCP to notify the receiver of this fact, so it\ncould log the user off (if he had failed to do that himself) and could\nfree any resources that he had been using.\n\nA more formal outline of the proposed protocol described in the scenario\nabove follows:\n\n\n\n\n\n\n\n\n\n\n\n                                                                [Page 2]\n\f\n   1. Stable state: receive-logger at foreign host listening to User 0,\n   Socket 0.\n\n   2. Local user calls send-logger.\n\n   3. Send-logger calls CONNECT (port, 2N+1, \u003cforeign host#,0,0\u003e).\n\n   4. Send-logger calls LISTEN (port, \u003clocal host#, user#, 2N\u003e).\n\n   5. Foreign logger's LISTEN is answered, and he is told local user\n   number, host and #2N+1.\n\n   6. Foreign logger looks for available sockets (2M and 2M+1).  If they\n   exist and it is able to establish connection, it accepts and then\n   immediately closes the link.\n\n   7. Foreign logger calls CONNECT (port, 2M+1, \u003clocal host#, user#,\n   2N\u003e).\n\n   8. Foreign logger calls LISTEN (port, \u003clocal host#, user#, 2M\u003e).\n\n   9. Send-logger has listened to 2N and accepts link, then calls\n   CONNECT (port, 2N+1, \u003cforeign host#, user#,2M\u003e).\n\n   10. Receive-logger, which is listening on 2M, accepts link.\n\n   11. Loggers activate appropriate handlers.\n\n   12. When the user is finished, sender closes down both links.\n\nThis basic method of establishing a full duplex connection should be\nstandard throughout the network. The particular way each installation\nhandles the implementation of the sender, receiver, and the two loggers\nis of no consequence to the network and is highly machine dependent.\n(Even the fact of needing a sender and receiver is machine dependent in\nthat some members of the network might be able to handle their functions\nin other ways.) However, some conventions must be established regarding\ncommunication between the sender and receiver, or their equivalents.\n\nNetwork Standard Code\n\nIn order to facilitate use of the network, we propose the convention\nthat all teletype-to-foreign-monitor communication be done using 128\ncharacter USASCII. (This is the code used by the IMP's and is in the\nappendix to the IMP operating manual.) It makes sense to require\nmachines to make only one conversion to a standard code, than to have to\nmake conversions to every code on the net.\n\n\n\n\n                                                                [Page 3]\n\f\nIn addition, since most of the network machines use ASCII as their\ninternal character code, it will be no trouble for them. Even those\nmachines that use a different code must translate to and from ASCII in\norder to communicate with local teletypes. Extending this translation to\nthe network should cause very little trouble. We envision this\ntranslation as taking place in the sender and receiver, but again that\nis implementation dependent.\n\nIf ASCII is adopted as a standard, we would suggest that all non-ASCII\nmachines create a monitor to the machine's internal code. This would\nmake the complete character set available to those who wished to use it\n(and were willing to write a simple conversion routine for the local\nmachine.) In this way, those users who wanted to could use any machine\non the net from their teletype, without requiring their machines to have\nrecords of all the network codes, and yet could use the full power of\nthe foreign machine if they wanted.\n\nAgain, this standard applies only for teletype-to-foreign-monitor\ncommunication.\n\nBreak Characters\n\nA standard way of handling the break character has to be established for\nthe network and be included in the protocol. Problems with the break\ncharacter arise in several contexts. First, there are two distinct\npurposes served by the break character. One is as a panic button. This\nsays, \"I do not care what is happening, stop and get me out to monitor\nlevel now.\" This command is executed immediately upon receipt, and is\nmost commonly used to get out of a program that one does not want to be\nin (e.g., one that is in an infinite loop, etc.)\n\nThe other purpose that is served is that of an exit from a subsystem, or\non a machine with a forking structure as a method to get back to the\nnext higher level fork. This second purpose is not an immediate one in\nthat the user wants the system to finish all that he has told it to do\nbefore exiting.\n\nWe assume that there does not exist in every system 1) a way of\nperforming each of these functions, or 2) a clear cut distinction\nbetween the calling and operation of the two. Furthermore, there are\nsubtle distinctions as to how each system treats the commands.\n\nThe panic button function can easily be performed by the proposed\ncontrol command \u003cINT\u003e. This function must be accomplished by using a\ncontrol command, since a program can enter a state where it is accepting\nno input: hence, the program cannot be aborted by sending it a message\ndown the teletype link. There is no reason to worry about the race\ncondition caused by sending this command down the control link since its\n\n\n\n                                                                [Page 4]\n\f\nwhole purpose is to force the machine to disregard everything else the\nuser has sent.\n\nIn our implementation of this, we would ask the user to specify to the\nlogger a seldom used character that he wants to be his foreign panic\nbutton. Then, it would be a simple task for the sender to map this\ncharacter into an \u003cINT\u003e command, which the foreign machine must\ninterpret properly. This scheme would work well for most machines, but\nsome may lend themselves to different ways of generating the \u003cINT\u003e.\n\nThe other problem that presents itself is what to do if the foreign\nmachine's \"exit\" character is the same as the local machine's.  The\nproblem is that while a user is talking to a foreign machine, he would\nwant to be in a transparent mode, where everything he types is sent\ndirectly to the other machine. The way he would get himself out of this\nmode is to type either his machine's \"exit\" character or its panic\nbutton. Thus, if the foreign machine has the same one, there would be no\nway to send it. The way out of this is the same as above--merely a\nmapping of another seldom used character into the foreign machine's\n\"exit\" character. This type of mapping can be carried as far as each\ninstallation deems necessary. Giving the user complete control over\ntranslation is helpful in that it allows him to user characters that his\nteletype cannot generate.\n\nCommand Message Formats\n\nEach site should establish its now conventions about when to send a\nmonitor command string, and in what size chunks. When performing a\nroutine operation, one might want to send several command lines as a\nsingle message. If working with the monitor as usual, a reasonable break\npoint might be at every carriage return. When using a highly interactive\nlanguage such as QED, one might decide character-by-character\ntransmission was a necessity. We feel that each user should have the\nchoice between these three methods (and possible more). Furthermore, the\nuser should be able to change between each mode at will. The differences\nin syntax of the send-message commands mentioned above should be noted.\nFor the first, a special send-message command character must be defined,\nand it should not be sent along with the message. For the second, the\ncarriage return acts dually as the send-message command and as a command\ndelimiter. Therefore it must be sent with the message. Finally, the case\nof character-by-character transmission with its implicit send command\nshould pose no significant problems.\n\n\n\n\n\n\n\n\n\n                                                                [Page 5]\n\f\nThe preceding discussion is meant to imply also that the receiver must\nbe able to buffer up each of the above types of transmission into a form\nacceptable to its own monitor interface.\n\nIn addition, all echoing should be done in the local host, with the\nforeign machine suppressing its echoes (if it can.)\n\n\nWe would like to thank Carl Ellison (of Utah) for his valuable\nsuggestions and criticisms of this work, and Jim Curry (of Utah) for his\nencouragement and support of the effort.\n\n\n       [ This RFC was put into machine readable form for entry ]\n          [ into the online RFC archives by Jon Ribbens 7/97 ]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                                [Page 6]\n\f\n"
}