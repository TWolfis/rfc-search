{
  "series": "Request for Comments",
  "number": "178",
  "howpublished": "RFC 178",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0178",
  "url": "https://www.rfc-editor.org/info/rfc178",
  "title": "Network graphic attention handling",
  "pagetotal": "11",
  "year": "1971",
  "month": "jun",
  "body": "\n\n\n\n\n\nNetwork Working Group                                      Ira W. Cotton\nRequest for Comments: 178                                          MITRE\nNIC: 7118                                                  June 27, 1971\n\n\n                   NETWORK GRAPHIC ATTENTION HANDLING\n\n\n1.0 INTRODUCTION\n\n   Discussions of network graphic protocols have thus far primarily\n   dealt with protocols for the description of graphic data to be\n   displayed.  RFC 86 proposed a Network Standard Graphic Data Stream\n   (NGDS) which would serve to convey graphic images expressed in the\n   Network Standard Display List (NGDL).  RFC 94 expanded on this\n   proposal, and pointed out some shortcomings of the original scheme.\n   RFC 125 also replied to RFC 86 with comments and extensions, but also\n   recognized that a protocol for graphic display alone is insufficient\n   to support an interactive graphic system.\n\n1.1 TOPICS COVERED\n\n   The present paper addresses itself to this requirement.  The process\n   of attention handling is briefly described, various graphic\n   configurations are discussed, input devices are surveyed to identify\n   the types of data which they produce, and an attention protocol is\n   suggested.\n\n1.2 VIEWPOINT\n\n   It should be made clear at the onset that the discussion which follow\n   will be from the viewpoint of a graphics user or a graphic\n   application program serving one or more users.  Our concern is with\n   third-level protocols only.  We assume the network is capable of\n   delivering arbitrary bit streams from terminal to graphic application\n   program, but don't care how this is accomplished.\n\n2.0 ATTENTION-HANDLING\n\n   In order to demonstrate the need for an attention protocol, we must\n   first define what is meant by \"attention\" and \"attention-handling.\"\n   We therefore begin by borrowing the definitions given in a recent\n   survey of this area(1).\n\n\n\n\n\n\n\n\nCotton                                                          [Page 1]\n\f\nRFC 178            NETWORK GRAPHIC ATTENTION HANDLING          June 1971\n\n\n2.1 DEFINITION\n\n   Graphic attention handling refers to the processes and techniques\n   whereby human inputs to a computer graphic system are serviced.  An\n   attention event, or simply \"attention,\" is a stimulus to the graphic\n   system, such as that resulting from a keystroke or light pen usage,\n   which presents information to the system.  Servicing includes\n   accepting or detecting the hardware input, processing it to determine\n   its intended meaning, and either passing this information to a user\n   routine or taking some _immediate_ action related to the display\n   and/or its underlying data structure, or both.  The emphasis is on\n   \"immediate.\"  Attention-handling is not intended to include any\n   detailed, application-oriented processing which the attention\n   information may indicate is to be performed.  Thus, attention\n   handling may be considered separately from any particular\n   application.\n\n2.2 INDEPENDENT FROM DISPLAY CONSIDERATIONS\n\n   Not only may attention handling be considered separately from any\n   application, but attention generating hardware may be considered\n   separately from display hardware.  Oftentimes, it is only\n   coincidental that they come in the same package.  Indeed, in some\n   configurations an input be processed locally (by the terminal) to\n   provide the appropriate response.  For example, a keystroke may or\n   may not cause a character to be displayed on a terminal, and the\n   logic causing the display may or may not be local (within the\n   terminal).  The keystroke might be immediately displayed locally, as\n   in the case of an alphanumeric display terminal which buffers\n   keystrokes and transmits messages of many characters or it might be\n   transmitted to the host computer and \"echoed\" back for display as in\n   teletype-like terminals.\n\n   The question is not limited to such simple input devices as\n   keyboards.  So-called \"intelligent terminals\" with integrated\n   programmable logic or even complete small computers can process more\n   sophisticated attentions locally, and even alter a local distillate\n   of the central (host) data structure without central knowledge.  This\n   raises the problem of insuring that the display and the graphic\n   application program do not get \"out of sync,\" and requires a more\n   expressive protocol from terminal to host processor.\n\n\n\n\n\n\n\n\n\n\nCotton                                                          [Page 2]\n\f\nRFC 178            NETWORK GRAPHIC ATTENTION HANDLING          June 1971\n\n\n3.0 SYSTEM CONFIGURATIONS\n\n   We now turn to a consideration of the evolution of system\n   configurations for computer graphics.  Our intent is to demonstrate\n   that just as display generation has evolved from the output of device\n   dependent codes to a generalized protocol, so too should attention\n   generation evolve.\n\n3.1 STAND-ALONE CONFIGURATION\n\n   Figure 1 illustrates the stand-alone graphic configuration which was\n   the first and is still the most common.  As we have stressed, input\n   and output are entirely independent, and are shown as separate\n   devices.  In this configuration, display code generation and\n   interrupt processing are both done within the graphic application\n   program in the host processor.  The graphic application is very\n   device-dependent.\n\n3.2 STAND-ALONE CONFIGURATION WITH STANDARDIZED FORMATS\n\n   The significant conceptual change occurs when the input and output\n   processors are removed from the graphic application program.  The\n   graphic application program then generates output and accepts input\n   in a generalized form, as illustrated in Figure 2.  The important\n   fact to note is that in order to accommodate additional (different)\n   input and/or output devices, only these input/output processing\n   routines must be replaced or altered.  Graphic application programs\n   may be designed without regard to which particular processing routine\n   will be used.  So far as the application program is concerned,\n   device-independence has been achieved.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCotton                                                          [Page 3]\n\f\nRFC 178            NETWORK GRAPHIC ATTENTION HANDLING          June 1971\n\n\nFigure 1 Stand-Alone Graphic Configuration\n\n   +----------------------------+\n   |                            |                _______\n   | +---------+-----------+    |               /       \\\n   | |         |OUTPUT     |    |              /         \\\n   | |     /--\u003e|PROCESSOR  |----|------------\u003e|           |\n   | |    /    +-----------+    |              \\         /\n   | |    |                |    |               \\_______/\n   | |    |                |    |             OUTPUT DEVICE\n   | |    |    +-----------+    |              ______\n   | |    \\    |INPUT      |    |             |      \\\n   | |     \\---|PROCESSOR  |\u003c-- |-------------|_______\\\n   | +---------+-----------+    |\n   |     Graphic Application    |             INPUT DEVICE\n   |         Program            |\n   +----------------------------+\n   /SERVING\\ HOST\n   \\USING  /\n\n\nFigure 2 Stand-Alone Configuration with Standardized Input and Output\n   Formats\n\n+-------------------------------------+                        ______\n|                                     |                 /----\u003e/      \\\n|                      +-----------+  |DEVICE-DEPENDENT/  ___/___     \\\n|                    +-----------+ |--|---------------/  /       \\    |\n|        STANDARD    | OUTPUT    | |  |DISPLAY LIST     /         \\   /\n| +-----+DISPLAY LIST|PROCESSOR  |-+  |                 |         |__/\n| |  ---|-----------\u003e|           |----|----------------\u003e\\         /\n| |  |  |            +-----------+    |                  \\_______/\n| |  |  |                             |                 OUTPUT DEVICE(S)\n| |  |  |                             |\n| |  |  |              +-----------+  |DEVICE-DEPENDENT       ______\n| |  |  |  STANDARD  +-----------+ |\u003c-|----------------------|      \\\n| |  |--|\u003c-----------|INPUT      | |  |INPUT DATA         ___|___    \\\n| +-----+  ATTENTION |PROCESSOR  |-+  |                  |       \\____\\\n|                    |           |\u003c---|------------------|        \\\n|                    +-----------+    |                  |_________\\\n|    Graphic Application Program      |                  INPUT DEVICE(S)\n|                                     |\n+-------------------------------------+\n/SERVING\\ HOST\n\\USING  /\n\n\n\n\n\n\nCotton                                                          [Page 4]\n\f\nRFC 178            NETWORK GRAPHIC ATTENTION HANDLING          June 1971\n\n\n3.3 NETWORK CONFIGURATION\n\n   When the stand-alone configuration with standardized formats is\n   implemented on a network, the organization illustrated in Figure 3\n   results.  In the network configuration, the graphic application\n   program and the input and output processors may be in different\n   hosts.  The standardized formats become network standards, and now\n   any using host with input/output processors conforming to the\n   standard can access the graphic application program in the serving\n   host.  The network is transparent to the graphic configuration.\n\n3.4 NETWORK CONFIGURATION WITH INTELLIGENT TERMINAL\n\n   The case of an intelligent graphics terminal configured in the\n   network is illustrated in Figure 4.  Here, input and output\n   processors are located within the terminal itself.  The using host\n   serves only to connect the terminal to the network, and in the case\n   of a terminal IMP, is dispensed with altogether.  Any type of\n   intelligent terminal may access any graphic application program if\n   its (the terminals) input and output processing routines conform to\n   the network standard.  As before, the network is transparent to the\n   graphic configuration.\n\n   Figure 3 Network Configuration (Omitted due to complexity)\n\n   Figure 4 Network Configuration with Intelligent Terminal (Omitted due\n   to complexity)\n\n\n4.0 INPUT DEVICES\n\n   We now turn to a survey of graphic input devices as suggested in RFC\n   87.  The survey will concern itself with the characteristics of the\n   attention information presented when the device is used (rather than,\n   for example, human factors considerations).\n\n   We wish to stress at the onset that we consider all devices\n   equivalent in capability.  By this we mean that with appropriate\n   programming, any device can simulate any other device.  Throughout\n   the survey we will illustrate typical data conversions which might be\n   performed, and at times discuss how various devices may be simulated.\n\n   It is convenient to consider the characteristics of classes of\n   devices.  Information about particular commercial devices may be\n   found in reference 5 and elsewhere.  Table I presents a device class\n   summary.\n\n\n\n\n\nCotton                                                          [Page 5]\n\f\nRFC 178            NETWORK GRAPHIC ATTENTION HANDLING          June 1971\n\n\n4.1 PUSHBUTTONS\n\n   Perhaps the first and most primitive class of input devices is the\n   pushbutton, which presents some unique code to the system when\n   depressed.  In the simplest case, the code is equivalent to the\n   knowledge that the button has been pushed, and may be just a flag.\n\n   Beyond the basic pushbutton, more advanced key devices have been\n   designed in a variety of ways.  For example, each key may be\n   associated with a single bit in a word or with a complex pattern\n   (character or byte), multiple keys may or may not be able to be\n   struck simultaneously (if so, their codes being combined in some\n   defined way).\n\n   The salient feature of the function key is that it presents two\n   pieces of information to the system: the fact that a keystroke has\n   occurred (which may be implicit), and some unique code related to it.\n\n   More elaborate keyboards, be they teletypes or solid state devices\n   with elaborate \"overlays\", are merely special cases of function keys.\n   They present the same information, attention source plus a unique\n   code.  The fact that such a code may be associated with a displayable\n   character is at this stage only incidental.\n\n   Since keyboards permit the entry of arbitrary codes, particular\n   sequences of codes may easily be defined to simulate other devices.\n   If local logic permits, codes may be accumulated until a complete\n   sequence is entered and then be reformatted to exactly the same\n   format as the device being simulated would have produced.\n\n   Pointing devices such as light pens and tablets may be simulated by\n   associating particular keys with screen directions (up, down, right,\n   left) and using them to position a pointer on the screen face.  This\n   facilitated on terminals with a hardware connection between keys and\n   cursor symbol.\n\n4.2 ANALOG DEVICES\n\n   The next most basic class of input devices are those which consist of\n   analog to digital converters.  These include simple shaft encoders,\n   mouse and trackball.  These devices all produce a digital output\n   proportional to an analog input, in this case, the rotation of a\n   shaft.  Several of these inputs may be presented together, as in the\n   case of the mouse and trackball.\n\n\n\n\n\n\n\nCotton                                                          [Page 6]\n\f\nRFC 178            NETWORK GRAPHIC ATTENTION HANDLING          June 1971\n\n\n   These devices all present as input a device identification (which may\n   be implicit depending on the hardware method of input) together with\n   a number of digital codes from the same number of analog devices.\n   The length of the code is arbitrary and may or may not relate to such\n   measures as the maximum raster count of the display screen.\n\n   Analog devices are often used as pointing devices by using the input\n   to control the movement of a cursor on the screen face.  This method\n   is superior to the use of a keyboard, since very smooth and rapid\n   movement may be obtained.\n\n4.3 TABLETS\n\n   A tablet consists of a flat surface on which (X,Y) position may be\n   indicated with a stylus.  If position changes can be registered\n   rapidly enough, arbitrary curves may be digitized by tracing them.\n\n   There are a variety of devices utilizing a variety of techniques\n   comprising this class.  Included are such diverse techniques as\n   variable resistance, variable capacitance, and ultrasonics, to\n   mention a few of the devices on the market.  The surface may be\n   horizontal or vertical and may even be superimposed on the screen\n   itself.  A variety of styli have been used, including the operator's\n   finger.  A device (the Lincoln Wand) has also been demonstrated which\n   may be manipulated in space to yield a position in three dimensions\n   (X,Y,Z).\n\n   These devices all present a device identification (which may be\n   implicit), and a position value, which is most often a coordinate\n   pair, but which may be a triple.\n\n4.4 LIGHT PEN\n\n   Light pens are devices which relate the occurrence of an attention to\n   the time in the refresh cycle when a particular point is illuminated\n   on the screen.  The display generators are generally stopped when the\n   attention occurs, to permit either the display list \"P\" register or\n   the (X,Y) beam position registers, or both to be presented as\n   attention data.  Often times this is not enough, as what is desired\n   is some value which serves to identify the image which the pen\n   detected.  In such cases local hardware and/or software is utilized\n   to obtain this information, which may be as simple as a single\n   identification code or as elaborate as a genealogical push down list.\n\n\n\n\n\n\n\n\nCotton                                                          [Page 7]\n\f\nRFC 178            NETWORK GRAPHIC ATTENTION HANDLING          June 1971\n\n\n   Light pens present as input a device identification (which may be\n   implicit) and at least one of the following:  memory address, (X,Y)\n   position, item identification.\n\n   Light pens may be used to simulate keyboards by displaying \"light\n   buttons\" on the screen associated with particular physical buttons.\n   Detecting on a light button is logically equivalent to pushing the\n   related key.\n\n4.5 INTERNAL ATTENTIONS\n\n   Internal attentions are stimuli arising not from operator action, but\n   from various sources within the terminal such as a screen edge\n   violation (overflow) or a programmed trap.  Such attentions present\n   information in much the same way as the operator input devices\n   already discussed.  This information consists of an attention source\n   identification (equivalent to device identification, and which may\n   again, be implicit) and appropriate data, which, for the two examples\n   given, will generally be a memory address.\n\n   Programmed traps are often used to permit mode changes (e.g., enable\n   or disable light pen operation) during the execution of the display\n   list.  Edge violation might occur when an image is being relocated in\n   response to operator input.  We must provide for describing such\n   attentions, since then cannot always be handled locally in the\n   terminal.\n\n4.6 LOGICAL ATTENTIONS\n\n   We may generalize the concept of an attention from a stimulus from a\n   physical source to a logically generated stimulus resulting from some\n   program condition which may or may not cause an interrupt.\n   (Programmed traps were classified as internal attentions because, by\n   definition, they cause an interrupt or set a hardware flag).  Logical\n   attentions are generally \"input\" by setting a software flag which\n   some control program can periodically inspect.  For example, logical\n   attentions may be designed to detect when a software-defined edge\n   violation occurs (of a region less than full screen) or when a light\n   button is picked.  There is no general form for the information\n   generated by logical attentions, since they are programmable, rather\n   than hardware-bound.  The best we can do is to say they consist of an\n   identification and appropriate data.  Actually, logical attentions\n   most often simulate physical attentions, and so each may be placed in\n   one of the classes already described.\n\n\n\n\n\n\n\nCotton                                                          [Page 8]\n\f\nRFC 178            NETWORK GRAPHIC ATTENTION HANDLING          June 1971\n\n\n                                TABLE I\n\n                          INPUT DEVICE SUMMARY\n\nDEVICE CLASS       DEVICE EXAMPLES               TYPICAL OUTPUT\n\nButton             Teletype                      1 Character\n                   Function Key with Overlay     1 Character and\n                                                 overlay code\n                   Buffered Keyboard             n Characters\n\nA/D Converter      Shaft Encoder                 delta a\n                   Mouse                         (delta a, delta b)\nTablet             Rand Tables and               (X,Y)\n                   Lincoln Word                  (X,Y,Z)\n\nLight Pen          Light Pen                     P (memory address)\n                   Light Pen                     (X,Y)\n                   Light Pen and Local Software  Item Name\n                   Light Pen and Local Software  Item name stack\n\nInternal           Program Trap                  P (memory address)\n                   Screen Overflow               P (memory address)\n\nLogical Attention  Any of the above              Any of the above\n\n\n5.0 INTELLIGENT TERMINALS\n\n   As has been indicated, the question of what data results from which\n   inputs is complicated when \"intelligent terminals\" are considered.\n   An intelligent terminal has the ability to modify the data presented\n   by the input device hardware.  In a sense then, all of the outputs of\n   an intelligent terminal may be considered as logical attentions.  The\n   logical complexity of such attentions may be very great indeed.  For\n   example, such a terminal might be programmed to perform sketching\n   functions, so that the net effect of a keystroke and a light pen hit\n   might be the deletion of a portion of the picture together with some\n   coded message to the effect.  A technique has even been developed\n   which permits the light pen operator to simulate the use of a shaft\n   encoder by twisting his wrist which holding the pen over a tracking\n   symbol (7).\n\n   Some intelligent terminal systems have been developed which permit\n   the terminal operator to modify the picture and the local data\n   structure independently.(2)  Thus, the need for a very expressive\n   protocol from terminal to central computer becomes apparent, so that\n   notice of such local processing may be communicated to the central\n\n\n\nCotton                                                          [Page 9]\n\f\nRFC 178            NETWORK GRAPHIC ATTENTION HANDLING          June 1971\n\n\n   program.\n\n\n6.0 NETWORK PROTOCOL GUIDELINES\n\n   We now suggest a format for a (third level) network protocol from\n   terminal to serving host which is sufficiently open-ended to permit\n   any type of attention to be communicated.  It is not the intent here\n   to formally propose such a protocol down to the level of \"this bit\n   means that.\"  When such details are decided, a Network Standard\n   Attention will have been defined.\n\n   The attention protocol has three basic elements:  device\n   identification, data identification, and data.\n\n6.1 DEVICE IDENTIFICATION\n\n   The device identification field must be sufficiently large to permit\n   the unique identification of any TYPE OF DEVICE in the network.  If\n   two or more identical input devices exist at different nodes in the\n   network, it is not necessary to distinguish among them in this field.\n   However, if a keyboard, for example, has keys which are logically\n   different, such as typewriter keys and function keys, the distinction\n   should be made in the identification field, rather than requiring an\n   analysis of the data.  Further, if two different devices are\n   logically equivalent, as a physical keyboard and light buttons, they\n   may be so treated by NOT having identification codes different from\n   each other.\n\n   Somewhere in the network (and possibly at each host supporting a\n   graphic application) a table should be kept of the input device types\n   and their characteristics.  It may be convenient to organize the\n   device identification field so that a subfield identifies the device\n   CLASS, as discussed previously\n\n6.2 DATA IDENTIFICATION\n\n   The device identification field is intended to contain a description\n   of the data field which follows.  Information which might be provided\n   here includes number of units (bits, words, bytes) of data which\n   follow, qualitative description of the data (character code, memory\n   address, cartesian coordinates, item name, etc.), and data format\n   information.  It may be desirable, for the sake of uniformity, to\n   include this information even when it is somewhat redundant.\n\n\n\n\n\n\n\nCotton                                                         [Page 10]\n\f\nRFC 178            NETWORK GRAPHIC ATTENTION HANDLING          June 1971\n\n\n6.3 DATA\n\n   Lastly comes the data itself (perhaps an anticlimax at this point!)\n   which, as should be clear by now, may be of arbitrary length and\n   organization.\n\n\nBIBLIOGRAPHY\n\n      1. Cotton, I. \"Languages for Graphic Attention-Handling.\" Proc.\n      Computer Graphics 70 Symposium, Brunel University, 197.\n\n      2. Cotton, I. and F. Greatorex \"Data Structures and Techniques for\n      Remote Computer Graphics,\" Proc. FJCC, 1968, pp. 533-544.\n\n      3. Crocker, S. \"Proposal for a Network Standard Format for a Data\n      Stream to Control Graphics Display.\" ARPA Network Working Group,\n      RFC # 86, 1971.\n\n      4. Harslem, E. and J. Heafner \"Some Thoughts on Network Graphics,\"\n      ARPA Network Working Group, RFC # 94, 1971.\n\n      5. Keast, D. \"Survey of Graphic Input Devices,\" MACHINE DESIGN.\n      August 3, 1967, pp. 114-120.\n\n      6. McConnell, J. \"Response to RFC #86,\" ARPA Network Working\n      Group, RFC #125, 1971.\n\n      7. Newman, W. \"A Graphical Technique for Numerical Input,\"\n      COMPUTER J., May 1968, pp. 63-64.\n\n      8. Vezza, A. \"Topic for Discussion at the Next Network Working\n      Group Meeting.\"  ARPA Network Working Group, RFC #87, 1971.\n\n\n\n\n\n\n           [This RFC was put into machine readable form for entry]\n        [into the online RFC archives by Kelly Tardif,Viag\ufffdnie 11/99]\n\n\n\n\n\n\n\n\n\n\nCotton                                                         [Page 11]\n\f\n"
}