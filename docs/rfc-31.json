{
  "series": "Request for Comments",
  "number": "31",
  "howpublished": "RFC 31",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0031",
  "url": "https://www.rfc-editor.org/info/rfc31",
  "title": "Binary Message Forms in Computer",
  "pagetotal": "7",
  "year": "1968",
  "month": "feb",
  "body": "\n\n\n\n\n\nNetwork Working Group\nRequest for Comments: 31\n\n\n\n\n\n\n\n               BINARY MESSAGE FORMS IN COMPUTER NETWORKS\n\n\n\n                             Daniel Bobrow\n                       Bolt, Beranek, and Newman\n                        Cambridge, Massachusetts\n\n\n\n                         William R. Sutherland\n                         MIT Lincoln Laboratory\n                        Lexington, Massachusetts\n\n\n\n\n\n                             February 1968\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                                [Page 1]\n\f\nRFC 31                    Binary Message Forms             February 1968\n\n\n                   MESSAGE FORMS IN COMPUTER NETWORKS\n\nINTRODUCTION\n\n\n     Network communication between computers is becoming increasingly\n   important.  However, the variety of installations working in the area\n   probably precludes standardization of the content and form of inter-\n   computer messages.  There is some hope, however, that a standard way\n   of defining and describing message forms can be developed and used to\n   facilitate communication between computers.  Just as ALGOL serves as\n   a standard vehicle for describing numerous algorithms, and BNF serves\n   as a standard for describing language syntax, a message description\n   language would be useful as a standard vehicle for defining message\n   formats.\n     Considerable progress has been made at the low level of message\n   handling protocol and one can expect the ASCII protocols to be used.\n   The discussion which follows assumes that the mechanics of exchanging\n   messages, check sums, repeat requests, etc., have been worked out.\n   The topic of concern is how to describe the content and intent of a\n   binary message body when the network header and trailer details have\n   been stripped off.\n     Most attempts at describing the content of binary messages\n   jump immediately into a consideration of the bit codings to be used.\n   Long, thin rectangles are drawn to represent the binary bit stream;\n   this stream is sliced up into boxes, and tables generally describe\n   the bit options for each box.  A better approach would be to provide\n   a symbolic method for describing messages.  The symbolism, by\n   avoiding immediate references to specific bit details, should help\n   one's understanding of the message content and the alternatives\n   available in the message body.  When the basic form of the binary\n   message body is clear, the coding details of the actual bit fields\n   can be shown.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                                [Page 2]\n\f\nRFC 31                    Binary Message Forms             February 1968\n\n\n     Describing a binary message body is not much different from\n   describing a text body or language.  Text assumes fixed bit fields\n   each containing one character.  Standard language description methods\n   (BNF) then show how the characters can be concatenated and what\n   interpretation should be placed on character groups.  Binary message\n   descriptions require the additional capacity of defining various size\n   fields in the message and the interpretation to be placed on the bits\n   contained in the field.\n     A message description is initially intended as a reference standard\n   to be written down on paper and made available to new users of a\n   computer network.  From this standard, the new user can discover the\n   kind and form of the binary data being exchanged over the network.\n   Once this is known, the programs necessary for using the network\n   facilities can be created.  Later on, in an established network, one\n   can envision the promulgation of standards for newly developed binary\n   formats via the exchange of ASCII text messages over the network\n   itself instead of on paper through the mail.  Still farther into the\n   future, the text of a binary format standard could be used as input\n   to compiler-like programs which automatically create data translation\n   programs for converting one binary format to another.  Right now,\n   though, some kind of binary data description method, however trivial,\n   is desperately needed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                                [Page 3]\n\f\nRFC 31                    Binary Message Forms             February 1968\n\n\n               A SUGGESTED BINARY FORMAT DESCRIPTION METHOD\n\n     The basic component of a binary message is a simple field\n   consisting of a consecutive number of bits in the message.  Binary\n   messages consist of concatenated fields.  A format description for a\n   binary message will consist of a title and four declarative sections.\n\n     1) Symbolic names are declared for all the different kinds of\n        fields found in the binary format being defined.\n     2) Symbolic names are declared for commonly used values of\n        particular fields.\n     3) The legal ways of concatenating fields are indicated.\n     4) The number of bits in each field and any special considerations\n        of bit codings are declared.\n\n   The following is a complete example of a binary message description\n   for a trivial kind of pictorial data.\n\n     Title: Illustrative graphic data format for a hierarchally\n        structured picture of lines and points.\n     Simple Fields:\n        OPT   - Option Control Field\n        COORD - Numerical Coordinate Value\n        ID    - Identnumber for group of picture parts\n        COUNT - Number of units in message\n\n\n     Field Equivalents:\n        PHDR   \u003c- '2' OPT\n        LHDR   \u003c- '4' OPT\n        GRPHDR \u003c- '1' OPT\n        GRPEND \u003c- '3' OPT\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                                [Page 4]\n\f\nRFC 31                    Binary Message Forms             February 1968\n\n\n     Characterizations:\n        CPAIR   \u003c- COORD = 2\n        POINT   \u003c- PHDR + CPAIR\n        LINE    \u003c- LHDR + CPAIR = 2\n        PARTS   \u003c- POINT/LINE/PARTS + PARTS\n        PIXUNIT \u003c- GRPHDR + ID + PARTS + GRPEND\n        PIXMSG  \u003c- '5' OPT + N: COUNT + PIXUNIT = N + '0' OPT\n     Simple Field Sizes:\n        OPT   3\n        COORD 14\n        ID    9\n        COUNT 6\n\n\n\nDeclaration of Simple Fields\n\n     The declaration of a simple field includes a symbolic\n   name, and for lack of a better way, an English description of what\n   the contents of the field represent.  For example:\n     Simple Fields:\n        F1    - Geometric Options\n        EXP   - STD Number - Exponent\n        COORD - STD Number - Geometric Coordinates\n\nRepresenting Field Values\n     A field with a specific value can be represented by a number in\n   single quotes followed by the field name.  A number consists of\n   standard digits construed as binary if zeros and ones.  Other numbers\n   must be followed by a base indicator unless no confusion is possible;\n   Q is octal, D is decimal.\n\n     Example:\n     '1001' F1\n     '300D' COORD\n     '27Q'   EXP\n   Field values are integer numbers assigned such that the least\n   significant bit is sent first.  Only that part of the number which\n   fits the field is used.  Appropriate sign extension is needed for\n   negative numbers and for numbers whose bit representation is smaller\n   than the field.\n\n\n\n\n\n\n\n\n\n\n                                                                [Page 5]\n\f\nRFC 31                    Binary Message Forms             February 1968\n\n\nSimple Field Equivalents\n     The declaration of a Simple Field Equivalent provides a symbolic\n   name which represents a particular field with a specific value.\n   Example:\n     Field Equivalents:\n        C1 \u003c- '1001' F1\n        C2 \u003c- '1010' F1\n\nCharacterization Statement\n     A characterization statement defines a complex field (message or\n   message part) by indicating how other fields can be combined and is\n   similar to a definition statement in BNF.  The left side is a complex\n   field name separated (by \u003c-) from the concatenation indications on\n   the right.  Field names or equivalent names are concatenated by plus\n   (+), alternatives indicated by slash (/).  Slash has precedence over\n   plus so that A + B/C means A followed by either B or C.  Alternatives\n   must be distinguishable in their own right.\n     Characterization statement parts can be grouped in the normal\n   manner by parentheses.  (A + B)/C means either A followed by B or C.\n\nRepetition Indicators\n     Repeated occurrences of a field may be indicated by following the\n   field name with an equal sign (=) and a number.  For example:\n   CPAIR  \u003c- (COORD = 2) i.e. exactly two COORD fields\n   PPAIRS \u003c- (C1 + CPAIR = 10D) / (C2 + CPAIR = 40D)\n\nAssignments Within a Characterization Statement\n     Simple fields interpretable as integers can be assigned to a\n   variable within the right side of a characterization statement.  This\n   variable can then be used as a repetition indicator.  Example:\n\n     MS \u003c- N1: EXP + CPAIR = N1\n   indicates that MS consists of field EXP interpreted as an integer and\n   then exactly that number of CPAIRS.  All variables are global in\n   scope.\n\nConditional Fields\n     Within a characterization statement a field may or may not\n   occur depending on the contents of some other previous field.  This\n   situation is indicated by assigning a label to the determining field.\n   The conditional occurrence is then indicated by enclosing a condition\n   expression and the optional field description in brackets ([ and ]).\n   For example:\n\n\n\n\n\n\n\n\n                                                                [Page 6]\n\f\nRFC 31                    Binary Message Forms             February 1968\n\n\n     SS \u003c- V:F1 + CPAIR + [V = C1 \u003e PPAIRS]\n   which defines a format of 2 and perhaps 3 fields.\n     a) Field F1 labeled V followed by\n     b) Field CPAIR followed by\n     c) Field PPAIRS if the first field (V) was C1; otherwise, this\n   third field is not present in the message.\n\nConditional Alternatives\n     Alternatives selected by the contents of some previous field rather\n   than by the contents of the alternative field itself are indicated by\n   an extension of the conditional field notation.  For example:\n     SM := W : F1 + CPAIR + [W = C1 \u003e CPAIR / C2 \u003e PPAIRS /\n   The determining field occurs at the beginning of the conditional\n   alternative and each alternative then includes its value for the\n   determining field and the alternative field then present.\n\nSize of Simple Fields\n     A separate field size declaration is provided.\n     Simple Field Sizes:\n           F1    4\n           EXP   7\n           COORD 12\n   This size declaration should appear at the end of the\n   message description; thus, forcing the reader to postpone an early\n   consideration of bit details. xmodmap -e \"add lock = Caps_Lock\"\n\n\n         [ This RFC was put into machine readable form for entry ]\n   [ into the online RFC archives by Dave Bachmann 1/98 ]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                                [Page 7]\n\f\n"
}