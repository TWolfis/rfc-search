{
  "series": "Request for Comments",
  "number": "98",
  "howpublished": "RFC 98",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0098",
  "url": "https://www.rfc-editor.org/info/rfc98",
  "title": "Logger Protocol Proposal",
  "pagetotal": "10",
  "year": "1971",
  "month": "feb",
  "body": "\n\n\n\n\n\nNetwork Working Group\nRequest for Comments #98\nNetwork Information Center #5744\n\n                        Logger Protocol Proposal\n\n                          Edwin W. Meyer, Jr.\n                           Thomas P. Skinner\n                           February 11, 1971\n\n\n        With the ARPA Network Host-to-Host  Protocol  specified  and  at\nleast  partially  implemented at a number of sites, the question of what\nsteps should be taken next arises. There  appears  to  be  a  widespread\nfeeling  among  Network  participants  that the first step should be the\nspecification and implementation of what has  been  called  the  \"Logger\nProtocol\";  the  Computer  Network Group at project MAC agrees. The term\n\"logger\" has been commonly used to indicate the basic mechanism to  gain\naccess  (to  \"login\")  to  a  system from a console. A network logger is\nintended to specify how the existing logger of  a  network  host  is  to\ninterface to the network so as to permit a login from a console attached\nto another host.\n\n        To  implement  network  login   capability   now   seems   quite\ndesirable.In  the first place, it is natural for Network participants to\nwish to learn more about the remote systems  in  the  immediate  fashion\nafforded  by  direct  use  of  those  systems.  In the second place, the\ntechnical problems introduced by remote logins are probably less complex\nthan  those  involved  with  such  further  tasks  as  generalized  file\ntransfer; thus,  a  Logger  Protocol  could  be  implemented  relatively\nquickly,  furnishing  additional  impetus  and  encouragement for taking\nstill further steps.\n\n        In order to furnish at least a basis for discussion (and at most\nan  initial  version  of  a  Logger  Protocol),  we  have  prepared this\ndocument, which attempts to present a  minimal  set  of  conditions  for\nbasing  a  Logger  Protocol. This proposal covers only the mechanism for\naccomplishing login. What occurs following login is not discussed  here,\nbecause  we  feel  more experimentation is necessary before any protocol\nfor general console communication can be established as standard. In its\nabsence,  each  site  should  specify its own experimental standards for\nconsole communications following login.\n\n\n        Some of the points raised in this document have already  reached\na  certain  level of consensus among network participants while at least\none point is rather new. It should be clearly understood, however,  that\nwe  feel  regardless  of  the disposal of particular issues, Networkwide\n\n\n\n                                                                [Page 1]\n\f\nRFC 98                  Logger Protcol Proposal                 Feb 1971\n\n\nagreement should  be  reached  as  soon  as  possible  on  some  general\nprotocol.  This is all the more desirable in view of the fact that it is\nquite likely that  certain  points  which  should  be  covered  in  this\nprotocol  will only become apparent during the course of implementation;\ntherefore, the sooner a common basis for implementation can be  reached,\nthe sooner a more rigorous protocol can be enunciated.\n\n        Before turning to 1) a discussion of the points  with  which  to\ndecide  the  protocol should deal, and 2) specifications for the current\nstate  of  the  protocolm  we  feel  that  we  should  acknowledge   the\nconsideration  that  a  case could be made for avoidingthe difficulty of\ngenerating a Logger Protocol by simply  declaring  that  each  host  may\nspecify  its  own, perhaps unique, preferences for being approached over\nthe Network. Although such a course is certainly possible, it  does  not\nseem  to  us  to  be desirable. One reason for avoiding such a course is\nsimply that following  it  hamper  general  Network  progress,  in  that\nadressing  the task of interfacing with some 20 systems is bound to more\ntime-consuming than to interface with \"one\"  system,  even  though  each\nindivudual one of the former, multiple interfaces might be in some sense\nsimpler than the latter, single interface. Another consideration is less\npragmatic,  but  nonetheless  important:  agreement on a common protocol\nwould tend to foster a sense of Network \"community\", which would tend to\nbe  fragmented  by  the  local option route. After all, the Host-to-Host\nProtocol could have been handled on a per-host basis as well; assumedly,\none  reason  why it has not had something to do with similar, admittedly\nabstract considerations.\n\nContext\n\n   Structurally, the mechanism serving to login a user over the  Network\nconsists  of  two  parts,  one  part at the using host, the other at the\nserving host. The using or local host is the  one  to  which  the  users\ntypewriter is directly connected; it contains a modulewhich channels and\ntransforms  communications  between  the  Network  connection  and   the\ntypewriter. The serving or foreign host provides the service to be used;\nit contains programming that adapts the logger and command system to use\nthrough the Network rather than a local typewriter.\n\n      There are three different phases to a login through the network.\n\n      1. During the connection phase the users console is connected to\n         the serving logger through the network. This is, of course,\n         the most important phase from the protocol viewpoint.\n\n      2. The second or dialog phase consists of a sequence of exchange\n         between the user and the logger that serves to identify the\n         user and verify his right to use the system. In some hosts,\n         this phase may be minimal or non-existent.\n\n\n\n                                                                [Page 2]\n\f\nRFC 98                  Logger Protcol Proposal                 Feb 1971\n\n\n      3. The admission phase occurs after the user has successfully\n         completed the login dialog. It consists of switching his\n         network typewriter connections from the logger to an entity\n         providing a command processor of some sort. In some hosts\n         this switching may be totally conceptual; in others there\n         may be a real internal switching between entities.\n\n\nThe Connection Phase\n\n        The issues involved in specifying a  protocol  for  implementing\nlogin  can  be  separatedintop  two  major  parts:  how to establish and\nmaintain the network connection between the typewriter and  the  logger,\nand how to conduct a dialog after the connection is made. The first part\nis called the Initial Connection Protocol by Harlem and Heafner  in  RFC\n80.  It  in turn consists of two subparts: how to establish a connection\nand how and when to destroy it.\n\n        We endorse the proposal for establishing a  connection  made  in\nRFC  80,  which  we  summarize briefly for convenience. It is a two-step\nprocess utilizing the  NCP  control  messages  to  effect  a  connection\nbetween  the logger and the console of a potential user. First, the user\ncauses the hosts NCP to send out  a  \"request  for  connection\"  control\nmessage  destined  for the serving hosts loggers contact socket. The two\npurposes of this message are to indicate to the logger  that  this  user\nwishes  to initiate a login dialog and to communicate the identifiers of\nthe and send socket he wishes to operate for this  purpose.  The  logger\nrejects  this request to free its contact socket. As the second step the\nlogger choses  two  sockets  to  connect  to  the  user's  sockets,  and\ndispatches  connection  requests  for  these.  If  the  user accepts the\nconnection within a reasonable period, the connection phase is over, and\nthe  dialog  phase can begin. If the user does not respond, the requests\nare aborted and the logger abandons this login attempt.\n\n        There is another part to an NCP: when  and  how  to  disconnect.\nThere  are  two  basic  situations  when a logger should disconnect. The\nfirst situation may arise of the serving host's volition. The logger may\ndecide  to abandon a login attempt or a logged-in user may decide to log\nout. The second situation may be due to the  using  host's  volition  or\nnetwork  difficulties.  This  situation  occurs  when  the  serving host\nreceives a \"close connection\" control message  or  one  of  the  network\nerror  messages signifying that further transmission is impossible. This\nmay  happen  for  either  the  \"read\"   or   the   \"write\"   connection,\nDisconnecting  involves both the deletion of the network connections and\nthe stoppage of any activity at the serving host related to  that  user.\nIf  the  login  is  in  progress, it should be abandoned. If the user is\nalready logged in, his process should be stopped, since he no longer has\ncontrol over what it is doing. This is not intended to restrict absentee\n\n\n\n                                                                [Page 3]\n\f\nRFC 98                  Logger Protcol Proposal                 Feb 1971\n\n\n(i.e. consoleless) jobs.\n\nThe Dialog Phase\n\n        The second major part other than getting  connected  is  how  to\nconduct  the  login dialog. This resolves itself into two parts: what to\nsay and in what form to say it. The login dialog generally consist of  a\nsequence  of  exchanges,  a  prompting  by the logger followed by a user\nreply specifying a name, a project, or password. However,  exactly  what\ninformation  is  desired in what sequence is idiosyncratic to each host.\nRather than attempt to specify a standard sequence for this  dialog,  we\nhave  taken the approach that each host may specify its own sequence, so\nlong as it is  expressible  as  an  exchange  of  messages  in  a  basic\ntransmission  format.  A  message is a set of information transmitted by\none of the parties that is sufficient for the other  party  to  reply.By\nhost  specification, either the logger or the user sends sends the first\nmessage of the dialog. After that, messages are  exchanged  sequentially\nuntil the dialog is completed. In this context \"message\" has no relation\nto \"IMP message\".\n\n        The other issue involved in the login dialog is the  format  for\ntransmitting  a message. We propose that it be transmitted as a sequence\nof ASCII characters (see Specificarions) in groupings calle  transaction\nblocks.\n\n   1. Character Set, We feel that there should be a standard\n      character set for logging-in. The alternative, requiring a\n      using host to maintain different transformation between its set\n      and of each serving host, is a burden that can only narrow the\n      scope of interhost usage, The character set proposed, ASCII is\n      widely used standard. Each host must define a transformation\n      sufficient to transform an arbitrary character sequence in the\n      host's code into ASCII and back again, without any ambiguity,\n      The definition of ASCII sequences to express characters not\n      contained in ASCII is appropriate.\n\n   2. Transaction Blocks. A message is transmitted as an arbitrary\n      integral number of transaction blocks. A transaction block\n      consists basically of a string of ASCII characters preceeded\n      by a character count. (It also contains a code field. See\n      below.) The count is included as an aid to efficiently\n      assembling a message. Some systems do not scan each character\n      as it is input from the console. Rather, such systems have\n      hardware IO controllers that place input characters into a\n      main memory buffer and interrupt the central processor only\n      when it receives an \"action\" character (such as \"newline\").\n      This reduces the load on the central processor. Because such\n      a hardware facility is not available for interpreting\n\n\n\n                                                                [Page 4]\n\f\nRFC 98                  Logger Protcol Proposal                 Feb 1971\n\n\n      network messages this scheme is proposed as a substitute. It\n      helps in two ways. First, a system need take no action until\n      it receives all characters specified in the count. Second, it\n      need not scan each character to find the end of the message.\n      The message ends at the end of the of a transaction block.\n\nOther Issues\n\n        There are several other issues involved in the  area  of  remote\nlogins   which  we  feel  should  be  raised,  although  most  need  not\nnecessarily have firm agreements reached for an intial protocal.\n\n1.  \"Echoplex\". Echoplex is a mode of typewriter operation in which\n    all typed material is directed by the computer. A key struck by\n    a user does not print directly. Rather the code is sent to the\n    computer, which \"echoes\" it back to be printed on the typewriter.\n    To reduce complexity, there is to be no option for network\n    echoplexing (for the login only). A using system having its\n    typewriters operating in echoplex mode must generate a local\n    echo to its typewriters. However, a serving system operating\n    echoplexed should suppress the echo of the input during the login\n    phase.\n\n2.  Correction of Mistakes. During the login dialog the user may make\n    a typing mistake. There is no mistake correction ecplicitly\n    proposed here. If the message in error has not yet been\n    transmitted, the user can utilize the input editing conventions\n    of either the using or the serving host. In the first case, the\n    message is corrected before transmission; in the second, it is\n    corrected at the serving host. If the user has made an\n    uncorrectlable mistake, he should abort the login and try again.\n    To abort, he instructs the local (using) host to \"close\" one of\n    the connections. The connections are disconnected as specified in\n    the Initial Connection Protocol.\n\n3.  \"Waiting\". It may happen that the user may get into a login dialog\n    but for some reason does not complete it. The logger is left\n    waiting for a response by the user. The logger should not wait\n    indefinitely but after a reasonable interval (perhaps a minute)\n    abort the login and \"close\" the connections according to the\n    provisions of the Initial Connection Protocol.\n\n4.  Socket Assignments. The Initial Connection Protocol does not\n    specify the ownership of the sockets to be used by the logger in\n    connecting to the user. (The use code field of the socket\n    identifier determines ownership.) The sockets may belong to the\n    logger or may have an arbitraryuser code not used by another\n    process currently existing at the serving host. Under this initial\n\n\n\n                                                                [Page 5]\n\f\nRFC 98                  Logger Protcol Proposal                 Feb 1971\n\n\n    scheme, it is not possible to implement administratively assigned\n    user codes, because the logger must assign permanent sockets\n    before the identity of the user is verified. A future connection\n    protocol can avoid this problem by implementing a socket\n    connection as a part of the admission phase. The logger would talk\n    to the user over the logger's sockets. Following identification it\n    would transfer the connections to the sockets belonging to the\n    user.\n\n5.  General Console Communications. A companion paper under\n    preparation outlines a protocol for general console communcations\n    between hosts. This paper will seek to adress most of the\n    problems associated with typewriter like communications. This\n    includes discussion of full and half duplex, character escapes,\n    action characters and other pertinent topics. Such a protocol\n    might not be suitable for all terminals and host systems but\n    would include solutions to problems for many. It is not\n    intended as a monolithic standard, but rather as a recommendation\n    for those sites who wish to implement a common protocol. The\n    important point is that we feel quite a bit of actual network\n    usage is required before all the problems are better understood.\n    This is a prerequisite for devising a standard.\n\n\n                             SPECIFICATIONS\n\nInitial Connection Protocol - Connection Phase\n\n      The following sequence is as presented in RFC 80. It  is  restated\n      here for completeness.\n\n1.  To intiate contact , the using process requests a connection of\n    his receive socket (US) to a socket (SERV) in the serving host.\n    By convention, this socket has the 24-bit user number field set\n    to zero. The 8-bit tag or AEN field is set to one indicating\n    the socket gender to be that of a sending socket. There is no\n    restriction on the choice of the socket US other than it be of\n    of the proper gender; in this case a receive socket. As a result\n    the using NCP sends:\n\n                            User -\u003e Server\n\n                   8        32          32         8\n                +-----+------------+------------+-----+\n                | RTS |     US     |   SERV     |  P  |\n                +-----+------------+------------+-----+\n\n\n\n\n\n                                                                [Page 6]\n\f\nRFC 98                  Logger Protcol Proposal                 Feb 1971\n\n\n    over the control link one, where P is the receive link assigned\n    by the user's NCP.\n\n2.  The serving host now has the option of accepting the request for\n    connection or closing the the connection.\n\n    a.  If he sends a close it is understood by the user that the\n        foreign host is unable to satisfy a request for service at\n        this time. The serving host's NCP would send:\n\n                          Server -\u003e User\n\n                   8        32          32\n                +-----+-----------+------------+\n                | CLS |    SERV   |     US     |\n                +-----+-----------+------------+\n\n        with the user's NCP sending the echoing close:\n\n                          User -\u003e Server\n\n                   8        32          32\n                +-----+-----------+------------+\n                | CLS |     US    |    SERV    |\n                +-----+-----------+------------+\n\n    b.  If the serving host is willing to provide service it will\n        accept the connection and immediately close the connection.\n        This results in the the serving host's NCP sending:\n\n                          Server -\u003e User\n\n                   8        32          32\n                +-----+-----------+------------+\n                | STR |    SERV   |     US     |\n                +-----+-----------+------------+\n\n                   8        32          32\n                +-----+-----------+------------+\n                | CLS |    SERV   |     US     |\n                +-----+-----------+------------+\n\n\n\n\n\n\n\n\n\n\n                                                                [Page 7]\n\f\nRFC 98                  Logger Protcol Proposal                 Feb 1971\n\n\n        with the user's NCP sending the echoing close. It sends:\n\n                          User -\u003e Server\n\n                   8        32          32\n                +-----+-----------+------------+\n                | CLS |     US    |    SERV    |\n                +-----+-----------+------------+\n\n        It should be mentioned that the echoing closes are required\n        by the host-to-host protocol and not by the logger initial\n        connection protocol.\n\nCharacter Set\n\n        The character  set  used  in  conducting  the  login  dialog  is\nstandard  ASCII  as  documented  in \"American National Standard Code for\nInformation Interchange\", ANS X3,  4-1968,  American  National  Standard\nInstitute, October, 1968. A logger at a serving host may demand any kind\nof input that can be  expressed  as  a  string  of  one  or  more  ASCII\ncharacters. It similarly, it may output any such string.\n\n        All ASCII characters  are  legal,  including  the  graphics  and\ncontrol  characters.  However, it is proposed that the only standard way\nof indicating the end of a console  line  be  the  line  feed  character\n(012).  This  is  in  accordance with an anticipated change to the ASCII\nstandard.\n\n       Currently the ASCII standard permits  two  methods  of  ending  a\nline.  One  method  defines  a  single  character,  line  feed (012), as\nincorporating the combined functions of line space and  carriage  return\nto  the  lefthand  margin.  The  second  method, implicitly permitted by\nASCII, uses the two character sequence  line  feed  (012)  and  carriage\nreturn (015) to perform the same function.\n\n        There is a proposal  that  the  ASCII  standard  be  changed  to\ninclude  a  return  to  the  left-hand  margin  in  all  vertical motion\ncharacters of at least one full space (line feed, vertical tab  and  new\npage). This will disallow the dual character sequence to end a line.\n\n        It is suggested that a character in a hostst character  set  not\nhaving  any  ASCII  equivalnet be represented by the ASCII two character\nsequence ESC (033) and one of the ASCII  characters.  Each  host  should\npublish a list of the escape sequence it has defined.\n\n\n\n\n\n\n\n                                                                [Page 8]\n\f\nRFC 98                  Logger Protcol Proposal                 Feb 1971\n\n\nTransaction Block Format\n\n        All textual messages exchanged between user and  logger  are  to\nconsist of one or more \"transaction blocks\". Each transaction block is a\nsequence of 8-bit elements in the following format:\n\n                \u003ccode\u003e \u003ccount\u003e \u003cchar1\u003e ... \u003ccharn\u003e\n\n\u003ccode\u003e     is an 8-bit element that is not interpreted in this\n           protocol. In the proposed general console communications\n           protocol, this field specifies communication modes or\n           special characteristics of this transaction block. Here\n           \u003ccode\u003e is to be zero.\n\n\u003ccount\u003e    is an 8-bit element that specifies the number of character\n           elements that follow in this transaction block. It is\n           interpreted as a binary integer which has a permissible\n           range between 0 and 127. The most significant bit is zero.\n\n\u003cchari\u003e    is an 8-bit element containing a standard 7-bit ASCII\n           character right-adjusted. The most significant bit is\n           zero. The number of \u003cchari\u003e in the transaction block is\n           governed by the \u003ccount\u003e field. A maximum of 127 and\n           minimum of zero characters are permitted in a single\n           transaction block.\n\n        The most significant bit of each  of  these  elements  is  zero,\neffectively   limiting   each   of  these  elements  to  seven  bits  of\nsignificance. The reason for doing this is twofold: the  eighth  bit  of\nthe  \u003cchari\u003e elements is specifically reserved for future expansion, and\nit was desired to limit  all  the  elements  so  as  to  permit  certain\nimplementations  to  convert  the incoming stream from 8-bit elements to\n7-bit elements prior to decoding.\n\n        With one exception, there  is  to  be  no  semantic  connotation\nattached  with  the  division  of a logger-user message into one or more\ntransaction blocks. The character string comprising the  message  to  be\ntransmitted  may  be  divided and apportioned among multiple transaction\nblocks according to the whim of the  sending  host.  If  less  than  128\ncharacters  in  length,  the message may be sent as a single transaction\nblock. The exception is that separate messages may  not  appear  in  the\nsame  transaction  block. That is, a message must start at the beginning\nof a transaction block and finish at the end  of  one.  Note  also  that\nthere  is  no syntactic device for specifying the last transaction block\nof a message. It  is  presumed  that  the  logger  end  user  both  have\nsufficient  knowledge  of  the  format to know when all of a message has\narrived\n\n\n\n\n                                                                [Page 9]\n\f\nRFC 98                  Logger Protcol Proposal                 Feb 1971\n\n\n        Note that the first 8-bits of data transmitted through  a  newly\nestablished  connection  must  be  a  type code as specified in Protocol\nDocument 1. This type code must be sent prior to the  first  transaction\nblock and should be discarded by the receiving host.\n\n\nAcknowledgments\n\n        Robert Bressler,  Allen  Brown,  Robert  Metcalfe,  and  Michael\nPadlipsky  contributed  directly  to  the  establishment  of  the  ideas\npresented  here.  Thanks  are  due  Michael  Padlipsky  and  others  for\neditorial comments.\n\n\n       [ This RFC was put into machine readable form for entry ]\n          [ into the online RFC archives by Carl Moberg 1/98 ]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                               [Page 10]\n\f\n"
}