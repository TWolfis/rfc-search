{
  "series": "Request for Comments",
  "number": "39",
  "howpublished": "RFC 39",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0039",
  "url": "https://www.rfc-editor.org/info/rfc39",
  "title": "Comments on Protocol Re: NWG/RFC \\#36",
  "pagetotal": "3",
  "year": "1970",
  "month": "mar",
  "body": "\n\n\n\n\n\nNetwork Working Group                                         E. Harslem\nRequest for Comments: 39                                      J. Heafner\n                                                                    RAND\n                                                           25 March 1970\n\n\n                  COMMENTS ON PROTOCOL RE: NWG/RFC #36\n\n   We offer the following suggestions to be considered as additions to\n   the April 28th 1970 protocol grammar specifications.\n\n   ERROR MESSAGES\n\n        \u003cERR\u003e \u003cCode\u003e \u003cCommand in error\u003e\n\n   It is desirable to include debugging aids in the initial protocol for\n   checking out Network Control Programs, etc.\n\n   There are three classes of errors--content errors, status errors, and\n   resource allocation or exhaustion. \u003cCode\u003e specifies the class and the\n   offending member of the class.  The command is returned to the\n   sending NCP for identification and analysis.\n\n   Examples of status errors are: messages sent over blocked links and\n   attempts to unblock an unblocked link.  Examples of content errors\n   are: an invalid RFC complete; a message sent on a link not connected;\n   closing of an unconnected link; and an attempt to unblock an\n   unconnected link.  Examples of resource errors are:  a request for a\n   non-existent program and connection table overflow, etc.  Resource\n   errors should be followed by a \u003cCLS\u003e in response to the \u003cRFC\u003e.\n\n   QUERIES\n\n        \u003cQRY\u003e \u003cMy   Socket\u003e  \u003c \u003e\n\n   or   \u003cQRY\u003e \u003cYour Socket\u003e  \u003cText\u003e\n\n   Queries provide an extension to the \u003cERR\u003e facility as well as limited\n   error recovery, thus avoiding re-initialization of an NCP.\n\n   The first command requests the remote NCP to supply the status of all\n   connections to the user specified by the user number in \u003cMy socket\u003e.\n   The second is the reply; \u003cText\u003e contains the connection status\n   information.  If an NCP wants the status of all connections to a\n   remote HOST, the \u003cMy Socket\u003e is zero.\n\n\n\n\n\n\nHarlsem \u0026 Heafner                                               [Page 1]\n\f\nRFC 39            COMMENTS ON PROTOCOL RE: NWG/RFC #36        March 1970\n\n\n   PROGRAM TERMINATION NOTIFICATION\n\n        \u003cTER\u003e \u003cMy Socket\u003e\n\n   This command supplements rather than replaces \u003cCLS\u003e.  It severs all\n   communication between a program and those programs in a given HOST to\n   which it is connected.  This command performs what would otherwise be\n   handled by multiple \u003cCLS\u003e commands. \u003cMy Socket\u003e contains the sender's\n   user number.\n\n   HOST STATUS\n\n        \u003cHCU\u003e\n        \u003cHGD\u003e\n\n   These messages (HOST coming up and HOST voluntarily going down) are\n   compatible with asynchronous, interrupt-driven programs, as opposed\n   to the more conventional post/poll method.\n\n   TRANSMIT AND BROADCAST\n\n        \u003cTRN\u003e \u003cBody\u003e\n        \u003cBDC\u003e \u003cBody\u003e\n\n   Unlike the previous commands, these are not sent over the control\n   link, but rather over links assigned to user programs.  The prefix of\n   \u003cTRN\u003e or \u003cBDC\u003e indicates, to the receiving NCP, the disposition of\n   the message body. \u003cTRN\u003e indicates a message to be passed to a single\n   process. \u003cBDC\u003e specifies to the destination NCP that the message is\n   to be distributed over all receiving connections linked to the\n   sender.  In response to a system call by the user to an NCP\n   requesting \u003cBDC\u003e, the NCP generates one \u003cBDC\u003e to each HOST to which\n   the sender is connected.\n\n   RFC AND DYNAMIC RECONNECTION\n\n   This protocol is complex; it proliferates control messages; it causes\n   queues (to become associated with re-entrant procedures) that are\n   artificially imposed via the protocol (remote AEN assignment); and\n   discounts the situation where only controlling process \"A\" has\n   knowledge that slave process \"B\" should be \"rung out\" in a dynamic\n   reconnection.\n\n   The \u003cERR\u003e, etc., are suggestions for inclusion as additions in the\n   April 28th protocol specifications.  The above criticism is, of\n   course, not intended to affect modification of the RFC structure by\n   April 28th, nor to reflect on those who planned it.  We have not\n   studied the problem.  It is meant, however, to voice our concern\n\n\n\nHarlsem \u0026 Heafner                                               [Page 2]\n\f\nRFC 39            COMMENTS ON PROTOCOL RE: NWG/RFC #36        March 1970\n\n\n   about complexity and resulting response times.  This is a difficult\n   problem and it deserves more study after we have exercised the\n   current RFC specifications.  We hope to offer constructive\n   suggestions with respect to the RFC in the future.\n\n\n\n   JFH:hs\n\n\n         [ This RFC was put into machine readable form for entry ]\n          [ into the online RFC archives by Mario Vitale 08/99 ]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHarlsem \u0026 Heafner                                               [Page 3]\n\f\n"
}