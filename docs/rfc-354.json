{
  "series": "Request for Comments",
  "number": "354",
  "howpublished": "RFC 354",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0354",
  "url": "https://www.rfc-editor.org/info/rfc354",
  "title": "File Transfer Protocol",
  "pagetotal": "25",
  "year": "1972",
  "month": "jul",
  "body": "\n\n\n\n\n\nNetwork Working Group                                     Abhay Bhushan\nRequest for Comments: 354                                       MIT-MAC\nNIC: 10596                                                 July 8, 1972\nCategories D.4, D.5, D.7\nObsoletes: RFC 264 and 265\n\n\n                       THE FILE TRANSFER PROTOCOL\n\n\nI. INTRODUCTION\n\n    The File Transfer Protocol (FTP) is a protocol for file\ntransfer betweet HOSTs (including terminal IMPs), on the ARPA\nComputer Network (ARPANET). The primary function of FTP is to\ntransfer files efficiently and reliably among HOSTs and to allow\nthe convenient use of remote file storage capabilities.\n\n    The objectives of FTP are 1) to promote sharing of files\n(computer programs and/or data), 2) fo encourage indirect or\nimplicit (via programs) use of remote computers, 3) to shield a\nuser from variations in file storage systems among HOSTs, and\n4) to transfer data reliably and efficiently. FTP, though usable\ndirectly by user at a terminal, is designed mainly for use by\nprograms.\n\n    The attempt in this specification is to satisfy the diverse\nneeds of users of maxi-HOSTs, mini-HOSTs, TIPs, and the\nDatacomputer, with a simple, elegant, and easily implemented\nprotocol design.\n\n    This paper assumes knowledge of the following protocols:\n\n         1) The HOST-HOST Protocol (NIC #8246)\n\n         2) The initial Connection Protocol (NIC #7101)\n\n         3) The TELNET Protocol (NWG/RFC #318, NIC #9348)\n\nII. DISCUSSION\n\n    In this section, the terminology and the FTP model are\ndiscussed. The terms defined in this section are only those that\nhave special significance in FTP.\n\n\n\n\n\n\n\n                                                                [Page 1]\n\f\nThe File Transfer Protocol                                  July 8, 1972\n\n\n11.A. Terminology\n\nASCII               The USASCII character set as defined in NIC\n                    #7104. In FTP, ASCII characters are defined\n                    to be the lower half of an eight bit code set\n                    (i.e., the most significant bit es zero).\n\naccess controls     Access controls define users' access\n                    privileges to the use of a system, and to the\n                    files in that system. Access controls are\n                    necessary to prevent unauthorized or\n                    accidental use of files. It is the\n                    prerogative of a user-FTP process to provide\n                    access controls.\n\nbyte size           The byte size specified for the transfer of\n                    data. The data connection is opened with\n                    this byte size. Data connection byte size is\n                    not necessarily the byte size in which data\n                    is to be stored in a system, and may not be\n                    related to the structure of data.\n\ndata connection     A simplex connection over which data is\n                    transferred, in a specified byte size, mode\n                    and type. The data transferred may be a part\n                    of a file, an entire file or a number of\n                    files. The data connection may be in either\n                    direction (server-to-user or user-to server).\n\ndata socket         The socket on which a User-FTP process\n                    \"listens\" for a data connection.\n\nEOF                 The end-of-file conidition that defines the\n                    end of a file being transferred.\n\nEOR                 The end-of-record condition that defines the\n                    end of a record being transferred.\n\nerror recovery      A procedure that allows a user to recover\n                    form certain errors such as failure of either\n                    Host system or transfer process In FTP,\n                    error recovery may involve restarting a file\n                    transfer at a given checkpoint\n\nFTP commands        A set of commands that comprise the control\n                    information flowing from the user-FTP to the\n                    server-FTP process.\n\n\n\n\n                                                                [Page 2]\n\f\nThe File Transfer Protocol                                  July 8, 1972\n\n\nfile                An ordered set of computer data (including\n                    programs) of arbitrary length uniquely\n                    identified by a pathname.\n\nmode                The mode in which data is to be transferred\n                    via the data connection. The mode defines\n                    the data format including EOR and EOF. The\n                    transfer modes defined in FTP are described\n                    in Section III.A.\n\nNVT                 The Network Virtual Terminal as defined in\n                    the ARPANET TELNET Protocol.\n\nNVFS                The Network Virtual File System. A concept\n                    which defines a standard network file system\n                    with standard commands and pathname\n                    conventions. FTP only partially embraces the\n                    NFS concept at this time.\n\npathname            Pathname is defined to be the character\n                    string which must be input to a file system\n                    by a user in order to identify a file.\n                    Pathname normally contains device and/or\n                    directory names, and file name specification.\n                    FTP does not yet specify a standard pathname\n                    convention. Each user must follow the file\n                    naming conventions of hte file systems he\n                    wishes to use.\n\nrecord              A sequential file may be structured as a\n                    number of contiguous parts called records.\n                    Record structures are supported by FTP but\n                    are not mandatory.\n\nreply               A reply is an acknowledgment (positive or\n                    negative) sent from server to user via the\n                    telnet connections in response to FTP\n                    commands. The general form of a reply is a\n                    completion code (including error codes)\n                    followed by an ASCII text string. The codes\n                    are for use by programs and the text is for\n                    human users.\n\nserver-FTP process  A process or set of processes which perform\n                    the function of file transfer in cooperation\n                    with a user-FTP process. The server-FTP\n                    process must interpret and respond to user\n                    commands and initiate the data connection.\n\n\n\n                                                                [Page 3]\n\f\nThe File Transfer Protocol                                  July 8, 1972\n\n\nserver site         A HOST site wich has a server-FTP process.\n\nserver-TELNET       A TELNET process which listens on a specified\n                    socket for an ICP initiated by a user-TELNET,\n                    and perform in accordance with the ARPANET\n                    TELNET Protocol.\n\nTELNET connections  The full-duplex communication path between a\n                    user-TELNET and a server-TELNET. The TELNET\n                    connections are established via the standard\n                    ARPANET initial Connection Protocol (ICP).\n\ntype                The data representation type used for data\n                    transfer and storage. Type implies certain\n                    transformations between the time of data\n                    storage and data transfer. The\n                    representation types defined in FTP are\n                    described in Section III.B.\n\nuser                A process on behalf of a human being or a\n                    human being wishing to obtain file transfer\n                    service.\n\nuser site           A HOST site satisfying any of the following\n                    conditions: 1) The site where a user is\n                    located, 2) a site where a user-FTP process\n                    is located, 3) a site to which a data\n                    connection is made by a server. In the\n                    normal case, the sites defined by 1, 2, and 3\n                    are the same site, but nothing in FTP\n                    requires that this be so.\n\nuser-FTP process    A process or set of precesses which perform\n                    the function of file transfer in cooperation\n                    with a server-FTP process. The user-FTP\n                    process 1) initiates the ICP (via a\n                    user-TELNET, 2) initiates FTP commands and\n                    3) \"listens\" on the data socket for the data\n                    connection. In some obvious cases (use from\n                    TIPs and other mini-HOSTs) a user-FTP process\n                    will be subsumed under the term \"user\".\n\nuser-TELNET         A TELNET process which initiates an ICP to a\n                    specified server-TELNET socket, and performs\n                    in accordance with the ARPANET TELNET\n                    protocol.\n\n\n\n\n\n                                                                [Page 4]\n\f\nThe File Transfer Protocol                                  July 8, 1972\n\n\nII.B. The FTP Model\n\n    With the above definitions in mind, the following model\n(shown in Figure 1) may be diagrammed for an FTP service.\n\n\n                            TELNET\n                          connections\nFile      Server    Server\u003c------------ User     User      File\nSystems\u003c-\u003e  FTP  \u003c-\u003eTELNET FTP Commands TELNET\u003c-\u003eFTP    \u003c-\u003eSystem\n          Process         ------------\u003e          Process\n\n                                                  Data\n                 \u003c------------------------------\u003eSocket\n                        Data Connection(s)         |\n                                                   |\n                                                  USER\n\n\n\n\nNotes:  1. The data connection may be in either direction.\n\n        2. The data connection need not exist all of the time.\n\n        3. The distinctions between user-FTP and user-TELNET,\n           and between server-FTP and server-TELNET may not\n           be as clear-cut as shown above. For example, a user-\n           TELNET may be directly driven by the user.\n\n\n\n                FIGURE 1 Model for FTP Use\n\n\n    In the model described in Figure 1, the user-TELNET\ninitiates the TELNET connection. Standard FTP commands are then\ngenerated by the user and transmitted to the server site via the TELNET\nconnections. FTP commands are in ASCII, in accordance with NVT\nconventions and the TELNET protocol. Note that commands may be initiated\nby the user directly through the user-TELNET or via a user-FTP process.\nStandard replies are sent from the server to the user in response to the\ncommands over the TELNET connections.\n\n    The FTP commands specify the parameters for teh data\nconnection (data socket, byte size, transfer mode, and representation\ntype), and the nature of file system operation (store, retrieve, append,\ndelete, etc.). The user-FTP process or its designate should \"listen\" on\n\n\n\n                                                                [Page 5]\n\f\nThe File Transfer Protocol                                  July 8, 1972\n\n\nthe specified data socket, and it is the server's responsibility to\ninitiate the data connection and data transfer in accordance with the\nspecified data connection parameters. It should be noted that the data\nsocket need not be in the same HOST that initiates the FTP commands via\nthe TELNET connection, but the user or his user-FTP process must ensure\na \"listen\" on the specified data socket. A practical example of such\nfile transfer to third HOSTs is a maxi-HOST user (who may actually be a\nTIP user) whishing to transmit a file to or from an I/O device attached\nto a TIP. It should also be noted that two data connections, one for\nsend and the other for receive, may exist simultaneously.\n\n    The protocol requires that the TELNET connections be open\nwhile data transfer is in progress. It is the responsibility of the user\nto close the TELNET connections when finished using the FTP service. The\nserver may abort data transfer if the TELNET connections are closed.\n\nIII. DATA TRANSFER FUNCTIONS\n\n    Data and files are transferred only via the data connection.\nThe data transfer of data is governed by FTP data transfer commands\nreceived on the TELNET connections. The data transfer functions include\nestablishing the data connection to the specified data socket in the\nspecified HOST (using the specified byte size), transmitting and\nreceiving data in the specified representation type and transfer mode,\nhandling EOR and EOF conditions and error recovery (where applicable).\n\nIII.A Establishing Data Connection\n\n    The user site shall \"listen\" on the specified data socket.\nThe FTP request command determines the direction of data transfer, and\nthe socket number (odd or even) which is to be used in establishing the\ndata connection. The server on receiving the appropriate store or\nretrieve request shall initiate the data connection to the specified\nuser data socket in the specified byte size (default byte size is 8\nbits) and send a reply indicating that file transfer may proceed. Prior\nto this the server should send a reply indicating the server socket for\nthe data connection. The user may use this server socket information to\nensure the security of his data transfer. The server may send this reply\neither before of after initiating the data connection.\n\n    The byte size for the data connection is specified by the\nTYPE (ASCII is 8 bits), or TYPE and BYTE commands. It is not required by\nthe protocol that servers accept all possible byte size. The user of\nvarious byte size is for efficiency in data transfer and servers may\nimplement only those byte size for which their data transfer is\nefficient. It is however recommended that servers implement at least the\nbyte size of 8 bits.\n\n\n\n\n                                                                [Page 6]\n\f\nThe File Transfer Protocol                                  July 8, 1972\n\n\n    After the data transfer is completed, it is the server's\nresponsibility to close the data connection except when the user is\nsender of data. The data connection shall be closed under any of the\nfollowing conditions:\n\n    1) server receives an abort command form user.\n\n    2) EOF in stream mode indicated by closing data connection.\n\n    3) the socket or byte size specification is changed.\n\n    4) any of the TELNET connections are closed.\n\n    5) an irrecoverable error condition.\n\n    It should be noted that two simultaneous data connections\n(for send and receive) may exist. It is a server option, however, to\nclose the data connection after each instance of file transfer.\n\nIII.B Data Representation and Storage\n\n    Data is transferred from a storage device in sending HOST to\na storage device in receiving HOST. Often it is necessary to perform\ncertain transformations on the data because data storage representations\nin the two systems are different. For example, NVT-ASCII has different\ndata storage representations in different systems. PDP-10's generally\nstore NVT-ASCII as five 7-bit ASCII characters, left justified in a 36\nbit word. 360's store NVT-ASCII as 8-bit EBCDIC codes. Multics stores\nNVT-ASCII as four 9-bit characters in a 36-bit word. It may desirable to\nconvert characters into the standard NVT-ASCII representation when\ntransmitting text between disimilar systems. The sending and receiving\nsite would have to perform the necessary transformations between the\nstandard representation and their internal representations.\n\n    A different problem in representation arises when\ntransmitting binary data (not character codes) between HOST systems with\ndifferent word length. it is not always clear how the sender should send\ndata, and the receiver store it. For example, when transmitting 32-bit\nbytes from a 32-bit word-length system to a 36-bit word-length system,\nit may be desirable (for reasons of efficiency and usefulness) o store\nthe 32-bit bytes right justified in a 36-bit word in the latter system.\nIn any case, the user should have the option of specifying data\nrepresentation and transformation functions. It should be noted that FTP\nprovides for very limited data types reprentations.  Transformations\ndesired beyond this limited capability should be performed by the user\ndirectly or via the use of the Data Reconfiguration Service (DRS, RFC\n#138, NIC #6715). Additional representation types may be defined later\nif there is a demonstrable need.\n\n\n\n                                                                [Page 7]\n\f\nThe File Transfer Protocol                                  July 8, 1972\n\n\n    Data representations are handled in FTP by a user specifying\na representation type. The type may also specify a fixed transfer byte\nsize. For example in ASCII and Print File representations, the transfer\nbyte size must be 8 bits. Only in the Image and Local Byte\nrepresentations the byte size specified by the BYTE command is to be\nused. The following data representation types are currently defined in\nFTP:\n\n1. ASCII            The sender converts data form its internal\n                    character representation to the standard\n                    ARPANET ASCII form. The receiver converts\n                    the data from the standard form to its own\n                    internal form. The data is transferred in\n                    the standard form. The transfer byte size\n                    must be 8 bits. This type would be used for\n                    transfer of text files. This is be default\n                    type, and it is recommended that this type be\n                    implemented by all.\n\n2. Image            The sender transforms data from contiguous\n                    bits to bytes for transfer. The receiver\n                    transforms the bytes into bits, storing them\n                    contiguously independent of the byte size\n                    chosen for data transfer. Typical uses for\n                    the Image type are transfer of executable\n                    programs between like machines, and transfer\n                    of binary (non-text) data. It is recommended\n                    that this type be implemented by all for some\n                    byte size preferably including the 8 bit byte\n                    size.\n\n3. Local Byte       This representation allows for efficient\n                    storage, use, and retrieval of data. The\n                    mann in which data is to be transformed\n                    depends on the byte size for data transfer,\n                    and the particular HOST being used. The\n                    transformation scheme for different byte size\n                    is to be well publicized b all server sites.\n                    This transformation shall be invertible\n                    (i.e., if a file is stored using a certain\n                    transfer byte size, an identical file must be\n                    retrievable using the same byte size and\n                    representation type). It is the user's\n                    responsibility to keep track of the\n                    representation type and byte size used for\n                    his transfer. Typical uses of the Local Byte\n                    type are in efficient storage and retrieval\n                    of files, and transfer of structured binary\n\n\n\n                                                                [Page 8]\n\f\nThe File Transfer Protocol                                  July 8, 1972\n\n\n                    data. This type may be identical to the\n                    image type for byte size which are integral\n                    multiples of or factors of the computer word\n                    length-\n\n4. Print File-      The server site will transform the ASCII\n   ASCII            file in a form suitable for printing at the\n                    server site. The byte size must be 8 bits.\n                    The transformation may not be invertible.\n                    This type is different from ASCII in that\n                    TABs, FFs and other ASCII format effector\n                    characters may be replaced by SPs, LFs, and\n                    other substitute characters. The print file\n                    conversions are to be well publicized by all\n                    server sites. This type would be used when\n                    the file is destined for an ASCII printer.\n                    This type in some systems may be identical to\n                    the ASCII type. It is recommended that this\n                    type be implemented by all.\n\n5. EBCDIC Print     The server site will transform the EBCDIC\n   File             file into a form suitable for printing at the\n                    server site. The byte size must be 8 bits.\n                    the transformation may not be invertible.\n                    This type would be used when the file is\n                    destined for an EBCDIC printer. Only systems\n                    which use EBCDIC for their internal character\n                    representation need accept this type.\n\n    It should be noted that a serving HOST need not accept all\nrepresentation types and/or byte size, but it must inform the user of\nthe fact by sending an appropriate reply.\n\nIII.C File Structure and Transfer Modes\n\n    The only file structures supported directly in FTP at the\npresent time are record structures. However, the use of record\nstructures is not mandatory. A user with no record structure in his file\nshould be able to store and retrieve his file at any HOST. A user\nwishing to transmit a record structured file must send the appropriate\nFTP 'STRU' command (the default assumption is no record structure). A\nserving HOST need not accept record structures, but it must inform the\nuser of this fact by sending an appropriate reply. Any record structure\ninformation in the data stream may subsequently be discarded by the\nreceiver.\n\n\n\n\n\n\n                                                                [Page 9]\n\f\nThe File Transfer Protocol                                  July 8, 1972\n\n\n    All data transfer must end with an EOF. The EOF is defined\nby the data transfer mode. For files that have record structures, an EOR\nis also defined by the transfer mode. Only the transfer modes and\nrepresentation type combinations that have EOR defined may be used for\ntransfer or files with record structures. Records may be of zero length\nbut they must be contained in file boundaries. The relationship between\nfiles and records is heirarchical and an EOF implies an EOR.\n\n    The following data transfer modes are defined in FTP:\n\n1. Stream           The file is transmitted as a stream of bytes of the\n                    specified byte size. The EOF is signalled by\n                    closing the data connection. Any representation\n                    type and byte size may be used in the stream mode\n                    but record structures are possible only with the\n                    ASCII representation type. The convention is that\n                    the ASCII character CR (Carriage Return, Code 13.)\n                    followed by LF (Line Feed, Code 10.) Indicates an\n                    EOR in stream mode and ASCII representation type.\n                    This is the default mode, and it is recommended\n                    that this mode be implemented by all.\n\n2. Text             The file is ASCII text transmitted as sequence of\n                    8-bit bytes in the ASCII representation type.\n                    Record structures are allowed in this mode. The\n                    EOR and EOF are defined by the presence of special\n                    \"TELNET-control\" codes (most significant bit set\n                    of one) in the data stream. The EOR code is 192\n                    (octal 300, hex C0). The EOF code os 193 (octal\n                    301, hex C1). The byte size for transfer is 8\n                    bits.\n\n3. Block            The file is transmitted as a series of data blocks\n                    preceded by one or more header bytes. The header\n                    bytes contain a count field and descriptor code.\n                    The count field indicates the total length of the\n                    data block in bytes, thus marking the beginning of\n                    the next data block (there are no filler bits).\n                    The descriptor code defines last file block (EOF),\n                    last record block (EOR), restart marker (see\n                    section III.D), or suspect data (i.e. the data\n                    being transferred is suspected of errors and is\n                    not reliable). Record structures are allowed in\n                    this mode, and any representation type or byte\n                    size may be used. The header consists of integral\n                    number of bytes whose length is greater than or\n                    equal to 24 bits. Only the least significant 24\n                    bits (right-jusified) of header shall have\n\n\n\n                                                               [Page 10]\n\f\nThe File Transfer Protocol                                  July 8, 1972\n\n\n                    information, other must significant bits must be\n                    zero. Of the 24 bits of header information, the\n                    16 low order bits shall represent byte count, and\n                    the 8 high order bits shall represent descriptor\n                    codes as shown below.\n\n                            Integral data bytes \u003e 24\n\n\n                    | Must be Zero  | Descriptor    | Byte Count    |\n                    | 0 to 231 bits |   8 bits      |    16 bits    |\n\n                    The following descriptor codes are assigned:\n\n                    Code  Meaning\n                      0   An ordinary block of data.\n                      1   End of data block is EOR.\n                      2   End of data block is EOF.\n                      3   Suspected errors in data block.\n                      4   Data block is a restart marker.\n\n                    The restart marker is imbedded in the data stream\n                    as integral number of 8-bit bytes (representing\n                    printable ASCII characters) right-justified in\n                    integral number of data bytes greater than 8 bits.\n                    For example if the byte size is 7 bits, the\n                    restart marker byte would be one byte\n                    right-justified per two 7-bit bytes as shown\n                    below:\n\n                      Two 7-bit bytes\n\n                    |           | Marker Char|\n                    |           |    8 bits  |\n\n                    For byte size of 16 bits or more, two more\n                    marker bytes shall be packed right-justified. The\n                    end of the marker may be delimited by the\n                    character SP (code 32.). If marker characters do\n                    no exactly fit an integral byte, the unused\n                    character slots should contain the ASCII character\n                    SP (code 32.). For example, to transmit a six\n                    character marker in a 36-bit byte size, the\n                    following three 36.bit bytes would be sent:\n\n                    |   Zero    |  Descriptor  |               |\n                    |   12 bits |  code=4      | Byte count=2  |\n\n\n\n\n                                                               [Page 11]\n\f\nThe File Transfer Protocol                                  July 8, 1972\n\n\n                    |    | Marker  | Marker | Marker | Marker |\n                    |    | 8 bits  | 8 bits | 8 bits | 8 bits |\n\n\n                    |    | Marker  | Marker | SP     | SP     |\n                    |    | 8 bits  | 8 bits | 8 bits | 8 bits |\n\n4 Hasp              The file is transmitted as a sequence of 8-bit bytes\n                    in the standard Hasp-compressed data format\n                    (document to be issued by Bob Braden, UCLA). This\n                    mode achieves considerable compression of data for\n                    print files. Record structures are allowed in the\n                    Hasp mode.\n\nIII.D Error Recovery and Restart\n\n    There is no provision for detecting bits lost or scrambled\nin data transfer. This issue is perhaps handled best at the NCP level\nwhere it benefits most users. However, a restart procedure is provided\nto protect user from system failures (such as failure of either HOST,\nFTP-process, or the IMP subnet).\n\n    The restart procedure is defined only for the block mode of\ndata transfer. It requires the sender of data to insert a special marker\ncode in teh data stream with some marker information. The marker\ninformation has meaning only to the sender, but must consist of\nprintable ASCII characters. The printable ASCII characters are defined\nto be codes 33. through 126. (i.e., not including codes 0. through 31.\nand the characters SP and DEL). The marker could represent a bit-count,a\nrecord-count, or any other information by wich a system may identify a\ndata checkpoint. The receiver of data, if it implements the restart\nprocedure, would then mark the corresponding position of this marker in\nthe receiving system, and return this information to the user.\n\n    In the event of a system failure, the user can restart the\ndata transfer by identifying the marker point with the FTP restart\nprocedure. The following examples Illustrate the use of the restart\nprocedure.\n\n    1. When server is the sender of data, the server-FTP process\ninserts an appropriate marker block in the data stream at a convenient\ndata point. The user-FTP process receiving the data, marks the\ncoressponding data point in its file system and conveys the last known\nsender and receiver marker information to the user. In the event of\nsystem failure, the user or user-FTP process restarts the server at the\n\n\n\n\n\n\n                                                               [Page 12]\n\f\nThe File Transfer Protocol                                  July 8, 1972\n\n\nlast server marker by sending a restart command with the server's marker\ncode at its argument.  The restart command is transmitted over the\nTELNET connection and is immediately followed by the command (such as\nstore or retrieve) which was being executed when the system failure\noccured.\n\n    2. When user is the sender of data, the user-FTP process\ninserts the appropriate marker block in the data stream. The server-FTP\nprocess receiving the data, marks the corresponding data point in its\nfile system. The server does not store this marker but conveys the last\nknown sender and receiver marker information to the user over the TELNET\nconnections by appropriate reply codes. The user or the user-FTP process\nthen restarts transfer in a manner identical to that described in the\nfirst example.\n\nIV. FILE TRANSFER FUNCTIONS\n\n    The TELNET connections on which FTP commands and replies are\ntransmitted, are initiated by the user-FTP process via an ICP to a\nstandard server socket. FTP commands are then transmitted from user to\nserver, and replies are transmitted from server to user.  The user file\ntransfer functions invoive sending the FTP commands, interpreting the\nreplies received and transferring data over the data connection in the\nspecified manner. The server file transfer functions involve accepting\nand interpreting FTP commands, sending replies, setting up the data\nconnection, and transferring data.\n\nIV.A FTP Commands\n\n    FTP commands are ASCII terminated by the ASCII\ncharacter sequence CRLF (Carriage Return follow by Line Feed).  The\ncommand codes themselves are ASCII alpabetic characters terminated by\nthe ASCII character 'space' (code = 32.). For convenience, the command\ncodes are defined to be four (or less) ASCII alphanumeric characters\n(including both upper and lower case alphabetic characters). The command\ncodes and the semantics of commands are described in this section, but\nthe detailed syntax of commands is specified in Section V.b, the reply\nsequence are discussed in Section V.C, and scenarios illustrating the\nuse of commands are provided in Section V.D.\n\n    FTP commands may be partitioned as those specifying\naccess-control identifiers, data transfer parameters, or FTP service\nrequests.\n\n\n\n\n\n\n\n\n                                                               [Page 13]\n\f\nThe File Transfer Protocol                                  July 8, 1972\n\n\nIV.A.1 Access Control Commands\n\nThe following commands specify access control identifiers\n       (command codes are shown in parentheses).\n\n       User name (USER) - The argument field is an ASCII string\n       identifying the user. The user identification is that wich is\n       required by the server for access to its file system. This\n       command will normally be the first command transmitted by the\n       user after the TELNET connections are made (some servers may\n       require this). Additional identification information in the form\n       of pasword command may also be required by some servers.\n\n       Password (PASS) - The argument field is an ASCII string\n       identifying the user's password. This command must be immediately\n       preceded by the user name command, and together it completes the\n       user's identifecation for access control.\n\nIV.A.2 Data Transfer Commands\n\n       All data transfer parameters have default values, and the\n       commands specifying data transfer parameters are required only if\n       the default parameter values are to be changed.  The default\n       value is teh last specified value, or if no value has been\n       specified, the standard default value specified here. This\n       implies that the server must \"remember\" the applicable default\n       values. The commands may be in any order except that they must\n       precede the FTP service request. The following commands specify\n       data transfer parameters.\n\n       Byte size (BYTE) - The argument is an ASCII-represented decimal\n       integer (1 through 255), specifying the byte size for the data\n       connection for local byte and image representation types. The\n       default byte size is 8 bits.  The byte size is always 8 bits in\n       the ASCII and Print file representation types. A server may\n       reject specific byte size/type combinations by sending an\n       appropriate reply.\n\n       Data socket (SOCK) - The argument is a HOST-socket specification\n       for the data socket to be used in data connection. There may be\n       two data sockets, one from server to user and the other for user\n       to server data transfer. An odd socket number defines a send\n       socket and an even socket number defines a receive socket. The\n       default HOST is the user HOST to which TELNET connections are\n       made. The default data sockets are (U+4) and (U+5) where U is the\n       socket number used in the TELNET ICP and the TELNET connections\n       are on sockets (U+2) and (U+3).\n\n\n\n\n                                                               [Page 14]\n\f\nThe File Transfer Protocol                                  July 8, 1972\n\n\n       Representation Type (TYPE) - The argument is a single ASCII\n       character code specifying the representation types described in\n       section III.B. The following codes are assigned for type:\n\n          A - ASCII\n          I - Image\n          L - Local Byte\n          P - Print file in ASCII\n          E - EBCDIC print file\n\n       The default representation type is ASCII\n\n       File Structure (STRU) - The argument is a single ASCII character\n       code specifying file structure described in section III.C. The\n       following codes are assigned for structure:\n\n          F - File (no record structure)\n          R - Record structure\n\n       The default structure is File (i.e., no records).\n\n       Transfer Mode (MODE) - The argument is a single ASCII character\n       code specifying the data transfer modes described in Section\n       III.C. The following codes are assigned for transfer modes:\n\n          S - Stream (bytes, close is EOF)\n          B - Block (Header with descriptor and count)\n          T - Text (TELNET control mode for EOR, EOF)\n          H - Hasp (specially formatted compressed data)\n\n       The default transfer mode is Stream.\n\nIV.A.3 FTP Service Commands.\n\n       The FTP service commands define the file transfer or the file\n       system function requested by the user. The argument of an FTP\n       service command will normally be a pathname.  the syntax of\n       pathnames must conform to server site conventions (with standard\n       defaults applicable), except that ASCII characters must be used\n       (in conformance with the TELNET Protool). The suggested default\n       handling is to use the last specified device directory or file\n       name, or the standard default defined for local users. The\n       commands may be in any order except that a \"rename from\" command,\n       must be followed by a \"rename to\" command, and some servers may\n       require an \"allocate\" command before a \"store\" command. The data\n       when transferred in response to FTP service commands shall always\n       be over the data connection. The following commands specify FTP\n       service requests:\n\n\n\n                                                               [Page 15]\n\f\nThe File Transfer Protocol                                  July 8, 1972\n\n\n       Retrieve (RETR) - This command achieves the transfer of a copy of\n       file specified in pathname, from server to user site. The status\n       and contents of a file at server site shall be unaffected.\n\n       Store (STOR) - This command achieves the transfer of a copy of\n       file from user to server site. If file specified in pathname\n       exists at the server site, then its contents shall be replaced by\n       the contents of the file being transferred. A new file is created\n       at the server site if the file specified in pathname does not\n       already exist.\n\n       Append (with create) (APPE) - This command achieves the transfer\n       of data from using to serving site. If file specified in pathname\n       exists at the server site, then the data transferred shall be\n       appended to that file, otherwise the file specified in pathname\n       shall be created at the server site.\n\n       Rename from (RNFR) - This command specifies the file which is to\n       be renamed. This command must be immediately followed by a\n       \"rename to\" command specifying the new file pathname.\n\n       Delete (DELE) - This command causes teh file specified in\n       pathname to be deleted at the server site. If an extra level of\n       protection is desired (such as the query, \"Do you really wish to\n       delete?\"), it should be provided by the user-FTP process.\n\n       List (LIST) - This command causes a list to be sent from server\n       to user site. If pathname specifies a directory, the server\n       should transfer a list of files in the specified directory. If\n       pathname specifies a file then server should send current\n       information on the file. This command may be used to obtain the\n       contents of a file directory (the response should be sent in\n       ASCII type) or test the existence of a file and its current\n       status.\n\n       Allocate (ALLO) - This command my be required by some servers to\n       reserve sufficient storage to accomodate the new file to be\n       transferred. The command field shall be a decimal integer\n       representing the number of bytes (of size specified by the byte\n       size command) of storage to be reserved for the file. This\n       command shall be followed by a store or append command. The ALLO\n       command should be treated as a NO-OP (no operation) by thuse\n       servers which do not require that the maximum size of the file be\n       declared beforehand.\n\n       Restart (REST) - The argument field represents the server marker\n       at which file transfer is to be restarted. This command does not\n       cause file transfer but \"spaces\" over the file to the specified\n\n\n\n                                                               [Page 16]\n\f\nThe File Transfer Protocol                                  July 8, 1972\n\n\n       data checkpoint. This command shall be immediately followed by\n       the appropriate FTP service command which shall cause file\n       transfer to resume.\n\n       Status (STAT) - This command shall cause a status response to be\n       sent over the TELNET connection in form of a reply.  The command\n       may have an argument field such as a pathname.  if the argument\n       is a pathname, the command is analogous to the \"list\" command\n       except that data shall be transferred in ASCII on the TELNET\n       connection. If no argument is specified, the server should return\n       general status information about the server FTP process. This may\n       include service availability, the current settings for the\n       relevant FTP parameters (including default settings), and the\n       status of command execution and connections.\n\n       Abort (ABOR) - This command indicates to the server to abort the\n       previous FTP service command and any associated transfer of data.\n       The abort command should be preceded by the TELNET SYNCH\n       condition (indicated by the combination of the DATA MARK and the\n       INS). No action is to be taken if the previous command has been\n       completed (including data transfer). The TELNET connections is\n       not to be closed by the server, but the data connection may be\n       closed. An appropriate reply should be sent by the server.\n\n       Logout (BYE) - This command terminates a USER and if file\n       transfer is not in progress, closes the TELNET connection.  If\n       file transfer is in progress, the connection will remain open for\n       result response and will then close.  During the interim a new\n       USER command (and no other command) is acceptable.\n\n       An unexpected close on TELNET connection will cause the server to\n       take the effective action of an abort (ABOR) and a logout (BYE).\n\nIV.B FTP Replies\n\n    The server sends FTP replies to user over the TELNET\nconnections in response to FTP commands. The FTP replies constitute the\nacknowledgement or completion code (including errors). The FTP-server\nreplies are formatted for human or program interpretation. The replies\nconsist of a leading three digit numeric code followed by a space\nfollowed by a text explanation of the code. The numeric codes are\nassigned by groups and for ease of interpretation by programs in a\nmanner consistent with other protocols such as the RJE protocol. The\nthree digits of the code are to be interpredet as follows:\n\n\n\n\n\n\n\n                                                               [Page 17]\n\f\nThe File Transfer Protocol                                  July 8, 1972\n\n\na) The first digit specifies type of response as indicated below:\n\n   000 These replies are purely informative and constitute\n       neither a positive nor a negative acknowledgement.\n\n   1xx informative replies to status inrequiries. These constitute\n       a positive acknowledgment to the status command.\n\n   2xx Positive acknowledgment of previous command or other\n       successful action.\n\n   3xx Incomplete information. Activity cannot proceed without\n       further specification and input.\n\n   4xx Unsuccessful reply. The request is correctly specified\n       but the server is unsuccessful in corretly fulfilling\n       it.\n\n   5xx Incorrect or illegal command. The command or its\n       parameters were invalid or incomplete from a syntactic\n       viewpoint, or the command its inconsistent with a previous\n       command. The command in question has been completely\n       ignored.\n\n   6xx - 9xx Reserved for future expansion.\n\nb) The second digit specifies the general category to which\n   the response refers:\n\n   x00-x29 General purpose replies, not assignable to other\n       categories.\n\n   x30 Primary access. Informative replies to the \"log-on\"\n       attempt.\n\n   x40 Secondary access. The primary server is commenting on its\n       ability to access a secondary service.\n\n   x5x FTP results.\n\n   x6x RJE resutls.\n\n   x7x-x9x Reserved for future expansion.\n\n\n\n\n\n\n\n\n                                                               [Page 18]\n\f\nThe File Transfer Protocol                                  July 8, 1972\n\n\nc) the final digit specifies a particular message type. Since the code\nis designed for an automaton process to interpret, it is not necessary\nfor every variation of a reply to have a unique number. Only the basic\nmeaning of replies need have unique numbers. The text of a reply can\nexplain the specific reason for that reply to a human user.\n\n    Each TELNET line (ended by CRLF) from the server is intended\nto be a complete reply message. if it is necessary to continue the text\nof a reply onto following lines, then those continuation replies contain\nthe special reply code of three spaces. It should be noted that text of\nreplies are intended for a human user. Only the reply codes and in some\ninstances the first line of text are intended for programs.\n\n    The assigned reply codes relating to FTP are:\n\n000 General information message (site, time of day, etc.)\n030 Server availibility information.\n050 FTP commentary or user information.\n100 System status reply.\n150 File status reply.\n151 Directory listing reply.\n200 Last command received correctly.\n201 An ABORT has terminated activity, as requested.\n202 Abort request ignored, no activity in progress.\n230 User is \"logged in\". may proceed.\n231 User is \"logged out\". Service terminated.\n232 Logout command noted, will complete when transfer done.\n250 FTP file transfer started correctly.\n251 FTP Restart-marker reply\n          Text is: MARK yyyy  =  mmmm\n          where yyyy is user's data stream marker (yours)\n          and mmmm is server's equivalent marker (mine)\n          (Note the spaces between the markers and '=').\n252 FTP transfer completed correctly.\n253 Rename completed.\n254 Delete completed.\n255 FTP server data socket reply\n          Text is: SOCK nnnn\n          where nnnn is decimal integer representing\n          the server socket for data connection.\n300 Connection greeting message, awaiting input.\n301 Current command incomplete (no CRLF for long time).\n330 Enter password (may be sent with hide-your-input).\n400 This service not implemented.\n401 This service not accepting users now, goodbye.\n430 Log-on time or tries exceeded, goodbye.\n431 Log-on unsuccessful. User and/or password invalid.\n432 User not valid for this service.\n\n\n\n                                                               [Page 19]\n\f\nThe File Transfer Protocol                                  July 8, 1972\n\n\n434 Log-out forced by operator action. Phone site.\n435 Log-out forced by system problem.\n436 Service shutting down, goodbye.\n450 FTP: File not found.\n451 FTP: File access denied to you.\n452 FTP: File transfer incomplete, data connection closed.\n453 FTP: File transfer incomplete, insufficient storage space.\n500 Last command line completely unrecognized.\n501 Syntax of last command in incorrect.\n502 Last command incomplete, parameters missing.\n503 Last command invalid (ignored), illegal parameter combination.\n504 Last command invalid, action not possible at this time.\n505 Last command conflicts illegally with previous command(s).\n506 Requested action not implemented by the server.\n\nV. DECLARATIVE SPECIFICATIONS\n\nV.A. Connections\n\n    The server-FTP process at the server site shall \"listen\" on\nSocket 3, via its server-TELNET. The user or user-FTP process at the\nuser site shall initiate the full-duplex TELNET connections via its\nuser-TELNET performing the ARPANET standard initial connection protocol\n(ICP) to server socket 3. The TELNET connections shall be closed by the\nuser site upon completion of use.\n\n    The user site shall \"listen\" on the specified data socket or\nsockets (a send and/or a receive socket). The server site shall initiate\nthe data connection using the specified data socket and byte size. The\ndirection of data connection and the data socket used shall be\ndetermined by the FTP service command. The server shall send a reply to\nthe user indicating the server data socket so that the user may ensure\nthe security of data transfer. This can be done at any time prior to the\nfirst transfer of data over a data connection.\n\n    The data connection shall be closed by the server site under\nthe conditions described is Section III.A. The server should in general\nsend a reply before closing the data connection to avoid problems at the\nuser end.\n\nV.B. Commands\n\n    The commands are ASCII character strings transmitted over\nthe TELNET connections as described in section IV.A. The command\nfunctions and semantics are described in sections IV.A.1, IV.A.2,\nIV.A,3, and IV.A.4. The command syntax is specified here.\n\n\n\n\n\n                                                               [Page 20]\n\f\nThe File Transfer Protocol                                  July 8, 1972\n\n\n    The commands begin with a command code followed by an\nargument field. The command codes are four of less ASCII alphabetic\ncharacters. Upper and lower case alphabetic characters are to be treated\nidentically. Thus any of the following may represent the retrieve\ncommand:\n\n    RETR Retr retr ReTr rETr\n\nThe command codes and the argument fields are separated by one or more\nspaces.\n\n    The argument field consists of a variable length ASCII\ncharacter string ending with the character sequence CRLF (Carriage\nReturn immediately followed by Line Feed). In the following section on\nsyntax it should be stressed that all characters in the argument field\nare ASCII characters. Thus a decimal integer shall mean an ASCII\nrepresented decimal integer.\n\n    The following are all the currently defined FTP commands:\n\n         USER \u003cuser name\u003e CRLF\n         PASS \u003cpassword\u003e CRLF\n         BYTE \u003cbyte size\u003e CRLF\n         SOCK \u003cHOST-socket\u003e CRLF\n         TYPE \u003ctype code\u003e CRLF\n         STRU \u003cstructure code\u003e CRLF\n         MODE \u003cmode code\u003e CRLF\n         RETR \u003cpathname\u003e CRLF\n         STOR \u003cpathname\u003e CRLF\n         APPE \u003cpathname\u003e CRLF\n         RNFR \u003cpathname\u003e CRLF\n         RNTO \u003cpathname\u003e CRLF\n         DELE \u003cpathname\u003e CRLF\n         LIST \u003cpathname\u003e CRLF\n         ALLO \u003cdecimal integer\u003e CRLF\n         REST \u003cmarker\u003e CRLF\n         STAT \u003cpathname\u003e CRLF\n         ABOR \u003cempty\u003e CRLF\n          Bye \u003cempty\u003e CRLF\n\n    The syntax of the above argument fields (using BNF notation\nwhere aplicable) is:\n\n     \u003cusername\u003e ::= \u003cstring\u003e\n     \u003cpassword\u003e ::= \u003cstring\u003e\n     \u003cstring\u003e ::= \u003cempty\u003e | \u003cchar\u003e | \u003cchar\u003e\u003cstring\u003e\n     \u003cchar\u003e ::= any of the 128 ASCII characters except CR and LF.\n     \u003cmarker\u003e ::= \u003cpr string\u003e\n\n\n\n                                                               [Page 21]\n\f\nThe File Transfer Protocol                                  July 8, 1972\n\n\n     \u003cpr string\u003e ::= \u003cempty\u003e | \u003cpr char\u003e | \u003cpr char\u003e\u003cpr string\u003e\n     \u003cpr char\u003e ::= any ASCII code 33 through 126.\n     \u003cbyte size\u003e ::= any decimal integer 1 through 255.\n     \u003cHOST-socket\u003e ::= \u003csocket\u003e | \u003cHOST number\u003e,\u003csocket\u003e\n     \u003cHOST number\u003e ::= a decimal integer specifying an ARPANET HOST.\n     \u003csocket\u003e ::= decimal integer between o and (2**32)-1\n     \u003ctype code\u003e ::= A|I|L|P|E\n     \u003cstructure code\u003e ::= F|R\n     \u003cmode code\u003e ::= S|B|T|H\n     \u003cpathname\u003e ::= \u003cstring\u003e\n     \u003cdecimal integer\u003e ::= \u003cdigit\u003e | \u003cdigit\u003e\u003cdecimal integer\u003e\n     \u003cdigit\u003e ::= 0|1|2|3|4|5|6|7|8|9|\n     \u003cempty\u003e ::= the null string (specifies use of default).\n\nV.C Sequencing of Commands and Replies\n\n    The communication between the user and server is intended to\nbe an alternating dialogue. As such, the user issues an FTP\ncommand and the server responds with a prompt primary reply. The\nuser should wait for this initial primary success of failure\nresponse before sending further commands.\n\n    A second type of reply is sent asynchronously with respect\nto user commands. These replies may for example report on the\nprogress or completion of file transfer and as such are secondary\nreplies to file transfer commands.\n\n    The third class of replies are informational and spontaneous\nreplies which may arrive at any time. These replies are listed\nbelow as spontaneous.\n\n               COMMAND-REPLY CORRESPONDENCE TABLE\n\nCOMMAND             SUCCESS              FAIL\n\nUSER                230,330              430-432,500-505\nPASS                230                  430-432,500-505\nBYE                 231,232              430-432,500-505\nBYTE                200                  500-506\nSOCK                200                  500-506\nTYPE                200                  500-506\nMODE                200                  500-506\nRETR                250                  450,451,500-506\n  Secondary Reply   252                  452\nSTOR                250                  451,451,500-506\n  Secondary Reply   252                  452,453\nAPPE                250                  451,451,500-506\n  Secondary Reply   252                  452,453\n\n\n\n                                                               [Page 22]\n\f\nThe File Transfer Protocol                                  July 8, 1972\n\n\nRNFR                200                  450,451,500-506\nRNTO                253                  450,451,500-505\nDELE                254                  450,451,500-506\nLIST                250                  450,453,500-506\n  Secondary Reply   252                  452\nALLO                200                  500-506\nSTAT                100,150,151          450,451,500-506\nREST                200                  500-506\nABOR                201,202              500-505\n\nSpontaneous         0xx,300,301          400,401,434-436\nReplies             251,255\n\nV.D. Tyical FTP Scenarious\n\n1. TIP User wanting o transfer file from FOST X to local printer:\n\n   a) TIP user opens TELNET connections by ICP to HOST X, socket 3.\n\n   b) The following commands and replies are exchanged:\n          TIP                           HOST X\n\n          USER username CRLF  --------\u003e\n          \u003c-------  330 Enter Password CRLF\n\n          PASS password CRLF  --------\u003e\n          \u003c-------  230 User logged in CRLF\n\n          SOCK 65538 CRLF     --------\u003e\n          \u003c-------  200 Command received OK CRLF\n\n          RETR this.file CRLF --------\u003e\n          \u003c-------  255 SOCK 5533 CRLF\n\n          (HOST X initiates data connection to\n           TIP socket 65538, i.e., PORT 1 receive)\n\n          \u003c------- 250 File transfer started\n\n          BYE CRLF           ------_-\u003e\n          \u003c------- 252 File transfer completed\n\n   c) HOST X closes the TELNET and data connections.\n\n   Note: The TIP user should be in line mode and can thus use\n         local TIP editing such as character delete.\n\n\n\n\n\n                                                               [Page 23]\n\f\nThe File Transfer Protocol                                  July 8, 1972\n\n\n2. User at Host U wanting to transfer files to/from HOST S:\n\n     In general the user would communicate to the server via a\n   mediating user-FTP process. The following may be a typical\n   scenario. The user-FTP prompts are shown in parenthesis,\n   '----\u003e' represents commands from HOST U to HOST S, and\n   '\u003c----' represents replies from HOST S to HOST U.\n\nLocal Commands by User                  Action Involved\n\nftp (host) multics CR         ICP to HOST S, socket 3,\n                              establishing TELNET connections.\nusername Doe CR               USER DoeCRLF ----\u003e\n                              \u003c---- 330 passwordCRLF\npassword mumble CR            PASS mumbleCRLF ----\u003e\n                              \u003c---- 230 Doe logged in.CRLF\nretrieve (local type ASCIICR\n(local pathname) test 1 CR    USER-FTP open local file in ASCII.\n(for. pathname) test.pl1CR    RETR test.pl1 CRLF ----\u003e\n                              \u003c---- 255 SOCK 1233CRLF\n                              Server makes data connection to (U+4).\n                              \u003c---- 250 File transfer startsCRLF\n                              \u003c---- 252 File transfer completeCRLF\ntype imageCR                  TYPE |CRLF ----\u003e\n                              \u003c---- 200 Command OKCRLF\nbyte 36CR                     BYTE 36CRLF ----\u003e\n                              \u003c---- 200 Command OKCRLF\nstore (local type) ImageCR\n(local pathname) file dumpCR  User-FTP opens local file in Image.\n(for. pathname) \u003eudd\u003ecn\u003efdCR  STOR \u003eudd\u003ecn\u003efdCRLF ----\u003e\n                              \u003c---- 451 Access deniedCRLF\nterminate                     BYECRLF\n                              \u003c---- 231 Doe logged outCRLF\n                              Server closes all connections.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                               [Page 24]\n\f\nThe File Transfer Protocol                                  July 8, 1972\n\n\nACKNOWLEDGEMENTS\n\n    The work on file transfer protocol has involved many people.\nThis document reports the work of a group rather than the author\nalone. The author gratefully acknowledges the conributions of\nthe following:\n\n          Bob Braden         UCLA-CCCN\n          Arvola Chan        MIT-MAC\n          Bill Crowther      BBN-TIP\n          Eric Harslem       RAND\n          John Heafner       RAND\n          Chuck Holland      UCSD\n          Alex McKenzie      BBN (NET)\n          Bob Metcalfe       XPARC\n          Jon Postel         UCLA\n          Neal Ryan          MIT-MAC\n          Bob Sundberg       HARVARD\n          Ray Tomlinson      BBN (TENEX)\n          Dick Watson        SRI-ARC\n          Jim White          SRI-ARC\n          Richard Winter     CCA\n\n\n       [ This RFC was put into machine readable form for entry ]\n       [ into the online RFC archives by Gottfried Janik 9/97  ]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                               [Page 25]\n\f\n"
}