{
  "series": "Request for Comments",
  "number": "5",
  "howpublished": "RFC 5",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0005",
  "url": "https://www.rfc-editor.org/info/rfc5",
  "title": "Decode Encode Language (DEL)",
  "pagetotal": "17",
  "year": "1969",
  "month": "jun",
  "body": "Network Working Group                                           4691\nRFC-5                                                           Jeff Rulifson\n                                                                June 2, l969\n\n\n\n                                DEL\n\n\n\n:DEL, 02/06/69 1010:58   JFR   ;   .DSN=1; .LSP=0; ['=] AND NOT SP ; ['?];\ndual transmission?\n\nABSTRACT\n\n   The Decode-Encode Language (DEL) is a machine independent language\n   tailored to two specific computer network tasks:\n\n      accepting input codes from interactive consoles, giving immediate\n      feedback, and packing the resulting information into message \n      packets for network transmissin.\n\n      and accepting message packets from another computer, unpacking\n      them, building trees of display information, and sending other\n      information to the user at his interactive station.\n\n   This is a working document for the evolution of the DEL language.\n   Comments should be made through Jeff Rulifson at SRI.\n\nFORWARD\n\n   The initial ARPA network working group met at SRI on October 25-26,\n   1968.\n\n      It was generally agreed beforehand that the runmning of interactive\n      programs across the network was the first problem that would be\n      faced.\n\n      This group, already in agreement about the underlaying notions of\n      a DEL-like approach, set down some terminology, expectations for\n      DEL programs, and lists of proposed semantic capability.\n\n      At the meeting were Andrews, Baray, Carr, Crocker, Rulifson, and\n      Stoughton.\n\n   A second round of meetings was then held in a piecemeal way.\n\n      Crocker meet with Rulifson at SRI on November 18, 1968.  This\n      resulted in the incorporation of formal co-routines.\n\n      and Stoughton meet with Rulifson at SRI on Decembeer 12, 1968.  It\n      was decided to meet again, as a group, probably at UTAH, in late\n      January 1969.\n\n   The first public release of this paper was at the BBN NET meeting in\n   Cambridge on February 13, 1969.\n\nNET STANDARD TRANSLATORS        \n\n   NST   The NST library is the set of programs necessary to mesh\n   efficiently with the code compiled at the user sites from the DEL\n   programs it receives.  The NST-DEL approach to NET interactive system\n   communication is intended to operate over a broad spectrum.\n\n   The lowest level of NST-DEL usage is direct transmission to the\n   server-host, information in the same format that user programs\n   would receive at the user-host.\n\n      In this mode, the NST defaults to inaction.  The DEL program\n      does not receive universal hardware representation input but \n      input in the normal fashion for the user-host.\n\n      And the DEL 1 program becomes merely a message builder and\n      sender.\n\n   A more intermediate use of NST-DEL is to have echo tables for a\n   TTY at the user-host.\n\n      In this mode, the DEL program would run a full duplex TTY for\n      the user.\n\n      It would echo characters, translate them to the character set \n      of the server-host, pack the translated characters in messages,\n      and on appropriate break characters send the messages.\n\n      When messages come from the server-host, the DEL program would\n      translate them to the user-host character set and print them on\n      his TTY.\n\n   A more ambitious task for DEL is the operation of large,\n   display-oriented systems from remote consoles over the NET.\n\n      Large interactive systems usually offer a lot of feedback to\n      the user.  The unusual nature of the feedback make it\n      impossible to model with echo table, and thus a user program\n      must be activated in a TSS each time a button state is changed.\n\n         This puts an unnecessarily large load on a TSS, and if the\n         system is being run through the NET it could easily load two\n         systems.\n\n         To avoid this double overloading of TSS, a DEL program will\n         run on the user-host.  It will handle all the immediate\n         feedback, much like a complicated echo table.  At appropriate\n         button pushes, message will be sent to the server-host and\n         display updates received in return.\n\n      One of the more difficult, and often neglected, problems is the\n      effective simulation of one nonstandard console on another non-\n      standard console.\n\n         We attempt to offer a means of solving this problem through\n         the co-routine structure of DEL programs.  For the\n         complicated interactive systems, part of the DEL programs\n         will be constructed by the server-host programmers.\n         Interfaces between this program and the input stream may\n         easily be inserted by programmers at the user-host site.\n\n\nUNIVERSAL HARDWARE REPRESENTATION\n\n   To minimize the number of translators needed to map any facility's\n   user codes to any other facility, there is a universal hardware\n   representation.\n\n   This is simply a way of talking, in general terms, about all the\n   hardware devices at all the interactive display stations in the initial\n   network.\n\n   For example, a display is thought of as being a square, the\n   mid-point has coordinates (0.0), the range is -1 to 1 on both\n   axes.  A point may now be specified to any accuracy, regardless of\n   the particular number of density of rastor points on a display.\n\n   The representation is discussed in the semantic explanations\n   accompanying the formal description of DEL.\n\nINTRODUCTION TO THE NETWORK STANDARD TRANSLATOR (NST)\n\n   Suppose that a user at a remote site, say Utah, is entered in the\n   AHI system and wants to run NLS.\n\n   The first step is to enter NLS in the normal way.  At that time\n   the Utah system will request a symbolic program from NLS.\n\n      REP   This program is written in DEL.  It is called the NLS\n      Remote Encode Program (REP).\n\n      The program accepts input in the Universal Hardware\n      Representation and translates it to a form usable by NLS.\n\n      It may pack characters in a buffer, also do some local\n      feedback.\n\n   When the program is first received at Utah it is compiled and\n   loaded to be run in conjunction with a standard library.\n\n   All input from the Utah console first goes to the NLS NEP.  It is\n   processed, parsed, blocked, translated, etc.  When NEP receives a\n   character appropriate to its state it may finally initiate\n   transfers to the 940.  The bits transferred are in a form\n   acceptable to the 940, and maybe in a standard form so that the\n   NLSW need not differentiate between Utah and other NET users.\n\n\nADVANTAGES OF NST\n\n   After each node has implemented the library part of the NST, it\n   need only write one program for each subsystem, namely the\n   symbolic file it sends to each user that maps the NET hardware\n   representation into its own special bit formats.\n\n      This is the minimum programming that can be expected if \n      console is used to its fullest extent.\n\n      Since the NST which runs the encode translation is coded at the\n      user site, it can take advantage of hardware at its consoles to\n      the fullest extent.  It can also add or remove hardware \n      features without requiring new or different translation tables\n      from the host.\n\n      Local users are also kept up to date on any changes in the system\n      offered at the host site.  As new features are added,\n      the host programmers change the symbolic encode program.  When\n      this new program is compiled and used at the user site, the new\n      features are automatically included.\n\n   The advantages of having the encode translation programs\n   transferred symbolically should be obvious.\n\n      Each site can translate any way it sees fit.  Thus machine code\n      for each site can be produced to fit that site; faster run\n      times and greater code density will be the result.\n\n      Moreover, extra symbolic programs, coded at the user site, may\n      be easily interfaced between the user's monitor system and the\n      DEL program from the host machine.  This should ease the\n      problem of console extension (e.g. accommodating unusual keys and\n      buttons) without loss of the flexibility needed for man-machine\n      interaction.\n\n\n   It is expected that when there is matching hardware, the symbolic\n   programs will take this into account and avoid any unnecessary\n   computing.  This is immediately possible through the code\n   translation constructs of DEL.  It may someday be possible through\n   program composition (when Crocker tells us how??)\n\n\nAHI NLS - USER CONSOLE COMMUNICATION - AN EXAMPLE\n\n   BLOCK DIAGRAM\n\n      The right side of the picture represents functions done at the\n      user's main computer; the left side represents those done at the\n      host computer.\n\n         Each label in the picture corresponds to a statement with the\n         same name.\n\n         There are four trails associated with this picture.  The first\n         links (in a forward direction) the labels which are concerned\n         only with network information.  The second links the total\n         information flow (again in a forward direction).  The last two\n         are equivalent to the first two but in a backward direction.\n         They may be set with pointers t1 through t4 respectively.\n\n         [\"\u003etif:] OR I\" \u003enif\"]; [\"\u003ctif:] OR [\"\u003cnif\"];\n\nUSER-TO-HOST TRANSMISSION\n\n   Keyboard is the set of input devices at the user's console.\n   Input bits from stations, after drifting through levels of monitor\n   and interrupt handlers, eventually come to the encode translator.\n   [\u003enif(encode)]\n\n   Encode maps the semi-raw input bits into an input stream in a\n   form suited to the serving-host subsystem which will process the\n   input.  [\u003enif(hrt)\u003cnif(keyboard)]\n\n      The Encode program was supplied by the server-host subsystem\n      when the subsystem was first requested.  It is sent to the user\n      machine in symbolic form and is compiled at the user machine\n      into code particularly suited to that machine.\n\n      It may pack to break characters, map multiple characters to\n      single characters and vice versa, do character translation, and\n      give immediate feedback to the user.\n\n   1 dm    Immediate feedback from the encode translator first goes to\n   local display management, where it is mapped from the NET standard\n   to the local display hardware.\n\n      A wide range of echo output may come from the encode\n      translator.  Simple character echoes would be a minimum, while\n      command and machine-state feedback will be common.\n\n      It is reasonable to expect control and feedback functions not\n      even done at the server-host user stations to be done in local\n      display control.  For example, people with high-speed displays\n      may want to selectively clear curves on a Culler display, a\n      function which is impossible on a storage tube.\n\n   Output from the encode translator for the server-host goes to the\n   invisible IMP, is broken into appropriate sizes and labeled by the\n   encode translator, and then goes to the NET-to-host translator.\n\n      Output from the user may be more than on-line input.  It may be\n      larger items such as computer-generated data, or files\n      generated and used exclusively at the server-host site but\n      stored at the user-host site.\n\n      Information of this kind may avoid translation, if it is already in\n      server-host format, or it may undergo yet another kind of translation\n      if it is a block of data.\n\n   hrp  It finally gets to the host, and must then go through the\n   host reception program.  This maps and reorders the standard\n   transmission-style packets of bits sent by the encode programs\n   into messages acceptable to the host.  This program may well be\n   part of the monitor of the host machine. [\u003etif(net mode)\u003cnif(code)]\n\n\nHOST-TO-USER TRANSMISSION\n\n   decode   Output from the server-host initially goes through decode,\n   a translation map similar to, and perhaps more complicated than,\n   the encode map.  [\u003enif(urt)\u003etif(imp ctrl)\u003ctif(net mode)]\n\n      This map at least formats display output into a simplified\n      logical-entity output stream, of which meaningful pieces may be\n      dealt with in various ways at the user site.\n\n         The Decode program was sent to the host machine at the same\n         time that the Encode program was sent to the user machine.\n         The program is initially in symbolic form and is compiled\n         for efficient running at the host machine.\n         \n         Lines of charaters should be logically identified so that\n         different line widths can be handled at the user site.\n\n         Some form of logical line identification must also be made.\n         For example, if a straight line is to be drawn across the\n         display this fact should be transmitted, rather than a\n         series of 500 short vectors.\n\n         As things firm up, more and more complicated structural\n         display information (in the manner of LEAP) should be sent\n         and accommodated at user sites so that the responsibility for\n         real-time display manipulation may shift closer to the user.\n\n      imp ctrl   The server-host may also want to send control\n      information to IMPs.  Formatting of this information is done by\n      the host decoder.  [\u003etif(urt) \u003ctif(decode)]\n\n      The other control information supplied by the host decoder is\n      message break up and identification so that proper assembly and\n      sorting can be done at the user site.\n\n   From the host decoder, information does to the invisible IMP, and\n   directly to the NET-to-user translator.  The only operation done\n   on the messages is that they may be shuffled.\n\n   urt   The user reception translator accepts messages from the\n   user-site IMP 1 and fixes them up for user-site display.  \n   [\u003enif(d ctrl)\u003etif(prgm ctrl)\u003ctif(imp ctrl)\u003cnif(decode)]\n\n      The minimal action is a reordering of the message pieces.\n      \n      dctrl   For display output, however, more needs to be done.  The\n      NET logical display information must be put in the format of\n      the user site.  Display control does this job.  Since it\n      coordinates between (encode) and (decode) it is able to offer\n      features of display management local to the user site.\n      [\u003enif(display)\u003cnif(urt)]\n\n      prgmctrl   Another action may be the selective translation and\n      routing of information to particular user-site subsystems.\n      [\u003etif(dctrl)\u003ctif(urt)]\n\n         For example, blocks of floating-point information may be\n         converted to user-style words and sent, in block form, to a\n         subsystem for processing or storage.\n\n         The styles and translation of this information may well be a \n         compact binary format suitable for quick translation, rather\n         than a print-image-oriented format.\n\n      (display)   is the output to the user.  [\u003cnif(d ctrl)]\n\n   \n   USER-TO-HOST INDIRECT TRANSMISSION\n\n      (net mode)   This is the mode where a remote user can link to a node\n      indirectly through another node.   [\u003cnif(decode)\u003ctif(hrt)]\n\n\nDEL SYNTAX\n\n   NOTES FOR NLS USERS\n  \n      All statements in this branch which are not part of the compiler\n      must end with a period.\n\n      To compile the DEL compiler:\n\n         Set this pattern for the content analyzer ( (symbol for up arrow)P1\n         SE(P1) \u003c-\"-;). The pointer \"del\" is on the first character of pattern.\n\n         Jump to the first statement of the compiler.  The pointer \"c\"\n         is on this statement.\n\n         And output the compiler to file  ( '/A-DEL' ).  The pointer \"f\"\n         is on the name of the file for the compiler output -\n\n   PROGRAMS\n\n      SYNTAX\n\n         -meta file (k=100.m=300,n=20,s=900)\n\n         file = mesdecl $declaration $procedure \"FINISH\";\n\n         procedure =\n\n           procname (\n\n              (\n\n                 type \"FUNCTION\" /\n\n                 \"PROCEDURE\" ) .id (type .id / -empty)) /\n\n              \"CO-ROUTINE\") ' /\n\n           $declaration labeledst $(labeledst ';) \"endp.\";\n\n         labeledst = ((left arrow symbol).id ': / .empty) statement;\n\n         type = \"INTEGER\" / \"REAL\" ;\n\n         procname = .id;\n\n      Functions are differentiated from procedures to aid compilers in\n      better code production and run time checks.\n\n         Functions return values.\n\n         Procedures do not return values.\n\n      Co-routines do not have names or arguments.  Their initial\n      envocation points are given the pipe declaration.\n\n      It is not clear just how global declarations are to be??\n\nDECLARATIONS\n\n   SYNTAX\n\n      declaration = numbertype / structuredtype / label / lcl2uhr /\n      uhr2rmt / pipetype;\n\n      numbertype = : (\"REAL\" / \"INTEGER\") (\"CONSTANT\" conlist /\n      varlist);\n\n      conlist =\n\n         .id '(left arrow symbol)constant\n\n         $('. .id '(left arrow symbol)constant);\n\n      varlist =\n\n         .id ('(left arrow symbol)constant / .empty)\n\n         $('. .id('(left arrow symbol)constant / .empty));\n\n      idlist = .id $('. .id);\n\n      structuredtype = (tree\" / \"pointer\" / \"buffer\" ) idlist;\n\n      label = \"LABEL1\" idlist;\n\n      pipetype = PIPE\" pairedids $(', pairedids);\n\n      pairedids = .id .id;\n\n      procname = .id;\n\n      integerv = .id;\n\n      pipename = .id;\n\n      labelv = .id;\n\n   Variables which are declared to be constant, may be put in\n   read-only memory at run time.\n\n   The label declaration is to declare cells which may contain the\n   machine addresses of labels in the program as their values.  This \n   is not the B5500 label declaration.\n\n   In the pipe declaration the first .ID of each pair is the name of\n   the pipe, the second is thke initial starting point for the pipe.\n\nARITHMETIC\n\n   SYNTAX\n\n      exp = \"IF\" conjunct \"THEN\" exp \"ELSE\" exp;\n\n      sum = term (\n\n         '+ sum /\n\n         '- sum /\n\n         -empty);\n\n      term = factor (\n\n         '* term /\n\n         '/ term /\n\n         '(up arrow symbol) term /\n\n         .empty);\n\n      factor = '- factor / bitop;\n\n      bitop = compliment (\n\n         '/' bitop /\n\n         '/'\\ bitop /\n\n         '\u0026 bitop / (\n\n         .empty);\n\n      compliment = \"--\" primary / primary;\n\n   (symbol for up arrow) means mod. and /\\ means exclusive or.\n\n   Notice that the uniary minus is allowable, and parsed so you can\n   write x*-y.\n\n   Since there is no standard convention with bitwise operators, they\n   all have the same precedence, and parentheses must be used for\n   grouping.\n\n   Compliment is the l's compliment.\n\n   It is assumed that all arithmetic and bit operations take place in\n   the mode and style of the machine running the code.  Anyone who\n   takes advantage of word lengths, two's compliment arithmetic, etc.\n   will eventually have problems.\n\nPRIMARY\n\n   SYNTAX\n\n      primary =\n\n         constant /\n\n         builtin /\n\n         variable / (\n\n         block /\n\n         '( exp ');\n\n      variable = .id (\n\n         '(symbol for left arrow) exp /\n\n         '( block ') /\n\n         .empty);\n\n      constant =  integer / real / string;\n\n      builtin =\n\n         mesinfo /\n\n         cortnin /\n\n         (\"MIN\" / \"MAX\") exp $('. exp) '/ ;\n\n   parenthesized expressions may be a series of expressions.  The\n   value of a series is the value of the last one executed at run time.\n\n   Subroutines may have one call by name argument.\n\n   Expressions may be mixed.  Strings are a big problem?  Rulifson\n   also wants to get rid of real numbers!!\n\nCONJUNCTIVE EXPRESSION\n\n   SYNTAX\n\n      conjunct = disjunct (\"AND\" conjunct / .empty);\n\n      disjunct = negation (\"OR\" negation / .empty);\n\n      negation = \"NOT\" relation / relation;\n\n      relation =\n\n         '( conjunct ') /\n\n         sum (\n\n           \"\u003c=\" sum /\n\n           \"\u003e=\" sum /\n\n           '\u003c sum /\n\n           '\u003e sum /\n\n           '= sum /\n\n           '\" sum /\n\n           .empty);\n\n   The conjunct construct is rigged in such a way that a conjunct\n   which is not a sum need not have a value, and may be evaluated\n   using jumps in the code.  Reference to the conjunct is made only\n   in places where a logical decision is called for (e.g. if and\n   while statements).\n\n   We hope that most compilers will be smart enough to skip\n   unnecessary evaluations at run time.  I.e a conjunct in which the\n   left part is false or a disjunct with the left part true need not\n   have the corresponding right part evaluated.\n\nARITHMETIC EXPRESSION\n\n   SYNTAX\n\n      statement = conditional / unconditional;\n\n      unconditional = loopst / cases / cibtrikst / uist / treest /\n      block / null / exp;\n\n      conditional = \"IF\" conjunct \"THEN\" unconditional (\n\n         \"ELSE\" conditional /\n\n         .empty);\n\n      block = \"begin\" exp $('; exp) \"end\";\n\n   An expressions may be a statement.  In conditional statements the\n   else part is optional while in expressions it is mandatory.  This\n   is a side effect of the way the left part of the syntax rules are\n   ordered.\n\nSEMI-TREE MANIPULATION AND TESTING\n\n   SYNTAX\n\n      treest = setpntr / insertpntr / deletepntr;\n\n      setpntr = \"set\" \"pointer\" pntrname \"to\" pntrexp;\n\n      pntrexp = direction pntrexp / pntrname;\n\n      insertpntr = \"insert\" pntrexp \"as\"\n\n         ((\"left\" / \"right\") \"brother\") /\n\n         ((\"first\" / \"last: ) \"daughter\") \"of\" pntrexp;\n\n      direction =\n\n         \"up\" /\n\n         \"down\" /\n\n         \"forward\" /\n\n         \"backward: /\n\n         \"head\" /\n\n         \"tail\";\n\n      plantree = \"replace\" pntrname \"with\" pntrexp;\n\n      deletepntr = \"delete: pntrname;\n\n      tree = '( tree1 ') ;\n\n      tree1 = nodename $nodename ;\n\n      nodename = terminal / '( tree1 ');\n\n      terminal = treename / buffername / point ername;\n\n      treename = id;\n\n      treedecl = \"pointer\" .id / \"tree\" .id;\n\n   Extra parentheses in tree building results in linear subcategorization,\n   just as in LISP.\n\nFLOW AND CONTROL\n\n   controlst = gost / subst / loopstr / casest;\n\n   GO TO STATEMENTS\n\n      gost = \"GO\" \"TO\" (labelv / .id);\n\n         assignlabel = \"ASSIGN\" .id \"TO\" labelv;\n\n   SUBROUTINES\n\n      subst = callst / returnst / cortnout;\n\n         callst = \"CALL\" procname (exp / .emptyu);\n\n         returnst = \"RETURN\" (exp / .empty);\n\n         cortnout = \"STUFF\" exp \"IN\" pipename;\n\n      cortnin = \"FETCH\" pipename;\n\n      FETCH is a builtin function whose value is computed by envoking\n      the named co-routine.\n\n   LOOP STATEMENTS\n\n      SYNTAX\n\n         loopst = whilest / untilst / forst;\n\n         whilest = \"WHILE\" conjunct \"DO\" statement;\n\n         untilst = \"UNTIL\" conjunct \"DO\" statement;\n\n         forst = \"FOR\" integerv '- exp (\"BY\" exp / .empty) \"TO\" exp\n\n         \"DO\" statements;\n\n      The value of while and until statements is defined to be false\n      and true (or 0 and non-zero) respectively.\n\n      For statements evaluate their initial exp, by part, and to part\n      once, at initialization time.  The running index of for\n      statements is not available for change within the loop, it may\n      only be read.  If, some compilers can take advantage of this\n      (say put it in a register) all the better.  The increment and\n      the to bound will both be rounded to integers during the\n      initialization.\n\nCASE STATEMENTS\n\n   SYNTAX\n\n      casest = ithcasest / condcasest;\n\n      ithcasest = \"ITHCASE\" exp \"OF\" \"BEGIN\" statement $(';\n      statement) \"END\";\n\n      condcasest = \"CASE\" exp \"OF\" \"BEGIN\" condcs $('; condcs)\n      \"OTHERWISE\" statement \"END\";\n\n\n      condcs = conjunct ': statement;\n\n   The value of a case statement is the value of the last case executed.\n\nEXTRA STATEMENTS\n\n   null = \"NULL\";\n\nI/O STATEMENTS\n\n   iost = messagest / dspyst ;\n\n   MESSAGES\n\n      SYNTAX\n\n         messagest = buildmes / demand;\n\n            buildmest = startmes / appendmes / sendmes;\n\n              startmes = \"start\" \"message\";\n\n              appendmes = \"append\" \"message\" \"byute\" exp;\n\n              sendmes = \"send\" \"message\";\n\n              \n           demandmes = \"demand\" \"Message\";\n\n      mesinfo =\n\n         \"get\" \"message\" \"byte\"\n\n         \"message1\" \"length\" /\n\n         \"message\" empty: '?;\n\n      mesdecl = \"message\" \"bytes\" \"are\" ,byn \"bits\" long\" '..\n\nDISPLAY BUFFERS\n\n   SYNTAX\n\n      dspyst = startbuffer / bufappend / estab;\n\n      startbuffer - \"start\" \"buffer\";\n\n      bufappend = \"append\" bufstuff $('\u0026 bufstuff);\n\n      bufstuff = :\n\n         \"parameters\" dspyparm $('. dspyparm) /\n\n         \"character\" exp /\n\n         \"string\"1 strilng /\n\n         \"vector\" (\"from\" exp ':exp / .empty) \"to\" exp '. exp /\n\n         \"position\" (onoff / .empty) \"beam\" \"to\" exp '= exp/\n\n         curve\" ;\n\n      dspyparm F :\n\n         \"intensity\" \"to\" exp /\n\n         \"character\" \"width\" \"to\" exp /\n\n         \"blink\" onoff /\n\n        \"italics\" onff;\n\n      onoff = \"on\" / \"off\";\n\n      estab = \"establish\" buffername;\n\n   LOGICAL SCREEN\n\n      The screen is taken to be a square.  The coordinates are\n      normalized from -1 to +1 on both axes.\n\n      Associated with the screen is a position register, called\n      PREG.  The register is a triple \u003cx.y.r\u003e where x and y \n      specify a point on the screen and r is a rotation in\n      radians, counter clockwise, from the x-axis.\n\n      The intensity, called INTENSITY, is a real number in the\n      range from 0 to 1.  0 is black, 1 is as light as your\n      display can go, and numbers in between specify the relative\n      log of the intensity difference.\n\n      Character frame size.\n\n      Blink bit.\n\n   BUFFER BUILDING\n\n      The terminal nodes of semi-trees are either semi-tree names\n      or display buffers.  A display buffer is a series of logical\n      entities, called bufstuff.\n\n      When the buffer is initilized, it is empty.  If no\n      parameters are initially appended, those in effect at the\n      end of the display of the last node in the semi-tree will be in\n      effect for the display of this node.\n\n      As the buffer is built, the logical entities are added to it.\n      When it is established as a buffername, the buffer is\n      closed, and further appends are prohibited.  It is only a\n      buffername has been established that it may be used in a tree\n      building statement.\n\n   LOGICAL INPUT DEVICES\n\n      Wand\n\n      Joy Stick\n\n      Keyboard\n\n      Buttons\n\n      Light Pens\n\n      Mice\n\n   AUDIO OUTPUT DEVICES\n\n   .end\n\n\nSAMPLE PROGRAMS\n\n   Program to run display and keyboard as tty.\n\n   to run NLS\n\n      input part\n\n      display part\n\n         DEMAND MESSAGE;\n\n         While LENGTH \" O DO\n\n            ITHCASE GETBYTE OF Begin\n\n            ITHCASE GETBYTE OF %file area uipdate% BEGIN\n\n               %literal area%\n\n               %message area%\n\n               %name area%\n\n               %bug%\n\n               %sequence specs%\n\n               %filter specs%\n\n               %format specs%\n\n               %command feedback line%\n\n               %filer area%\n\n               %date time%\n\n               %echo register%\n\n           BEGIN %DEL control%\n\nDISTRIBUTION LIST\n\n   Steve Carr\n      Department of Computer Science\n      University of Utah\n      Salt Lake City, Utah  84112\n      Phone 801-322-7211 X8224\n\n   Steve Crocker\n\n      Boelter Hall\n      University of California\n      Los Angeles, California\n      Phone 213-825-4864\n\n   Jeff Rulifson\n\n      Stanford Research Institute\n      333 Ravenswood\n      Menlo Park, California  94035\n      Phone 415-326-6200 X4116\n\n   Ron Stoughton\n\n      Computer Research Laboratory\n      University of California\n      Santa Barbara, California  93106\n      Phone 805-961-3221\n\n   Mehmet Baray\n\n      Corey Hall\n      University of California\n      Berkeley, California  94720\n      Phone 415-843-2621\n\n        \n\n\n"
}