{
  "series": "Request for Comments",
  "number": "62",
  "howpublished": "RFC 62",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0062",
  "url": "https://www.rfc-editor.org/info/rfc62",
  "title": "Systems for Interprocess Communication in a Resource Sharing Computer Network",
  "pagetotal": "20",
  "year": "1970",
  "month": "aug",
  "body": "\n\n\n\n\n\nNetwork Working Group                                       D. C. Walden\nRequest for Comments: 62                                        BBN Inc.\nSupercedes NWG/RFC #61                                     3 August 1970\n\n\n                A System for Interprocess Communication\n                                 in a\n                   Resource Sharing Computer Network\n\n1.  Introduction\n\n   If you are working to develop methods of communications within a\n   computer network, you can engage in one of two activities.  You can\n   work with others, actually constructing a computer network, being\n   influenced, perhaps influencing your colleagues.  Or you can\n   construct an intellectual position of how things should be done in an\n   ideal network, one better than the one you are helping to construct,\n   and then present this position for the designers of future networks\n   to study.  The author has spent the past two years engaged in the\n   first activity.  This paper results from recent engagement in the\n   second activity.\n\n   \"A resource sharing computer network is defined to be a set of\n   autonomous, independent computer systems, interconnected so as to\n   permit each computer system to utilize all of the resources of the\n   other computer systems much as it would normally call a subroutine.\"\n   This definition of a network and the desirability of such a network\n   is expounded upon by Roberts and Wessler in [9].\n\n   The actual act of resource sharing can be performed in two ways:  in\n   an ad hoc manner between all pairs of computer systems in the\n   network; or according to a systematic network-wide standard.  This\n   paper develops one possible network-wide system for resource sharing.\n\n   I believe it is natural to think of resources as being associated\n   with processes\u003c1\u003e and available only through communication with these\n   processes.  Therefore, I view the fundamental problem of resource\n   sharing to be the problem of interprocess communication.  I also\n   share with Carr, Crocker, and Cerf [2] the view that interprocess\n   communication over a network is a subcase of general interprocess\n   communication in a multi-programmed environment.\n\n   These views have led me to perform a two-part study.  First, a set of\n   operations enabling interprocess communication within a single time-\n   sharing system is constructed.  This set of operations eschews many\n   of the interprocess communications techniques currently in use within\n   time-sharing systems -- such as communication through shared memory\n   -- and relies instead on techniques that can be easily generalized to\n\n\n\nWalden                                                         [Page 1]\n\f\nRFC 62                  IPC for Resource Sharing          3 August 1970\n\n\n   permit communication between remote processes.  The second part of\n   the study presents such a generalization.  The application of this\n   generalized system to the ARPA Computer Network [9] is also\n   discussed.\n\n   The ideas enlarged upon in this paper came from many sources.\n   Particularly influential were -- 1) an early sketch of a Host\n   protocol for the ARPA Network by S. Crocker of UCLA and W. Crowther\n   of Bolt Beranek and Newman Inc. (BBN); 2) Ackerman and Plummer's\n   paper on the MIT PDP-1 time-sharing system [1]; and 3) discussions\n   with W. Crowther and R. Kahn of BBN about Host protocol, flow\n   control, and message routing for the ARPA Network.  Hopefully, there\n   are also some original ideas in this note.  I alone am responsible\n   for the collection of all of these ideas into the system described\n   herein, and I am therefore responsible for any inconsistencies or\n   bugs in the system.\n\n   It must be emphasized that this paper does not represent an official\n   BBN position on Host protocol for the ARPA Computer Network.\n\n\n2.  A System for Interprocess Communication within a Time-Sharing System\n\n   This section describes a set of operations enabling interprocess\n   communication within a time-sharing system.  Following the notation\n   of [10], I call this interprocess communication facility an IPC.  As\n   an aid to the presentation of this IPC, a model for a time-sharing\n   system is described; this model is then used to illustrate the use of\n   the interprocess communication operations.\n\n   The model time-sharing has two pieces: the monitor and the processes.\n   The monitor performs such functions as switching control from one\n   process to another process when a process has used \"enough\" time,\n   fielding hardware interrupts, managing core and the swapping medium,\n   controlling the passing of control from one process to another (i.e.,\n   protection mechanisms), creating processes,caring for sleeping\n   processes, and providing to the processes a set of machine extending\n   operations (often called Supervisor or Monitor Calls).  The processes\n   perform the normal user functions (user processes) as well as the\n   functions usually thought of as being supervisor functions in a\n   time-sharing system (systems processes) but not performed by the\n   monitor in the current model.  A typical system process is the disc\n   handler or the file system.  System processes is the disc handler or\n   the file system.  System processes are probably allowed to execute in\n   supervisor mode, and they actually execute I/O instructions and\n   perform other privileged operations that user processes are not\n   allowed to perform.  In all other ways, user and system processes are\n   identical.  For reasons of efficiency, it may be useful to think of\n\n\n\nWalden                                                         [Page 2]\n\f\nRFC 62                  IPC for Resource Sharing          3 August 1970\n\n\n   system processes as being locked in core.\n\n   Although they will be of concern later in this study, protection\n   considerations are not my concern here: instead I will assume that\n   all of the processes are \"good\" processes which never made any\n   mistakes.  If the reader needs a protection structure to keep in mind\n   while he reads this note, the capability system developed in\n   [1][3][7][8] should be satisfying.\n\n   Of the operations a process can call on the monitor to perform, six\n   are of particular interest for providing a capability for\n   interprocess communication.\n\n   RECEIVE. This operation allows a specified process to send a message\n   to the process executing the RECEIVE. The operation has four\n   parameters: the port (defined below) awaiting the message -- the\n   RECEIVE port; the port a message will be accepted from -- the SEND\n   port; a specification of the buffer available to receive the message;\n   and a location to transfer to when the transmission is complete --\n   the restart location.\n\n   SEND.  This operation sends a message from the process executing the\n   SEND to a specified process.  It has four parameters: a port to send\n   the message to -- the RECEIVE port; the port the message is being\n   sent from -- the SEND port; a specification of the buffer containing\n   the message to be sent; and the restart location.\n\n   RECEIVE ANY.  This operations allows any process to send a message to\n   the process executing the RECEIVE ANY.  The operation has four\n   parameters: the port awaiting the message -- the RECEIVE port; a\n   specification of the buffer available to receive the message; a\n   restart location; and a location where the port which sent the\n   message may be noted.\n\n   SEND FROM ANY.  This operation allows a process to send a message to\n   a process able to receive a message from any process.  It has the\n   same four parameters as SEND.  (The necessity for this operation will\n   be explained much later).\n\n   SLEEP.  This operation allows the currently running process to put\n   itself to sleep pending the completion of an event.  The operation\n   has one optional parameter, an event to be waited for.  An example\n   event is the arrival of a hardware interrupt.  The monitor never\n   unilaterally puts a process to sleep as a result of the process\n   executing one of the above four operations; however, if a process is\n   asleep when one of the above four operations is satisfied, the\n   process is awakened.\n\n\n\n\nWalden                                                         [Page 3]\n\f\nRFC 62                  IPC for Resource Sharing          3 August 1970\n\n\n   UNIQUE.  This operation obtains a unique number from the monitor.\n\n   A port is a particular data path to a process (a RECEIVE port) or\n   from a process (a SEND port), and all ports have an associated unique\n   port number which is used to identify the port.  Ports are used in\n   transmitting messages from one process to another in the following\n   manner.  Consider two processes, A and B, that wish to communicate.\n   Process A executes a RECEIVE to port N from port M.  Process B\n   executes a SEND to port N from port M.  The monitor matches up the\n   port numbers and transfers the message from process B to process A.\n   As soon as the buffer has been fully transmitted out of process B,\n   process B is restarted at the location specified in the SEND\n   operation.  As soon as the message is fully received at process A,\n   process A is restarted at the location specified in the RECEIVE\n   operation.  Just how the processes come by the correct port numbers\n   with which to communicate with other processes is not the concern of\n   the monitor -- this problem is left to the processes.\n\n   When a SEND is executed, nothing happens until a matching RECEIVE is\n   executed.  Somewhere in the monitor there must be a table of port\n   numbers associated with processes and restart locations.  The table\n   entries are cleared after each SEND/RECEIVE match is made.  If a\n   proper RECEIVE is not executed for some time, the SEND is timed out\n   after a while and the SENDing process is notified.  If a RECEIVE is\n   executed but the matching SEND does not happen for a long time, the\n   RECEIVE is timed out and the RECEIVing process is notified.\n\n   The mechanism of timing out \"unused\" table entries is of little\n   fundamental importance, merely providing a convenient method of\n   garbage collecting the table.  There is no problem if an entry is\n   timed out prematurely, because the process can always re-execute the\n   operation.  However, the timeout interval should be long enough so\n   that continual re-execution of an operation will cause little\n   overhead.\n\n   A RECEIVE ANY never times out, but may be taken back using a\n   supervisor call.  A message resultant from a SEND FROM ANY is always\n   sent immediately and will be discarded if a proper receiver does not\n   exist.  An error message is not returned and acknowledgment, if any,\n   is up to the processes.  If the table where the SEND and RECEIVE are\n   matched up ever overflows, a process originating a further SEND and\n   RECEIVE is notified just as if the SEND or RECEIVE timed out.\n\n   The restart location is an interrupt entrance associated with a\n   pseudo interrupt local to the process executing the operation\n   specifying the restart location.  If the process is running when then\n   event causing the pseudo interrupt occurs (for example, a message\n   arrives satisfying a pending RECEIVE), the effect is exactly as if\n\n\n\nWalden                                                         [Page 4]\n\f\nRFC 62                  IPC for Resource Sharing          3 August 1970\n\n\n   the hardware interrupted the process and transferred control to the\n   restart location.  Enough information is saved for the process to\n   continue execution at the point it was interrupted after the\n   interrupt is serviced.  If the process is asleep, it is readied and\n   the pseudo interrupt is saved until the process runs again and the\n   interrupt is then allowed.  Any RECEIVE or RECEIVE ANY message port\n   may thus be used to provide process interrupts, event channels,\n   process synchronization, message transfers, etc.  The user programs\n   what he wants.\n\n   It is left as an exercise to the reader to convince himself that the\n   monitor he is saddled with can be made to provide the six operations\n   described above -- most monitors can since these are only additional\n   supervisor calls.\n\n   An example.  Suppose that our model time-sharing system is\n   initialized to have several processes always running.  Additionally,\n   these permanent processes have some universally known and permanently\n   assigned ports\u003c2\u003e.  Suppose that two of the permanently running\n   processes are the logger-process and the teletype-scanner-process.\n   When the teletype-scanner-process first starts running, it puts\n   itself to sleep awaiting an interrupt from the hardware teletype\n   scanner.  The logger-process initially puts itself to sleep awaiting\n   a message from the teletype-scanner-process via well-known permanent\n   SEND and RECEIVE ports.  The teleype-scanner-process keeps a table\n   indexed by teletype number, containing in each entry a pair of port\n   numbers to use to send characters from that teletype to a process and\n   a pair of port numbers to use to receive characters for that teletype\n   from a process.  If a character arrives (waking up the teletype-\n   scanner- process) and the process does not have any entry for that\n   teletype, it gets a pair of unique numbers from the monitor (via\n   UNIQUE) and sends a message containing this pair of numbers to the\n   logger-process using the ports for which the logger-process is known\n   to have a RECEIVE pending.  The scanner-process also enters the pair\n   of numbers in the teletype table, and sends the character and all\n   future characters from this teletype to the port with the first\n   number from the port with the second number.  The scanner-process\n   must also pass a second pair of unique numbers to the logger-process\n   for it to use for teletype output and do a RECEIVE using these port\n   numbers.  When the logger-process receives the message from the\n   scanner-process, it starts up a copy of what SDS 940 TSS [6] users\n   call the executive\u003c3\u003e, and passes the port numbers to this copy of\n   the executive, so that this executive-process can also do its inputs\n   and outputs to the teletype using these ports.  If the logger-process\n   wants to get a job number and password from the user, it can\n   temporarily use the port numbers to communicate with the user before\n   it passes them on to the executive.  The scanner-process could always\n   use the same port numbers for a particular teletype as long as the\n\n\n\nWalden                                                         [Page 5]\n\f\nRFC 62                  IPC for Resource Sharing          3 August 1970\n\n\n   numbers were passed on to only one copy of the executive at a time.\n\n   It is important to distinguish between the act of passing a port from\n   one process to another and the act of passing a port number from one\n   process to another.  In the previous example, where characters from a\n   particular teletype are sent either to the logger-process or an\n   executive-process by the teletype-scanner-process, the SEND port\n   always remains in the teletype-scanner-process while the RECEIVE port\n   moves from the logger-process to the executive process.  On the other\n   hand, the SEND port number is passed between the logger-process and\n   the executive-process to enable the RECEIVE process to do a RECEIVE\n   from the correct SEND port.  It is crucial that, once a process\n   transfers a port to some other process, the first process no longer\n   use the port.  We could add a mechanism that enforces this.  The\n   protected object system of [9] is one such mechanism.  Using this\n   mechanism, a process executing a SEND would need a capability for the\n   SEND port and only one capability for this SEND port would exist in\n   the system at any given time.  A process executing a RECEIVE would be\n   required to have a capability for the RECEIVE port, and only one\n   capability for this RECEIVE port would exist at a given time.\n   Without such a protection mechanism, a port implicitly moves from one\n   process to another by the processes merely using the port at disjoint\n   times even if the port's number is never explicitly passed.\n\n   Of course, if the protected object system is available to us, there\n   is really no need for two port numbers to be specified before a\n   transmission can take place.  The fact that a process knows an\n   existing RECEIVE port number could be considered prima facie evidence\n   of the process' right to send to that port.  The difference between\n   RECEIVE and RECEIVE ANY ports then depends solely on the number of\n   copies of a particular port number that have been passed out.  A\n   system based on this approach would clearly be preferable to the one\n   described here if it was possible to assume that all autonomous\n   time-sharing systems in a network would adopt this protection\n   mechanism.  If this assumption cannot be made, it seems more\n   practical to require both port numbers.\n\n   Note that in the interprocess communication system (IPC) being\n   described here, when two processes wish to communicate they set up\n   the connection themselves, and they are free to do it in a mutually\n   convenient manner.  For instance, they can exchange port numbers or\n   one process can pick all the port numbers and instruct the other\n   process which to use.  However, in a particular implementation of a\n   time-sharing system, the builders of the system might choose to\n   restrict the processes' execution of SENDs and RECEIVEs and might\n   forbid arbitrary passing around of ports and port numbers, requiring\n   instead that the monitor be called (or some other special program) to\n   perform these functions.\n\n\n\nWalden                                                         [Page 6]\n\f\nRFC 62                  IPC for Resource Sharing          3 August 1970\n\n\n   Flow control is provided in this IPC by the simple method of never\n   starting data transmission resultant from a SEND from one process\n   until a RECEIVE is executed by the receiver.  Of course, interprocess\n   messages may also be sent back and forth suggesting that a process\n   stop sending or that space be allocated.\n\n   Generally, well-known permanently-assigned ports are used via RECEIVE\n   ANY and SEND FROM ANY.  The permanent ports will most often be used\n   for starting processes and, consequently, little data will be sent\n   via them.  If a process if running (perhaps asleep), and has a\n   RECEIVE ANY pending, then any process knowing the receive port number\n   can talk to that process without going through loggers.  This is\n   obviously essential within a local time-sharing system and seems very\n   useful in a more general network if the ideal of resource sharing is\n   to be reached.  For instance, in a resource sharing network, the\n   programs in the subroutine libraries at all sites might have RECEIVE\n   ANYs always pending over permanently assigned ports with well-known\n   port numbers.  Thus, to use a particular network resource such as a\n   matrix manipulation hardware, a process running anywhere in the\n   network can send a message to the matrix inversion subroutine\n   containing the matrix to be inverted and the port numbers to be used\n   for returning the results.\n\n   An additional example demonstrates the use of the FORTRAN compiler.\n   We have already explained how a user sits down at his teletype and\n   gets connected to an executive.  We go on from there.  The user is\n   typing in and out of the executive which is doing SENDs and RECEIVEs.\n   Eventually the user types RUN FORTRAN, and executive asks the monitor\n   to start up a copy of the FORTRAN compiler and passes to FORTRAN as\n   start up parameters the port numbers the executive was using to talk\n   to the teletype.  (This, at least conceptually, FORTRAN is passed a\n   port at which to RECEIVE characters from the teletype and a port from\n   which to SEND characters to the teletype.)  FORTRAN is, of course,\n   expecting these parameters and does SENDs and RECEIVEs via the\n   indicated ports to discover from the user what input and output files\n   the user wants to use.  FORTRAN types INPUT FILE? to the user, who\n   responds F001.  FORTRAN then sends a message to the file-system-\n   process, which is asleep waiting for something to do.  The message is\n   sent via well-known ports and it asks the file system to open F001\n   for input. The message also contains a pair of port numbers that the\n   file-system process can use to send its reply.  The file-system looks\n   up F001, opens it for input, make some entries in its open file\n   tables, and sends back to FORTRAN a message containing the port\n   numbers that FORTRAN can use to read the file.  The same procedure is\n   followed for the output file.  When the compilation is complete,\n   FORTRAN returns the teletype port numbers (and the ports) back to the\n   executive that has been asleep waiting for a message from FORTRAN,\n   and then FORTRAN halts itself.  The file-system-process goes back to\n\n\n\nWalden                                                         [Page 7]\n\f\nRFC 62                  IPC for Resource Sharing          3 August 1970\n\n\n   sleep when it has nothing else to do\u003c4\u003e.\n\n   Again, the file-system process can keep a small collection of port\n   numbers which it uses over and over if it can get file system users\n   to return the port numbers when they have finished with them.  Of\n   course, when this collection of port numbers has eventually dribbled\n   away, the file system can get some new unique numbers from the\n   monitor.\n\n\n3. A System for Interprocess Communication Between Remote Processes\n\n   The IPC described in the previous section easily generalizes to allow\n   interprocess communication between processes at geographically\n   different locations as, for example, within a computer network.\n\n   Consider first a simple configuration of processes distributed around\n   the points of a star.  At each point of the star there is an\n   autonomous operating system\u003c5\u003e.  A rather large, smart computer\n   system, called the Network Controller, exists at the center of the\n   star.  No processes can run in this center system, but rather it\n   should be thought of as an extension of the monitor of each of the\n   operating systems in the network.\n\n   If the Network Controller is able to perform the operations SEND,\n   RECEIVE, SEND FROM ANY, RECEIVE ANY, and UNIQUE and if all of the\n   monitors in all of the time-sharing systems in the network do not\n   perform these operations themselves but rather ask the Network\n   Controller to perform these operations for them, then the problem of\n   interprocess communication between remote processes if solved.  No\n   further changes are necessary since the Network Controller can keep\n   track of which RECEIVEs have been executed and which SENDs have been\n   executed and match them up just as the monitor did in the model\n   time-sharing system.  A networkwide port numbering scheme is also\n   possible with the Network Controller knowing where (i.e., at which\n   site) a particular port is at a particular time.\n\n   Next, consider a more complex network in which there is no common\n   center point, making it necessary to distribute the functions\n   performed by the Network Controller among the network nodes.  In the\n   rest of this section I will show that it is possible to efficiently\n   and conveniently distribute the functions performed by the star\n   Network Controller among the many network sites and still enable\n   general interprocess communication between remote processes.\n\n   Some changes must be made to each of the four SEND/RECEIVE operations\n   described above to adapt them for use in a distributed Network\n   Controller.  To RECEIVE is added a parameter specifying a site to\n\n\n\nWalden                                                         [Page 8]\n\f\nRFC 62                  IPC for Resource Sharing          3 August 1970\n\n\n   which the RECEIVE is to be sent.  To the SEND FROM ANY and SEND\n   messages is added a site to send the SEND to although this is\n   normally the local site.  Both RECEIVE and RECEIVE ANY have added the\n   provision for obtaining the source site of any received message.\n   Thus, when a RECEIVE is executed, the RECEIVE is sent to the site\n   specified, possibly a remote site.  Concurrently a SEND is sent to\n   the same site, normally the local site of the process executing the\n   SEND.  At this site, called the rendezvous site, the RECEIVE is\n   matched with the proper SEND and the message transmission is allowed\n   to take place from the SEND site to the site from whence the RECEIVE\n   came.\n\n   A RECEIVE ANY never leaves its originating site and therein lies the\n   necessity for SEND FROM ANY, since it must be possible to send a\n   message to a RECEIVE ANY port and not have the message blocked\n   waiting for a RECEIVE at the sending site.  It is possible to\n   construct a system so the SEND/RECEIVE rendezvous takes place at the\n   RECEIVE site and eliminates the SEND FROM ANY operation, but in my\n   judgment the ability to block a normal SEND transmission at the\n   source site more than makes up for the added complexity.\n\n   At each site a rendezvous table is kept.  This table contains an\n   entry for each unmatched SEND or RECEIVE received at that site and\n   also an entry for all RECEIVE ANYs given at that site.  A matching\n   SEND/RECEIVE pair is cleared from the table as soon as the match\n   takes place.  As in the similar table kept in the model time-sharing,\n   SEND and RECEIVE entries are timed out if unmatched for too long and\n   the originator is notified.  RECEIVE ANY entries are cleared from the\n   table when a fulfilling message arrives.\n\n   The final change necessary to distribute the Network Controller\n   functions is to give each site a portion of the unique numbers to\n   distribute via its UNIQUE operation.  I'll discuss this topic further\n   below.\n\n   To make it clear to the reader how the distributed Network Controller\n   works, an example follows.  The details of what process picks port\n   numbers, etc., are only exemplary and are not a standard specified as\n   part of the IPC.\n\n   Suppose that, for two sites in the network, K and L, process A at\n   site K wishes to communicate with process B at site L.  Process B has\n   a RECEIVE ANY pending at port M.\n\n\n\n\n\n\n\n\nWalden                                                         [Page 9]\n\f\nRFC 62                  IPC for Resource Sharing          3 August 1970\n\n\n                        SITE K                        SITE L\n\n                        ______                        ______\n                       /      \\                      /      \\\n                      /        \\                    /        \\\n                     /          \\                  /          \\\n                    /            \\                /            \\\n                   |              |              |              |\n                   |   Process A  |              |   Process B  |\n                   |              |              |              |\n                    \\            /                \\            /\n                     \\          /      RECEIVE--\u003e port M      /\n                      \\        /       ANY          \\        /\n                       \\______/                      \\______/\n\n\n   Process A, fortunately, knows of the existence of port M at site L and\n   sends a message using the SEND FROM ANY operation from port N to port\n   M.  The message contains two port numbers and instructions for process\n   B to SEND messages for process A to port P from port Q.  Site K's site\n   number is appended to this message along with the message's SEND port N.\n\n                        SITE K                        SITE L\n\n                        ______                        ______\n                       /      \\                      /      \\\n                      /        \\                    /        \\\n                     /          \\                  /          \\\n                    /            \\                /            \\\n                   |              |              |              |\n                   |   Process A  |              |   Process B  |\n                   |              |              |              |\n                    \\   port N   /                \\   port M   /\n                     \\          /---\u003eSEND FROM ---\u003e\\          /\n                      \\        /        ANY         \\        /\n                       \\______/                      \\______/\n\n                                   to port M, site L\n\n                                   containing K,N,P, \u0026 Q\n\n   Process A now executes a RECEIVE at port P from port Q.  Process A\n   specifies the rendezvous site to be site L.\n\n\n\n\n\n\n\n\nWalden                                                        [Page 10]\n\f\nRFC 62                  IPC for Resource Sharing          3 August 1970\n\n\n                        SITE K                        SITE L\n\n                        ______                        ______\n                       /      \\                      /      \\\n                      /        \\                    /        \\\n                     /          \\        Rendezvous/          \\\n                    /            \\            table            \\\n                   |              |              |              |\n                   |   Process A  |           ^  |   Process B  |\n                   |              |           |  |              |\n                    \\   port P   /            |   \\            /\n                     \\          /             |    \\          /\n                      \\        / \u003c--RECEIVE __/     \\        /\n                       \\______/     MESSAGE          \\______/\n\n                                    to site L\n\n                                    containing P, Q, \u0026 K\n\n\n   A RECEIVE message is sent from site K to site L and is entered in the\n   rendezvous table at site L.  At some other time, process B executes a\n   SEND to port P from port Q specifying site L as the rendezvous site.\n\n\n                        SITE K                        SITE L\n\n                        ______                       ______\n                       /      \\                     /      \\\n                      /        \\                   /        \\\n                     /          \\       Rendezvous/          \\\n                    /            \\           table            \\\n                   |              |             |              |\n                   |   Process A  |             |   Process B  |\n                   |              |             |              |\n                    \\   port P   /        \u003c--------- port Q   /\n                     \\          /                 \\          /\n                      \\        /        SEND       \\        /\n                       \\______/                     \\______/\n                                        to site L\n\n                                        containing P \u0026 Q\n\n   A rendezvous is made, the rendezvous table is cleared, and the\n   transmission to port P at site K takes place.  The SEND site number\n   (and conceivably the SEND port number) is appended to the messages of\n   the transmission for the edification of the receiving process.\n\n\n\n\nWalden                                                        [Page 11]\n\f\nRFC 62                  IPC for Resource Sharing          3 August 1970\n\n\n                        SITE K                         SITE L\n\n                        ______                        ______\n                       /      \\                      /      \\\n                      /        \\                    /        \\\n                     /          \\                  /          \\\n                    /            \\                /            \\\n                   |              |              |              |\n                   |   Process A  |              |   Process B  |\n                   |              |              |              |\n                    \\   port P   /                \\   port Q   /\n                     \\          /\u003c--transmission\u003c--\\          /\n                      \\        /                    \\        /\n                       \\______/   to port P, site K  \\______/\n\n                                  containing data and L\n\n   Process B may simultaneously wish to execute a RECEIVE from port N at\n   port M.\n\n   Note that there is only one important control message in this system\n   which moves between sites, the type of message that is called a\n   Host/Host protocol message in [2].  This control message is the\n   RECEIVE message.  There are two other possible intersite control\n   messages: an error message to the originating site when a RECEIVE or\n   SEND is timed out, and the SEND message in the rare case when the\n   rendezvous site is not the SEND site.  There must also be a standard\n   format for messages between ports.  For example, the following:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWalden                                                        [Page 12]\n\f\nRFC 62                  IPC for Resource Sharing          3 August 1970\n\n\n         _________________           __________________      _____________\n        | rendezvous site |  \u003c6\u003e    | destination site |    | source site |\n        |-----------------|         |------------------|    |-------------|\n        |    RECEIVE port |         |   RECEIVE port   |    | RECEIVE port|\n        |-----------------|         |------------------|    |-------------|\n        |    SEND port    |         |   SEND port      |    | SEND port   |\n        |-----------------|         |------------------|    |-------------|\n        |                 |         |   source site    |    |             |\n        |                 |         |------------------|    |             |\n        |                 |         |                  |    |             |\n        |                 |         |                  |    |             |\n        |                 |         |                  |    |             |\n        |                 |         |                  |    |             |\n        |     data        |         |     data         |    |   data      |\n        |                 |         |                  |    |             |\n        |                 |         |                  |    |             |\n        |                 |         |                  |    |             |\n        |                 |         |                  |    |             |\n        |_________________|         |__________________|    |_____________|\n         transmitted                 transmitted             received\n         by SEND                     by Network              by RECEIVE\n         process                     Controller              process\n\n   In the model time-sharing system it was possible to pass a port form\n   process to process.  This is still possible with a distributed Network\n   Controller.\n\n   Remember that, for a message to be sent from one process to another, a\n   SEND to port M from port N and a RECEIVE at port M from port N must\n   rendezvous, normally at the SEND site.  Both processes keep track of\n   where they think the rendezvous site is and supply this site as a\n   parameter of appropriate operations.  The RECEIVE process thinks it is\n   the SEND site also.  Since once a SEND and a RECEIVE rendezvous the\n   transmission is sent to the source of the RECEIVE and the entry in the\n   rendezvous table is cleared and must be set up again for each further\n   transmission from N to M, it is easy for a RECEIVE port to be moved.\n   If a process sends both the port numbers and the rendezvous site\n   number to a new process at some other site which executes a RECEIVE\n   using these same old port numbers and rendezvous site specification,\n   the SENDer never knows the RECEIVEr has moved.  It is slightly harder\n   for a send port to move.  However, if it does, the pair of port\n   numbers that has been being used for a SEND and the original\n   rendezvous site number are passed to the new site.  The process at the\n   new SEND site specifies the old rendezvous site with the first SEND\n   from the new site.  The RECEIVE process will also still think the\n   rendezvous site is the old site, so the SEND and RECEIVE will meet at\n   the old site.  When they meet, the entry in the table at that site is\n   cleared, and both the SEND and RECEIVE messages are sent to the new\n\n\n\nWalden                                                        [Page 13]\n\f\nRFC 62                  IPC for Resource Sharing          3 August 1970\n\n\n   SEND site just as if they had been destined for there in the first\n   place.  The SEND and RECEIVE then meet again at the new rendezvous\n   site and transmission may continue as if the port had never moved.\n   Since all transmissions contain the source site number, further\n   RECEIVEs will be sent to the new rendezvous site.  It is possible to\n   discover that this special manipulation must take place because a SEND\n   message is received at a site that did not originate the SEND\n   message\u003c7\u003e.  Note that the SEND port and the RECEIVE port can move\n   concurrently.\n\n   Of course, all of this could have also been done if the processes had\n   sent messages back and forth announcing any potential moves and the\n   new site numbers.\n\n   A problem that may have occurred to the reader is how the SEND and\n   RECEIVE buffers get matched for size.  The easiest solution would be\n   to require that all buffers have a common size but this is\n   unacceptable since it does not easily extend to a situation where\n   processes in autonomous operating systems are attempting to\n   communicate.  A second solution is for the processes to pass messages\n   specifying buffer sizes.  If this solution is adopted, excessive data\n   sent from the SEND process and unable to fix into the RECEIVE buffer\n   is discarded and the RECEIVE process notified.  The solution has great\n   appeal on account of its simplicity.  A third solution would be for\n   the RECEIVE buffer size to be passed to the SEND site with RECEIVE\n   message and to notify the SEND process when too much data is sent or\n   even to pass the RECEIVE buffer size on to the SEND process.  This\n   last method would also permit the Network Controller at the SEND site\n   to make two or more SENDs out of one, if that was necessary to match a\n   smaller RECEIVE buffer size.\n\n   The maintenance of unique numbers is also a problem when the processes\n   are geographically distributed.  Three solutions to this problem are\n   presented here.  The first possibility is for the autonomous operating\n   systems to ask the Network Controller for the unique numbers\n   originally and then guarantee the integrity of any unique numbers\n   currently owned by local processes and programs using whatever means\n   are at the operating system's disposal.  In this case, the Network\n   Controller would provide a method for a unique number to be sent from\n   one site to another and would vouch for the number's identity at the\n   new site.  The second method is simply to give the unique numbers to\n   the processes that are using them, depending on the non-malicious\n   behavior of the processes to preserve the unique numbers, or if an\n   accident should happen, the two passwords (SEND and RECEIVE port\n   numbers) that are required to initiate a transmission.  If the unique\n   numbers are given out in a non-sequential manner and are reasonably\n   long (say 32 bits), there is little danger.  In the final method, a\n   user identification is included in the port numbers and the individual\n\n\n\nWalden                                                        [Page 14]\n\f\nRFC 62                  IPC for Resource Sharing          3 August 1970\n\n\n   operating systems guarantee the integrity of these identification\n   bits.  Thus a process, while not able to be sure that the correct port\n   is transmitting to him, can be sure that some port of the correct user\n   is transmitting.  This is the so-called virtual net concept suggested\n   by W. Crowther [2].\u003c8\u003e\n\n   A third difficult problem arises when remote processes wish to\n   communicate, the problem of maintaining high bandwidth connections\n   between the remote processes.  The solution to this problem lies in\n   allowing the processes considerable information about the state of an\n   on-going transmission.  First, we examine a SEND process in detail.\n   When a process executes a SEND, the local portion of the Network\n   Controller passes the SEND on to the rendezvous site, normally the\n   local site.  When a RECEIVE arrives matching a pending SEND, the\n   Network Controller notifies the SEND process by causing an interrupt\n   to the specified restart location.  Simultaneously the Network\n   Controller starts shipping the SEND buffer to the RECEIVE site.  When\n   transmission is complete, a flag is set which the SEND process can\n   test.  While a transmission is taking place, the process may ask the\n   Network Controller to perform other operations, including other SENDs.\n   A second SEND over a pair of ports already in the act of transmission\n   is noted and the SEND becomes active as soon as the first transmission\n   is complete.  A third identical SEND results in an error message to\n   the SENDing process.  Next, we examine a RECEIVE process in detail.\n   When a process executes a RECEIVE, the RECEIVE is sent to the\n   rendezvous site.  When data resultant from this RECEIVE starts to\n   arrive at the RECEIVE site, the RECEIVE process is notified via an\n   interrupt to the specified restart location.  When the transmission is\n   complete, a flag is set which the RECEIVE process can test.  A second\n   RECEIVE over the same port pair is allowed.  A third results in an\n   error message to the RECEIVE process.  Thus, there is sufficient\n   machinery to allow a pair of processes always to have both a\n   transmission in progress and the next one pending.  Therefore, no\n   efficiency is lost.  On the other hand, each transmission must be\n   preceded by a RECEIVE into a specified buffer, thus continuing to\n   provide complete flow control.\n\n\n4. A Potential Application\n\n   Only one  resource sharing computer network currently exists, the\n   ARPA Computer Network.  In this section, I discuss application of the\n   system described in this paper to the ARPA Network [2][5][9].\n\n   The ARPA Network currently incorporates ten sites spread across the\n   United States.  Each site consists of one to three (potentially four)\n   independent computer systems called Hosts and one communications\n   computer system called an IMP.  All of the Hosts at a site are\n\n\n\nWalden                                                        [Page 15]\n\f\nRFC 62                  IPC for Resource Sharing          3 August 1970\n\n\n   directly connected to the IMP.  The IMPs themselves are connected\n   together by 50-kilobit phone lines (much higher rate lines are a\n   potential), although each IMP is connected to only one to five other\n   IMPs.  The IMPs provide a communications subnet through which the\n   Hosts communicate.  Data is sent through the communications subnet in\n   messages of arbitrary size (currently about 8000 bits) called network\n   messages.  When a network message is received by the IMP at the\n   destination site, that IMP sends an acknowledgment, called a RFNM, to\n   the source site.\n\n   A system for interprocess communication for the ARPA Network (let us\n   call this IPC for ARPA) is currently being designed by the Network\n   Working Group, under the chairmanship of S. Crocker of UCLA.  Their\n   design is somewhat constrained by the communications subnet [5]\u003c9\u003e.\n   I would like to compare point-by-point IPC for ARPA with the one\n   developed in this paper; however, such a comparison would first\n   require description here, almost from scratch, of the current state\n   of IPC for ARPA since very little up-to-date information about IPC\n   for ARPA appears in the open literature [2].  Also, IPC for ARPA is\n   quite complex and the working documents describing it now run to many\n   hundred pages, making any description lengthy and inappropriate for\n   this paper.\u003c10\u003e Therefore, I shall make only a few scattered\n   comparisons of the two systems, the first of which are implicit in\n   this paragraph.\n\n   The interprocess communication system being developed for the ARPA\n   Network comes in several almost distinct pieces: The Host/IMP\n   protocol, IMP/IMP protocol, and the Host/Host protocol.  The IMPs\n   have sole responsibility for correctly transmitting bits from one\n   site to another.  The Hosts have sole responsibility for making\n   interprocess connections.  Both the Host and IMP are concerned and\n   take a little responsibility for flow control and message sequencing.\n   Applications of the interprocess communication system described in\n   this paper leads me to make a different allocation of responsibility.\n   The IMP still continues to move bits from on site to another\n   correctly but the Network Controller also resides in the IMP, and\n   flow control is completely in the hands of the processes running in\n   the Hosts, although using the mechanisms provided by the IMPs.\n\n   The IMPs provide the SEND, RECEIVE, SEND FROM ANY, RECEIVE ANY, and\n   UNIQUE operations in slightly altered forms for the Hosts and also\n   maintain the rendezvous tables, including moving of SEND ports when\n   necessary.  Putting these operations in the IMP requires the\n   Host/Host protocol program to be written only once, rather than many\n   times as is currently being done in the ARPA Network.  It is perhaps\n   useful to step through the five operations again.\n\n   SEND.  The Host gives the IMP a SEND port number, a RECEIVE port\n\n\n\nWalden                                                        [Page 16]\n\f\nRFC 62                  IPC for Resource Sharing          3 August 1970\n\n\n   number, the rendezvous site, and a buffer specification (e.g., start\n   and end, or beginning and length).  The SEND is sent to the\n   rendezvous site IMP, normally the local IMP.  When a matching RECEIVE\n   arrives at the local IMP, the Host is notified of the RECEIVE port of\n   the just arrived message.  This port number is sufficient to identify\n   the SENDing process, although a given operating system may have to\n   keep internal tables mapping this port number into a useful internal\n   process identifier.  Simultaneously, the IMP begins to ask the Host\n   for specific pieces of the SEND buffer, sending these pieces as\n   network messages to the destination site.  If a RFNM is not received\n   for too long, implying a network message has been lost in the\n   network, the Host is asked for the same data again and it is\n   retransmitted.\u003c11\u003e Except for the last piece of a buffer, the IMP\n   requests pieces from the Host which are common multiplies of the word\n   size of the source Host, IMP, and destination Host.  This avoids\n   mid-transmission word alignment problems.\n\n   RECEIVE.  The Host gives the IMP a SEND port, a RECEIVE port, a\n   rendezvous site, and a buffer description.  The RECEIVE message is\n   sent to the rendezvous site.  As the network messages making up a\n   transmission arrive for the RECEIVE port, they are passed to the Host\n   along with RECEIVE port number (and perhaps the SEND port number),\n   and an indication to the Host where to put this data in its input\n   buffer.  When the last network message of the SEND buffer is passed\n   into the Host, it is marked accordingly and the Host can then detect\n   this.  (It is conceivable that the RECEIVE message could also\n   allocate a piece of network bandwidth while making its network\n   traverse to the rendezvous site.)\n\n   RECEIVE ANY.  The Host gives the IMP a RECEIVE port and a buffer\n   descriptor.  This works the same as RECEIVE but assumes the local\n   site to be the rendezvous site.\n\n   SEND FROM ANY.  The Host gives the IMP RECEIVE and SEND ports, the\n   destination site, and a buffer descriptor.  The IMP requests and\n   transmits the buffer as fast as possible.  A SEND FROM ANY for a\n   non-existent port is discarded at the destination site.\n\n   In the ARPA Network, the Hosts are required by the IMPs to physically\n   break their transmissions into network messages, and successive\n   messages of a single transmission must be delayed until the RFNM is\n   received for the previous message.  In the system described here,\n   since RFNMs are tied to the transmission of a particular piece of\n   buffer and since the Hosts allow the IMPs to reassemble buffers in\n   the Hosts by the IMP telling the Host where to put each buffer piece\n   then pieces of a single buffer can be transmitted in parallel network\n   messages and several RFNMs can be outstanding simultaneously.  This\n   enables The Hosts to deal with transmissions of more natural sizes\n\n\n\nWalden                                                        [Page 17]\n\f\nRFC 62                  IPC for Resource Sharing          3 August 1970\n\n\n   and higher bandwidth for a single transmission.\n\n   For additional efficiency, the IMP might know the approximate time it\n   takes for a RECEIVE to get to a particular other site and warn the\n   Host to wake up a process shortly before the arrival of a message for\n   that process is imminent.\n\n\n   5. Conclusion\n\n   Since the system described in this paper has not been implemented, I\n   have no clearly demonstrable conclusions nor any performance reports.\n   Instead, I conclude with four openly subjective claims.\n\n   1) The interprocess communication system described in Section 2 is\n   simpler and more general than most existing systems of equivalent\n   power and is more powerful than most intra time-sharing system\n   communication systems currently available.\n\n   2) Time-sharing systems structured like the model in Section 2 should\n   be studied by designers of time-sharing systems who may see a\n   computer network in their future, as structure seems to enable\n   joining a computer network with a minimum of difficulty.\n\n   3) As computer networks become more common, remote interprocess\n   communication systems like the one described in Section 3 should be\n   studied.  The system currently being developed for ARPA is a step in\n   the wrong direction, being addressed, in my opinion, more to\n   communication between monitors than to communication between\n   processes and consequently subverting convenient resource sharing.\n\n   4) The application of the system as described in Section 4 is much\n   simpler to implement and more powerful than the system currently\n   being constructed for the ARPA Network, and I suggest that\n   implementation of my method be seriously considered for adoption by\n   the ARPA Network.\n\n\n \u003cFootnotes\u003e\n\n    1. Almost any of the common definitions of a process would suit the\n       needs of this paper.\n\n    2. Or perhaps there is only one permanently known port, which\n       belongs to a directory-process that keeps a table of\n       permanent-process/well-know-port associations.\n\n    3. That program which prints file directories, tells who is on other\n\n\n\nWalden                                                        [Page 18]\n\f\nRFC 62                  IPC for Resource Sharing          3 August 1970\n\n\n       teletypes, runs subsystems, etc.\n\n    4. The reader should have noticed by now that I do not like to think\n       of a new process (consisting of a new conceptual copy of a\n       program) being started up each time another user wishes to use\n       the program.  Rather, I like to think of the program as a single\n       process which knows it is being used simultaneously by many other\n       processes and consciously multiplexes among the users or delays\n       service to users until it can get around to them.\n\n    5. I use operating system rather than time-sharing system in this\n       section to point up the fact that the autonomous systems at the\n       network nodes may be either full blown time-sharing systems in\n       their own right, and individual process in a larger\n       geographically distributed time-sharing system, or merely\n       autonomous sites wishing to communicate.\n\n    6. For a SEND FROM ANY message, the rendezvous site is the\n       destination site.\n\n    7. For readers familiar with the once-proposed re-connection scheme\n       for the ARPA Network, the above system is simple, comparatively,\n       because there are no permanent connections to break and move;\n       that is, connections only exist fleetingly in the system\n       described here and can therefore be remade between any pair of\n       processes which at any time happen to know each other's port\n       numbers and have some clue where they each are.\n\n    8. Crowther says this is not the virtual net concept.\n\n    9. As one of the builders of the ARPA communications subnet, I am\n       partially responsible for these constraints.\n\n   10. The reader having access to the ARPA working documents may want\n       to read Specifications for the Interconnection of a Host to\n       an IMP, BBN Report No. 1822; and ARPA Network Working Group\n       Notes #36, 37, 38, 39, 42, 44, 46, 47, 48, 49, 50, 54, 55, 56,\n       57, 58, 59, 60.\n\n   11. This also allows messages to be completely thrown away by the IMP\n       subnet it that should ever be useful.\n\n\n [REFERENCES]\n\n    1.  Ackerman, W., and Plummer, W.  An implementation of a\n            multi-processing computer system.  Proc. ACM Symp. on\n            Operating System Principles, Gatlinsburg, Tenn.,\n\n\n\nWalden                                                        [Page 19]\n\f\nRFC 62                  IPC for Resource Sharing          3 August 1970\n\n\n            Oct. 1-4, 1967.\n\n    2.  Carr, C. Crocker, S., and Cerf, V.  Host/Host communication\n            protocol in the ARPA network.  Proc. AFIPS 1970 Spring\n            Joint Comput. Conf., Vol. 36, AFIPS Press, Montvale, N.J.,\n            pp. 589-597.\n\n    3.  Dennis, J., and VanHorn, E.  Programming semantics for\n            multiprogrammed computations.  Comm. ACM 9, 3 (March,\n            1966), 143-155.\n\n    4.  Hansen, P.B.  The nucleus of a multiprogramming system.  Comm.\n            ACM 13, 4 (April, 1970), 238-241, 250.\n\n    5.  Heart, F., Kahn, R., Ornstein, S., Crowther, W., and Walden, D.\n            The interface message processor for the ARPA computer\n            network.  Proc. AFIPS 1970 Spring Joint Comput. Conf., Vol.\n            36, AFIPS Press, Montvale, N.J., pp. 551-567.\n\n    6.  Lampson, B.  SDS 940 Lectures, circulated informally.\n\n    7.  _______.  An overview of the CAL time-sharing system.  Computer\n            Center, University of California, Berkeley, Calif.\n\n    8.  _______.  Dynamic protection structures.  Proc.  AFIPS 1969 Fall\n            Joint Comput. Conf., Vol. 35, AFIPS Press, Montvale, N.J.,\n            pp. 27-38.\n\n    9.  Roberts, L., and Wessler, B.  Computer network development to\n            achive resource sharing.  Proc.  AFIPS 1970 Spring Joint\n            Comput. Conf., Vol. 36, AFIPS Press, Monvale, N.J., pp.\n            543-549.\n\n   10.  Spier, M., and Organick, E.  The MULTICS interprocess\n            communication facility.  Proc. ACM Second Symp. on Operating\n            Systems Principles, Princeton University, Oct. 20-22, 1969.\n\n\n\nAuthor's Address\n\n   D. C. Walden\n   Bolt Bernakek and Newman, Inc.\n   Cambridge, Massachusetts\n\n\n        [ This RFC was put into machine readable form for entry ]\n        [ into the online RFC archives by Adam Costello 3/97 ]\n\n\nWalden                                                        [Page 20]\n\f\n"
}