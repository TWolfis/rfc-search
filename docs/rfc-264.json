{
  "series": "Request for Comments",
  "number": "264",
  "howpublished": "RFC 264",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0264",
  "url": "https://www.rfc-editor.org/info/rfc264",
  "title": "The Data Transfer Protocol",
  "pagetotal": "9",
  "year": "1972",
  "month": "jan",
  "body": "\n\n\n\n\n\nNetwork Working Group                                         A. Bhushan\nRequest for Comments: 264                                            MIT\nNIC: 7812                                                      B. Braden\n                                                                    UCLA\n                                                             W. Crowther\n                                                                     BBN\n                                                              E. Harslem\n                                                              J. Heafner\n                                                                    Rand\n                                                             A. McKenzie\n                                                                     BBN\n                                                               J. Melvin\n                                                                     SRI\n                                                             B. Sundberg\n                                                                 Harvard\n                                                               D. Watson\n                                                                     SRI\n                                                                J. White\n                                                                    UCSB\n                                                        15 November 1971\n\n\n                       THE DATA TRANSFER PROTOCOL\n\n   This paper is a revision of RFC 171, NIC 6793.  The changes to RFC\n   171 are given below.  The protocol is then restated for your\n   convenience.\n\nCHANGES TO RFC 171\n\n   1) The sequence number field is changed to 16 bits in the error (Type\n      B5) transactions, thus resolving the ambiguity in the previous\n      specification.  In addition, the information separators (Type B4)\n      transactions shall also contain a 16-bit sequence number field.\n\n   2) The modes available (Type B3) transactions shall define only the\n      modes available for receive, instead of both receive and send.  In\n      simplex connections modes available transactions should not be\n      sent as they are meaningless.  In full-duplex connections, the\n      modes available transactions are still required.\n\n   3) The code assignments for \"End Code\" in information separators and\n      for \"function\" in abort transactions have been changed to reflect\n      a numerical order rather than \"bit-coding\".\n\n   4) Minor editorial changes.\n\n\n\n\n\nBhushan, et. al.                                                [Page 1]\n\f\nRFC 264                The Data Transfer Protocol       15 November 1971\n\n\nI.  INTRODUCTION\n\n      A common protocol is desirable for data transfer in such diverse\n      applications as remote job entry, file transfer, network mail\n      system, graphics, remote program execution, and communication with\n      block data terminals (such as printers, card, paper tape, and\n      magnetic tape equipment, especially in context of terminal IMPs).\n      Although it would be possible to include some or even all of the\n      above applications in an all-inclusive file transfer protocol, a\n      separation between data transfer and application functions may\n      provide flexibility in implementation, and reduce complexity.\n      Separating the data transfer function from the specific\n      applications functions may also reduce proliferation of programs\n      and protocols.\n\n      We have therefore defined a data transfer protocol (DTP) which\n      should be used for transfer of data in file transfer, remote job\n      entry, and other applications protocols.  This paper concerns\n      itself only with the data transfer protocol.  A companion paper\n      (RFC 265) describes the file transfer protocol.\n\nII.  DISCUSSION\n\n      The data transfer protocol (DTP) serves three basic functions.  It\n      provides for convenient separation of NCP messages into \"logical\"\n      blocks (transactions, units, records, groups, and files), it\n      allows for the separation of data and control information, and it\n      includes some error control mechanisms.\n\nTransfer Modes\n\n      Three modes of separating messages into transactions [1] are\n      allowed by DTP.  The first is an indefinite bit stream which\n      terminates only when the connection is closed (i.e., the bit\n      stream represents a single transaction for duration of\n      connection).  This mode would be useful in data transfer between\n      hosts and terminal IMPs (TIPs).\n\n      The second mode utilizes a \"transparent\" block convention, similar\n      to the ASCII DLE (Data Link Escape) convention.  In \"transparent\"\n      mode, transactions (which may be arbitrarily long) end whenever\n      the character sequence DLE ETX is encountered (DLE and ETX are 8-\n      bit character codes).  To prevent the possibility of a DLE ETX\n      sequence occurring within data stream, any occurrence of DLE is\n      replaced by DLE DLE on transmission.  The extra DLE is stripped on\n      reception.  A departure from the ASCII convention is that\n\n\n\n\n\nBhushan, et. al.                                                [Page 2]\n\f\nRFC 264                The Data Transfer Protocol       15 November 1971\n\n\n      \"transparent\" block does not begin with DLE STX, but with a\n      transaction type byte.  This mode would be useful in data transfer\n      between terminal IMPs.\n\n      The third mode utilizes a count mechanism.  Each transaction\n      begins with a fixed-length descriptor field containing separate\n      binary counts of information bits and filler (i.e., not\n      information) bits.  If a transaction has no filler bits, its\n      filler count is zero.  This mode would be useful in most host-to-\n      host data transfer applications.\n\n      DTP allows for transfer modes to be intermixed over the same\n      connection (i.e., the transfer mode is not associated with\n      connection, but only with transaction).  The transfer modes can\n      represent transfer of either data or control information.  The\n      protocol allows for separating data and control information at a\n      lower level, by providing different \"type\" codes (see\n      SPECIFICATIONS) for data and control transactions.  This provision\n      may simplify some implementations.\n\n      The implementation of a subset of transfer modes is specifically\n      permitted by DTP.  To provide compatibility between hosts using\n      different subsets of transfer modes, an initial \"handshake\"\n      procedure may be used.  The handshake involves exchanging\n      information on modes available for receive.  This will enable host\n      programs to agree on transfer modes acceptable for a connection.\n\nUsing DTP\n\n      The manner in which DTP is used would depend largely on the\n      applications protocol.  It is the applications protocol which\n      defines the use of transfer modes and the use of information\n      separator and abort functions provided in DTP (see\n      SPECIFICATIONS).  For example, in a remote job entry protocol,\n      aborts may be used to stop the execution of a job, while they may\n      not cause any action in another applications protocol.\n\n      It should also be noted that DTP does not define a data transfer\n      service.  There is no standard server socket, or initial\n      connection protocol defined for DTP.  What DTP defines is a\n      mechanism for data transfer which can be used to provide services\n      for block data transfers, file transfers, remote job entry,\n      network mail and other applications.\n\n      There are to be no restrictions on the manner in which DTP is\n      implemented at various sites.  For example, DTP may be imbedded in\n      an applications program such as for file transfer, or it may be a\n      separate service program or subroutine used by several\n\n\n\nBhushan, et. al.                                                [Page 3]\n\f\nRFC 264                The Data Transfer Protocol       15 November 1971\n\n\n      applications programs.  Another implementation may employ macros\n      or UUO's (unimplemented user operations on PDP-10's), to achieve\n      the functions specified in DTP.  It is also possible that in\n      implementation, the separation between the DTP and applications\n      protocols be only at a conceptual level.\n\nIII.  SPECIFICATIONS\n\n   1.    Byte Size for Network Connection\n\n         The standard byte size for network connections using DTP is 8\n         bits.  However, other byte sizes specified by applications\n         protocols are also allowed by DTP.  For the purpose of this\n         document bytes are assumed to be 8-bits, unless otherwise\n         stated.\n\n   2.    Transactions\n\n         At DTP level, all information transmitted over a connection is\n         a sequence of transactions.  DTP defines the rules for\n         delimiting transactions.\n\n   2A.   Types\n\n         The first 8-bit byte of each transaction shall define a\n         transaction type, as shown below.  (Note that code assignments\n         do not conflict with assignments in TELNET protocol.)  The\n         transaction types will be referred to by the hexadecimal code\n         assigned to them.  (The transaction types are discussed in more\n         detail in Section 2B.)\n\n            Code                    Transaction Type\n         Hex     Octal\n\n         B0      260             Indefinite bit stream -- data.\n         B1      261             Transparent (DLE) block--data.\n         B2      262             Descriptor and counts--data.\n         B3      263             Modes available (handshake).\n         B4      264             Information Separators.\n         B5      265             Error codes.\n         B6      266             Abort.\n         B7      267             No operation (NoOp).\n         B8      270             Indefinite bit stream--control.\n         B9      271             Transparent (DLE) block--control.\n         BA      272             Descriptor and counts--control.\n         BB      273\n         through through         Unassigned but reserved for DTP.\n         BF      277\n\n\n\nBhushan, et. al.                                                [Page 4]\n\f\nRFC 264                The Data Transfer Protocol       15 November 1971\n\n\n   2B.  Syntax and Semantics\n\n   2B.1  Type B0 and B8 (indefinite bitstream modes) transactions\n         terminate only when the NCP connection is \"closed\".  There is\n         no other escape convention defined in DTP at this level.  It\n         should be noted that the closing of a connection in bitstream\n         mode is an implicit file separator (see Section 2B.5).\n\n   2B.2  Type B1 and B9 (transparent block modes) transactions terminate\n         when the byte sequence DLE ETX is encountered.  The sender\n         shall replace any occurrence of DLE in data stream by the\n         sequence DLE DLE.  The receiver shall strip the extra DLE.  The\n         transaction is assumed to be byte-oriented.  The code for DLE\n         is Hex '90' or Octal '220' (this is different from the ASCII\n         DLE which is Hex '10' or Octal '020).  [2] ETX is Hex '03' or\n         Octal '03' (the same as ASCII ETX).\n\n   2B.3  Type B2 and BA (descriptor and counts modes) transactions have\n         three fields, a 9-byte (72-bit) descriptor field (as shown\n         below) and variable length (including zero) info and filler\n         fields.  The total length of a transaction is (72+info+filler)\n         bits.\n\n  |\u003cB2 or BA\u003e|\u003cInfo count\u003e| \u003cNUL\u003e \u003cSequence #\u003e| \u003cNUL\u003e |\u003cfiller count\u003e|\n  |\u003c-8-bit-\u003e |\u003c--24-bit--\u003e|\u003c8-bit\u003e\u003c--16-bit--\u003e|\u003c8-bit\u003e|\u003c---8-bit----\u003e|\n  |\u003c--------------------72-bit descriptor field---------------------\u003e|\n\n         _Info count_ is a binary count of the number of bits in the\n         info field, not including descriptor or filler bits.  The\n         number of info bits is limited to (2**24 - 1), as there are 24\n         bits in info count field.\n\n         _Sequence #_ is a sequential count in round-robin manner of B2,\n         BA, and B4 type transactions.  The inclusion of sequence\n         numbers will help in debugging and error control, as sequence\n         numbers may be used to check for missing transactions and aid\n         in locating errors.  Hosts not wishing to implement this\n         mechanism should have all 1's in the field.  The count shall\n         start from zero and continue sequentially to all 1's, after\n         which it is reset to all zeros.  The permitted sequence numbers\n         are one greater than the previous, all 1's, and zero for the\n         first transaction only.\n\n         _Filler count_ is a binary count of bits used as fillers (i.e.,\n         not information) after the end of meaningful data.  Number of\n         filler bits is limited to 255, as there are 8 bits in filler\n         count field.\n\n\n\n\nBhushan, et. al.                                                [Page 5]\n\f\nRFC 264                The Data Transfer Protocol       15 November 1971\n\n\n         The NUL bytes must contain all 0's.\n\n   2B.4  Type B3 (modes available) transactions have a fixed length of\n         two bytes, as shown below.  First byte defines the transaction\n         type B3, and second byte defines the transfer modes available\n         for receive.\n\n         +-----------------+---------------------+\n         |Type             |     I receive       |\n         |        B3       |                     |\n         |                 |0|0|BA|B2|B9|B1|B8|B0|\n         +-----------------+---------------------+\n\n         The modes are indicated by bit-coding, as shown above.  The\n         particular bits, if set to logical \"1\", indicate that the\n         corresponding modes are handled by the sender's receive side.\n         The two most significant bits should be set to logical \"0\".\n         Mode available transactions have no significance in a simplex\n         connection.  The use of type B3 transactions is discussed in\n         section 3B.\n\n   2B.5  Type B4 (information separator) transactions have a fixed\n         length of four bytes, as shown below.  First byte defines the\n         transaction type B4, second byte defines the separator, and\n         third and fourth bytes contain a 16-bit sequence number.\n\n         +------------+------------+-------------------------+\n         |Type        |  End Code  |      Sequence Number    |\n         |     B4     |            |            |            |\n         |            |            |            |            |\n         +------------+------------+------------+------------+\n\n         The following separator codes are assigned:\n\n               Code                      Meaning\n         Hex             Octal\n\n         01              001             Unit separator\n         02              002             Record separator\n         03              003             Group separator\n         04              004             File separator\n\n         Files, groups, records, and units may be data blocks that a\n         user defines to be so.  The only restriction is that of the\n         hierarchical relationship File\u003eGroups\u003eRecords\u003eUnits (where '\u003e'\n         means 'contains').  Thus a file separator marks not only the\n         end of file, but also the end of group, record, and unit.\n\n\n\n\nBhushan, et. al.                                                [Page 6]\n\f\nRFC 264                The Data Transfer Protocol       15 November 1971\n\n\n         These separators may provide a convenient \"logical\" separation\n         of data at the data transfer level.  Their use is governed by\n         the applications protocol.\n\n   2B.6  Type B5 (error codes) transactions have a fixed length of four\n         bytes, as shown below.  First byte defines the transaction type\n         B5, second byte indicates an error code, and third and fourth\n         bytes may indicate the sequence number of a transaction in\n         which an error occurred.\n\n         +------------+------------+-------------------------+\n         |Type        |  End Code  |      Sequence Number    |\n         |     B5     |            |            |            |\n         |            |            |            |            |\n         +------------+------------+------------+------------+\n\n         The following error codes are assigned:\n\n             Error Code            Meaning\n         Hex             Octal\n\n         00              000       Undefined error\n         01              001       Out of sync. (type code other\n                                   than B0 through BF).\n         02              002       Broken sequence (the sequence # field\n                                   contains the first expected but not\n                                   received sequence number).\n         03              003       Illegal DLF sequence (other than DLE\n                                   DLE or DLE FTX).\n         B0              260\n         through         through   The transaction type (indicated by\n         BF              277       by error code) is not implemented.\n\n         The error code transaction is defined only for the purpose of\n         error control.  DTP does not require the receiver of an error\n         code to take any recovery action.  The receiver may discard the\n         error code transaction.  In addition, DTP does not require that\n         sequence numbers be remembered or transmitted.\n\n   2B.7  Type B6 (abort) transactions have a fixed length of two bytes,\n         as shown below.  First byte defines the transaction type B6,\n         and second byte defines the abort function.\n\n         +------------+------------+\n         |Type        |  Function  |\n         |     B6     |            |\n         |            |            |\n         +------------+------------+\n\n\n\nBhushan, et. al.                                                [Page 7]\n\f\nRFC 264                The Data Transfer Protocol       15 November 1971\n\n\n         The following abort codes are assigned:\n\n             Abort Code                  Meaning\n         Hex             Octal\n\n         00              000             Abort preceding transaction\n         01              001             Abort preceding unit\n         02              002             Abort preceding record\n         03              003             Abort preceding group\n         04              004             Abort preceding file\n\n         DTP does not require the receiver of an abort to take specific\n         action, therefore a sender should not make any assumptions\n         thereof.  The manner in which abort is handled is to be\n         specified by higher-level applications protocols.\n\n   2B.8  Type B7 (NoOp) transactions are one byte (8-bit) long, and\n         indicate no operation.  These may be useful as fillers when the\n         byte size used for network connections is other than 8-bits.\n\n   3.    Initial Connection, Handshake and Error Recovery\n\n   3A.   DTP does not specify the mechanism used in establishing\n         connections.  It is up to the applications protocol (e.g., file\n         transfer protocol) to choose the mechanism which suits its\n         requirements. [3]\n\n   3B.   The first transaction after a full-duplex connection is made\n         will be type B3 (modes available) indicating the transfer modes\n         available for receive.  The modes available (Type B3)\n         transaction is not applicable in simplex connections.  It is\n         the sender's responsibility to choose a mode acceptable to the\n         receiver. [4]  If an acceptable mode is not available or if\n         mode chosen is not acceptable, the connection may be closed.\n\n   3C.   No error recovery mechanisms are specified by DTP.  The\n         applications protocol may implement error recovery and further\n         error control mechanisms.\n\n\n\n\n\n\n\n\n\n\n\n\n\nBhushan, et. al.                                                [Page 8]\n\f\nRFC 264                The Data Transfer Protocol       15 November 1971\n\n\nEndnotes\n\n   [1]  The term transaction is used here to mean a block of data\n   defined by the transfer mode.\n\n   [2]  This assignment was made to be consistent with the TELNET\n   philosophy of maintaining the integrity of the 128 Network ASCII\n   characters.\n\n   [3]  It is, however, recommended that the standard Initial Connection\n   Protocol as specified in RFC 165 or any subsequent standard document\n   be adopted where feasible.\n\n   [4]  It is suggested that when available, the sender should choose\n   'descriptor and count' mode (Type B2 or BA).  The 'indefinite\n   bitstream' mode (Type B0 or B8) should be chosen only when the other\n   two modes are not available.\n\n\n\n\n\n\n\n\n\n         [ This RFC was put into machine readable form for entry ]\n            [ into the online RFC archives by Ryan Kato 6/01 ]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBhushan, et. al.                                                [Page 9]\n\f\n"
}