{
  "series": "Request for Comments",
  "number": "138",
  "howpublished": "RFC 138",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0138",
  "url": "https://www.rfc-editor.org/info/rfc138",
  "title": "Status report on proposed Data Reconfiguration Service",
  "pagetotal": "23",
  "year": "1971",
  "month": "apr",
  "day": "1",
  "body": "\n\n\n\n\n\nNetwork Working Group                                       Bob Anderson\nRequest for Comments: 138                                           Rand\nNIC 6715                                                       Vint Cerf\n                                                                    UCLA\n                                                            Eric Harslem\n                                                            John Heafner\n                                                                    Rand\n                                                              Jim Madden\n                                                          U. of Illinois\n                                                            Bob Metcalfe\n                                                                     MIT\n                                                           Arie Shoshani\n                                                                     SDC\n                                                               Jim White\n                                                                    UCSB\n                                                              David Wood\n                                                                   Mitre\n                                                           28 April 1971\n\n         STATUS REPORT ON PROPOSED DATA RECONFIGURATION SERVICE\n\n                                 CONTENTS\n     I.  INTRODUCTION .................................    2\n\n         Purpose of this RFC ..........................    2\n         Motivation ...................................    2\n\n    II.  OVERVIEW OF DATA RECONFIGURATION SERVICE .....    3\n\n         Elements of Data Reconfiguration Service .....    3\n         Conceptual Network Connections ...............    3\n         Connection Protocols and Message Formats .....    4\n         Example Connection Configurations ............    6\n\n   III.  THE FORM MACHINE .............................    7\n\n         Input/Output Stream and Forms ................    7\n         Form Machine BNF Syntax ......................    7\n         Alternate Specification of Form Machine Syntax    8\n         Forms ........................................    9\n         Rules ........................................   10\n         Terms ........................................   10\n\n           Term Format 1 ..............................   11\n           Term Format 2 ..............................   11\n           Term Format 3 ..............................   13\n           Term Format 4 ..............................   13\n           Application of a Term ......................   14\n\n\n\nAnderson, et al.                                                [Page 1]\n\f\nRFC 138               Data Reconfiguration Service          April 1971\n\n\n           Restrictions and Interpretations of\n             Term Functions ...........................   14\n         Term and Rule Sequencing .....................   16\n\n    IV.  EXAMPLES .....................................   16\n\n         Remarks ......................................   16\n         Field Insertion ..............................   17\n         Deletion .....................................   17\n         Variable Length Records ......................   17\n         String Length Computation ....................   18\n         Transposition ................................   18\n         Character Packing and Unpacking ..............   18\n\n     V.  PROPOSED USES OF DATA RECONFIGURATION SERVICE    19\n\n    VI.  IMPLEMENTATION PLANS .........................   20\n\n   Appendix A .........................................   21\n\n         Note 1 to the DRS Working Group ..............   21\n         Note 2 to the DRS Working Group ..............   22\n\nI.  INTRODUCTION\n\n   PURPOSE OF THIS RFC\n\n   The purpose of this RFC is to describe, in part, a proposed Network\n   experiment and to solicit comments on any aspect of the experiment.\n   The experiment involves a software mechanism to reformat Network data\n   streams.  The mechanism can be adapted to numerous Network\n   application programs.  We hope that the results of the experiment\n   will lead to a further standard service that embodies the principles\n   described in this RFC.   We would like comments on the\n   appropriateness of this work as a Network experiment and also\n   comments on particular Network data reformatting needs that could not\n   easily be accomplished using these techniques.\n\nMOTIVATION\n\n   Application programs require specific data I/O formats yet the\n   formats are different from program to program.  We take the position\n   that the Network should adapt to the individual program requirements\n   rather than changing each program to comply with a standard.  This\n   position doesn't preclude the use of standards that describe the\n   formats of regular message contents; it is merely an interpretation\n   of a standard as being a desirable mode of operation but not a\n   necessary one.\n\n\n\nAnderson, et al.                                                [Page 2]\n\f\nRFC 138               Data Reconfiguration Service          April 1971\n\n\n   In addition to differing program requirements, a format mismatch\n   problem occurs where users wish to employ many different kinds of\n   consoles to attach to a single service program.  It is desirable to\n   have the Network adapt to individual console configurations rather\n   than requiring unique software packages for each console\n   transformation.\n\n   One approach to providing adaptation is for those sites with\n   substantial computing power to offer a data reconfiguration service;\n   a proposed example of such a service is described here.\n\n   The envisioned modus operandi of the service is that an applications\n   programmer defines _forms_ that describe data reconfigurations.  The\n   service stores the forms by name.  At a later time, a user (perhaps a\n   non-programmer) employs the service to accomplish a particular\n   transformation of a Network data stream, simply by calling the form\n   by name.\n\n   We have attempted to provide a notation tailored to some specifically\n   needed instances of data reformatting while keeping the notation and\n   its underlying implementation within some utility range that is\n   bounded on the lower end by a notation expressive enough to make the\n   experimental service useful, and that is bounded on the upper end by\n   a notation short of a general purpose programming language.\n\n\nII.  OVERVIEW OF THE DATA RECONFIGURATION SERVICE\n\nELEMENTS OF THE DATA RECONFIGURATION SERVICE\n\n   An implementation of the Data Reconfiguration Service (DRS) includes\n   modules for connection protocols, a handler of some requests that can\n   be made of the service, a compiler and/or interpreter (called the\n   Form Machine) to act on those requests, and a file storage module for\n   saving and retrieving definitions of data reconfigurations (forms).\n   This section highlights connection protocols and requests.  The next\n   section covers the Form Machine language in some detail.  File\n   storage is not described in this document because it is transparent\n   to the use of the service and its implementation is different at each\n   DRS host.\n\nCONCEPTUAL NETWORK CONNECTIONS\n\n   There are three conceptual Network connections to the DRS, see Fig.\n   1.\n\n         1)  The control connection (CC) is between an originating user\n             and the DRS.  A form specifying data reconfiguration is\n\n\n\nAnderson, et al.                                                [Page 3]\n\f\nRFC 138               Data Reconfiguration Service          April 1971\n\n\n             defined over this connection and is applied to data passing\n             over the two connections described below.\n         2)  The user connection (UC) is between a user process and the\n             DRS.\n         3)  The server connection (SC) is between the DRS and the\n             serving process.\n\n   Since the goal is to adapt the Network to user and server processes,\n   a minimum of requirements are imposed on the UC and SC.\n\n\n      +-------------+   CC   +-----------+   SC   +-----------+\n      | ORIGINATING +--------+    DRS    +--------+ SERVER    |\n      |    USER     |   ^    |           |    ^   | PROCESS   |\n      +-------------+   |    +------+----+    |   +-----------+\n                        |          /          |\n                     Telnet       / \u003c------ Simplex or Duplex\n                    Protocol   UC/            Connections\n                   Connection   /\n                               /\n                        +-----+-----+\n                        | USER      |\n                        | PROCESS   |\n                        +-----------+\n\n                Figure 1.  DRS Network Connections\n\n\nCONNECTION PROTOCOLS AND MESSAGE FORMATS\n\n   Over a control connection the dialog is directly between an\n   originating user and the DRS.  Here the user is defining forms or\n   assigning forms to connections for reformatting.\n\n   The user connects to the DRS via the initial connection protocol\n   (ICP) specified in NWG/RFC #80, version 1.  Rather than going through\n   a logger, the user calls on a particular socket on which the DRS\n   always listens.  DRS switches the user to another socket pair.\n\n   Messages sent over a control connection are of the types and formats\n   to be specified for TELNET.  Thus, a user at a terminal should be\n   able to connect to a DRS via his local TELNET, for example, as shown\n   in Fig.  2.\n\n\n\n\n\n\n\n\nAnderson, et al.                                                [Page 4]\n\f\nRFC 138               Data Reconfiguration Service          April 1971\n\n\n                                          +--------------+\n                         +--------+  CC   |              |\n                 +-------+ TELNET +-------+     DRS      |\n                 |       +--------+       |              |\n                 |                        +--------------+\n      +----------+---------+\n      |      USER          |\n      |(TERMINAL OR PROGRAM|\n      +--------------------+\n\n           Figure 2.  A TELNET Connection to DRS\n\n   When a user connects to DRS he supplies a six-character user ID (UID)\n   as a qualifier to guarantee the uniqueness of his form names.  He\n   will have (at least) the following commands:\n\n         1.  DEFFORM (name)\n         2.  ENDFORM (name)\n\n             These two commands define a form, the text of which is\n             chronologically entered between them.  The (name) is six\n             characters.  The form is stored in the DRS local file\n             system.\n\n         3.  PURGE (name)\n\n             The named form, as qualified by the current UID, is purged\n             from the DRS file system.\n\n         4.  LISTNAMES (UID)\n\n             The unqualified names of all forms assigned to UID are\n             returned.\n\n         5.  LISTFORM (name)\n\n             The source text of a named form is returned.\n\n         6.  DUPLEXCONNECT (user site, user send, user receive,\n                        user method, server site, server\n                        send, server receive, server method,\n                        user-to-server form, server-to-user form)\n\n         7.  SIMPLEXCONNECT (send site, send socket, send\n                          method, receive site, receive\n                          socket, receive method, form)\n\n\n\n\n\nAnderson, et al.                                                [Page 5]\n\f\nRFC 138               Data Reconfiguration Service          April 1971\n\n\n   Either one, both, or neither of the two parties specified in 6 or 7\n   may be at the same host as the party issuing the request.  Sites and\n   sockets specify user and server for the connection.  Method indicates\n   the way in which the connection is established.  Three options are\n   provided:\n        1)  Site/socket already connected to DRS as a dummy\n            control connection.  (A dummy control connection\n            should not also be the real control connection.)\n        2)  Connect via standard ICP. (Only for command no. 6.)\n        3)  Connect directly via STR, RTS.\n\nEXAMPLE CONNECTION CONFIGURATIONS\n\n   There are basically two modes of DRS operation: 1) the user wishes to\n   establish a DRS UC/SC connection(s) between two programs and 2) the\n   user wants to establish the same connection(s) where he (his\n   terminal) is at the end of the UC or the SC.  The latter case is\n   appropriate when the user wishes to interact from his terminal with\n   the serving process (e.g., a logger).\n\n   In the first case (Fig. 1, where the originating user is either a\n   terminal or a program) the user issues the appropriate CONNECT\n   command.  The UC/SC can be simplex or duplex.\n\n   The second case has two possible configurations, shown in Figs. 3 and\n   4.\n\n               +--------+  CC  +--------+      +------+\n               |        +------+        |  SC  |      |\n     +------+ /| TELNET |  UC  |  DRS   +------+  SP  |\n     |      |/ |        +------+        |      |      |\n     | USER | /+--------+      +--------+      +------+\n     |      |/\n     +------+\n\n            Figure 3.  Use of Dummy Control Connection\n\n               +--------+\n     +------+ /|  USER  |  CC  +--------+      +------+\n     |      |/ |  SIDE  +------+        |  SC  |      |\n     | USER |  +--------+  UC  |  DRS   +------+  SP  |\n     |      |\\ | SERVING+------+        |      |      |\n     +------+ \\|  SIDE  |      +--------+      +------+\n               +--------+\n\n            Figure 4.  Use of Server TELNET\n\n\n\n\n\nAnderson, et al.                                                [Page 6]\n\f\nRFC 138               Data Reconfiguration Service          April 1971\n\n\n   In Fig. 3 the user instructs his TELNET to make two duplex\n   connections to DRS.  One is used for control information (the CC) and\n   the other is a dummy.  When he issues the CONNECT he references the\n   dummy duplex connection (UC) using the \"already connected\" option.\n\n   In Fig. 4 the user has his TELNET (user side) call the DRS.  When he\n   issues the CONNECT the DRS calls the TELNET (server side) which\n   accepts the call on behalf of the console.  This distinction is known\n   only to the user since to the DRS the configuration in Fig. 4 appears\n   identical to that in Fig. 1.  Two points should be noted:\n\n        1)  TELNET protocol is needed only to define forms and direct\n            connections.  It is not required for the using and serving\n            processes.\n        2)  The using and serving processes need only a minimum of\n            modification for Network use, i.e., an NCP interface.\n\n\nIII.  THE FORM MACHINE\n\nINPUT/OUTPUT STREAMS AND FORMS\n\n   This section describes the syntax and semantics of forms that specify\n   the data reconfigurations.  The Form Machine gets an input stream,\n   reformats the input stream according to a form describing the\n   reconfiguration, and emits the reformatted data as an output stream.\n\n   In reading this section it will be helpful to envision the\n   application of a form to the data stream as depicted in Fig. 5.  An\n   input stream pointer identifies the position of data (in the input\n   stream) that is being analyzed at any given time by a part of the\n   form.  Likewise, an output stream pointer locates data being emitted\n   in the output stream.\n\n\n       /\\/\\                                                  /\\/\\\n  ^    |  |                     FORM                         |  |   ^\n  |    |  |                -----------------                 |  |   |\n  |    |  |            +-  -----------------  -+             |  |   |\n  |    |  |            |   CURRENT PART OF     |             |  |   |\nINPUT  |  |\u003c= CURRENT \u003c    -----------------    \u003e CURRENT =\u003e |  | OUTPUT\nSTREAM |  |   POINTER  |   FORM BEING APPLIED  |  POINTER    |  | STREAM\n       |  |            +-  -----------------  -+             |  |\n       |  |                -----------------                 |  |\n       |  |                -----------------                 |  |\n       |  |                -----------------                 |  |\n       \\/\\/                                                  \\/\\/\n              Figure 5.  Application of Form to Data Streams\n\n\n\nAnderson, et al.                                                [Page 7]\n\f\nRFC 138               Data Reconfiguration Service          April 1971\n\n\nFORM MACHINE BNF SYNTAX\n\n   form           ::=  rule | rule form\n\n   rule           ;;=  label  inputstream  outputstream ;\n\n   label          ::=  INTEGER | \u003cnull\u003e\n\n   inputstream    ::=  terms | \u003cnull\u003e\n\n   terms          ::=  term | terms , term\n\n   outputstream   ::=  : terms | \u003cnull\u003e\n\n   term           ::=  identifier | identifier  descriptor |\n                       descriptor | comparator\n\n   identifier     ::=  an alpha character followed by 0 to 3\n                       alphamerics\n\n   descriptor     ::=  (replicationexpression , datatype ,\n                       valueexpression , lengthexpression  control)\n\n   comparator     ::=  (value  connective  value  control)  |\n                       (identifier .\u003c=\u003e. control)\n\n   replicationexpression  ::=  arithmeticexpression | \u003cnull\u003e\n\n   datatype       ::=  B | O | X | E | A\n\n   valueexpression  ::=  value | \u003cnull\u003e\n\n   lengthexpression  ::=  # | arithmeticexpression | \u003cnull\u003e\n\n   connective     ::=  .LE. | .LT. | .GE. | .GT. | .EQ. | .NE.\n\n   value          ::=  literal | arithmeticexpression\n\n   arithmeticexpression  ::=  primary | primary operator\n                              arithmeticexpression\n\n   primary        ::=  identifier | L(identifier) | V(identifier) |\n                       INTEGER\n\n   operator       ::=  + | - | * | /\n\n   literal        ::=  literaltype \"string\"\n\n\n\n\nAnderson, et al.                                                [Page 8]\n\f\nRFC 138               Data Reconfiguration Service          April 1971\n\n\n   literaltype    ::=  B | O | X | E | A\n\n   string         ::=  from 0 to 256 characters\n\n   control        ::=  :  options | \u003cnull\u003e\n\n   options        ::=  S(where) | F(where) | U(where) |\n                       S(where) , F(where) |\n                       F(where) , S(where)\n\n   where          ::=  arithmeticexpression | R(arithmeticexpression)\n\n\n\nALTERNATE SPECIFICATION OF FORM MACHINE SYNTAX\n\n                                   infinity\nform                    ::=  {rule}\n                                   1\n                                      1         1          1\nrule                    ::=  {INTEGER}   {terms}   {:terms} ;\n                                      0         0          0\n                                         infinity\nterms                   ::=  term {,term}\n                                         0\n                                                      1\nterm                    ::=  identifier | {identifier}   descriptor\n                                                      0\n                             | comparator\n                                                    1\ndescriptor              ::=  ({arithmeticexpression}  , datatype ,\n                                                    0\n                                    1                     1           1\n                             {value} ,  {lengthexpression}  {:options}\n                                    0                     0           0\n                                                                 1\ncomparator              ::=  (value  connective  value {:options} ) |\n                                                                 0\n                                                              1\n                             (identifier .\u003c=. value {:options} )\n                                                              0\nconnective              ::=  .LE. | .LT. | .GE. | .GT. | .EQ. | .NE.\n\nlengthexpression        ::=  # | arithmeticexpression\n\ndatatype                ::=  B | O | X | E | A\n\nvalue                   ::=  literal | arithmeticexpression\n\n\n\nAnderson, et al.                                                [Page 9]\n\f\nRFC 138               Data Reconfiguration Service          April 1971\n\n\n                                                         infinity\narithmeticexpression    ::=  primary  {operator  primary}\n                                                         0\noperator                ::= + | - | * | /\n\nprimary                 ::=  identifier | L(identifier) |\n                             V(identifier) | INTEGER\n                                                      256\nliteral                 ::=  literaltype  \"{CHARACTER}   \"\n                                                      0\nliteraltype             ::=  B | O | X | A | E\n                                                 1\noptions                 ::=  S(where) {,F(where)}  |\n                                                 0\n                                                 1\n                             F(where) {,S(where)}  | U(where)\n                                                 0\n\nwhere                   ::=  arithmeticexpression |\n                             R(arithmeticexpression)\n                                                     3\nidentifier              ::=  ALPHABETIC  {ALPHAMERIC}\n                                                     0\n\nFORMS\n\n   A form is an ordered set of rules.\n\n         form ::=  rule | rule form\n\n   The current rule is applied to the current position of the input\n   stream.  If the (input stream part of a) rule fails to correctly\n   describe the contents of the current input then another rule is made\n   current and applied to the current position of the input stream.  The\n   next rule to be made current is either explicitly specified by the\n   current term in the current rule or it is the next sequential rule by\n   default.  Flow of control is more fully described under TERM AND RULE\n   SEQUENCING.\n\n   If the (input stream part of a) rule succeeds in correctly describing\n   the current input stream, then some data may be emitted at the\n   current position in the output stream according to the rule.  The\n   input and output stream pointers are advanced over the described and\n   emitted data, respectively, and the next rule is applied to the now\n   current position of the input stream.\n\n   Application of the form is terminated when an explicit return\n   (R(arithmeticexpression)) is encountered in a rule.  The user and\n\n\n\nAnderson, et al.                                               [Page 10]\n\f\nRFC 138               Data Reconfiguration Service          April 1971\n\n\n   server connections are closed and the return code\n   (arithmeticexpression) is sent to the originating user.\n\nRULES\n\n   A rule is a replacement, comparison, and/or an assignment operation\n   of the form shown below.\n\n         rule ::= label  inputstream  outputstream ;\n\n   A label is the name of a rule and it exists so that the rule may be\n   referenced elsewhere in the form for explicit rule transfer of\n   control.  Labels are of the form below.\n\n         label ::=  INTEGER | \u003cnull\u003e\n\n   The optional integer labels are in the range 0 \u003e= INTEGER \u003e= 9999.\n   The rules need not be labeled in ascending numerical order.\n\nTERMS\n\n   The inputstream (describing the input stream to be matched) and the\n   outputstream (describing data to be emitted in the output stream)\n   consist of zero or more terms and are of the form shown below.\n\n         inputstream   ::=  terms | \u003cnull\u003e\n         outputstream  ::=  :terms | \u003cnull\u003e\n         terms         ::=  term | terms , term\n\n   Terms are of one of four formats as indicated below.\n\n         term ::=  identifier | identifier  descriptor |\n                   descriptor | comparator\n\nTerm Format 1\n\n   The first term format is shown below.\n\n         identifier\n\n   The identifier is a symbolic reference to a previously identified\n   term (term format 2) in the form.  It takes on the same attributes\n   (value, length, type) as the term by that name.  Term format 1 is\n   normally used to emit data in the output stream.\n\n   Identifiers are formed by an alpha character followed by 0 to 3\n   alphameric characters.\n\n\n\n\nAnderson, et al.                                               [Page 11]\n\f\nRFC 138               Data Reconfiguration Service          April 1971\n\n\nTerm Format 2\n\n   The second term format is shown below.\n\n         identifier descriptor\n\n   Term format 2 is generally used as an input stream term but can be\n   used as an output stream term.\n\n   A descriptor is defined as shown below.\n\n         descriptor ::= (replicationexpression, datatype,\n                        valueexpression, lengthexpression\n                        control)\n\n   The identifier is the symbolic name of the term in the usual\n   programming language sense.  It takes on the type, length, and value\n   attributes of the term and it may be referenced elsewhere in the\n   form.\n\n   The replication expression is defined below.\n\n         replicationexpression ::= arithmeticexpression | \u003cnull\u003e\n         arithmeticexpression ::= primary | primary operator\n                                       arithmeticexpression\n         operator ::= + | - | * | /\n         primary ::= identifier | L(identifier) | V(identifier) |\n                     INTEGER\n\n   The replication expression is a repeat function applied to the\n   combined data type and value expression.  It expresses the number of\n   times that the value (of the data type/value expression) is to be\n   repeated within the field length denoted by the data type/length\n   expression.\n\n   A null replication expression has the value of one.  Arithmetic\n   expressions are evaluated from left-to-right with no precedence.  (It\n   is anticipated that this interpretation might be changed, if\n   necessary.)\n\n   The L(identifier) is a length operator that generates a 32-bit binary\n   integer corresponding to the length of the term named.  The\n   V(identifier) is a value operator that generates a 32-bit binary\n   integer corresponding to the value of the term named.  (See\n   Restrictions and Interpretations of Term Functions.)  The value\n   operator is intended to convert character strings to their numerical\n   correspondents.\n\n\n\n\nAnderson, et al.                                               [Page 12]\n\f\nRFC 138               Data Reconfiguration Service          April 1971\n\n\n   The data type is defined below.\n\n             datatype ::= B | O | X | E | A\n\n   The data type describes the kind of data that the term represents.\n   (It is expected that additional data types, such as floating point\n   and user-defined types, will be added as needed.)\n\n        Data Type         Meaning              Unit Length\n\n            B             Bit string              1 bit\n            O             Bit string              3 bits\n            X             Bit string              4 bits\n            E             EBCDIC character        8 bits\n            A             Network ASCII character 8 bits\n\n        The value expression is defined below.\n\n                 valueexpression ::= value | \u003cnull\u003e\n                 value ::= literal | arithmeticexpression\n                 literal ::= literaltype \"string\"\n                 literaltype ::= B | O | X | E | A\n\n   The value expression is the unit value of a term expressed in the\n   format indicated by the data type.  It is repeated according to the\n   replication expression, in a field whose length is constrained by the\n   length expression.\n\n   A null value expression in the input stream defaults to the data\n   present in the input stream.  The data must comply with the datatype\n   attribute, however.\n\n   A null value expression generates padding according to Restrictions\n   and Interpretations of Term Functions.\n\n   The length expression is defined below.\n\n         lengthexpression ::= # | arithmeticexpression | \u003cnull\u003e\n\n   The length expression states the length of the field containing the\n   value expression as expanded by the replication expression.  If the\n   value of the length expression is less then the length implied by the\n   expanded value expression, then the expanded value expression is\n   truncated, see Restrictions and Interpretations of Term Functions.\n\n   The terminal symbol # means an arbitrary length, explicitly\n   terminated by the value of the next term.  The # is legal only in the\n   input stream and not in the output stream.\n\n\n\nAnderson, et al.                                               [Page 13]\n\f\nRFC 138               Data Reconfiguration Service          April 1971\n\n\n   If the length expression is less than or equal to zero, the term\n   succeeds but the appropriate stream pointer is not advanced.\n   Positive lengths cause the appropriate stream pointer to be advanced\n   if the term otherwise succeeds.\n\n   Control is defined under TERM AND RULE SEQUENCING.\n\nTerm Format 3\n\n   Term format 3 is shown below.\n\n         descriptor\n\n   It is identical to term format 2 with the omission of the identifier.\n   Term format 3 is generally used in the output stream.  It is used in\n   the input stream where input data is to be passed over but not\n   retained for emission or later reference.\n\nTerm Format 4\n\n   The fourth term format is shown below.\n\n         comparator    ::= (value connective value control) |\n                           (identifier .\u003c=. value control)\n         value         ::= literal | arithmeticexpression\n         literal       ::= literaltype \"string\"\n         literaltype   ::= B | O | X | E | A\n         string        ::= from 0 to 256 characters\n         connective    ::= .LE. | .LT. | .GE. | .GT. | .EQ. | .NE.\n\n   The fourth term format is used for assignment and comparison.\n\n   The assignment operator .\u003c=. assigns the value to the identifier.\n   The connectives have their usual meaning.  Values to be compared must\n   have the same type and length attributes or an error condition arises\n   and the form fails.\n\nThe Application of a Term\n\n   The elements of a term are applied by the following sequence of\n   steps.\n\n         1.  The data type and value expression together specify a unit\n             value, call it x.\n\n         2.  The replication expression specifies the number of times x\n             is to be repeated (or copied) in concatenated fashion.  The\n             value of the concatenated xs becomes, say, y of length L1.\n\n\n\nAnderson, et al.                                               [Page 14]\n\f\nRFC 138               Data Reconfiguration Service          April 1971\n\n\n         3.  The data type and the length expression together specify a\n             field length of the input area (call it L2) that begins at\n             the current stream pointer position.\n\n         4.  The value of y is truncated to y' if L1 \u003e L2.  Call the\n             truncated length L1'.\n\n         5.  If the term is an input stream term, then the value y' of\n             length L1' is compared to the input value beginning at the\n             current input pointer position.\n\n         6.  If the values are identical over the length L1' then the\n             input value of length L2 (may be greater than L1') starting\n             at the current pointer position in the input area, becomes\n             the value of the term.\n\n   In an output stream term, the procedure is the same except that the\n   source of input is the value of the term(s) named in the value\n   expression and the data is emitted in the output stream.\n\n   The above procedure is modified to include a one term look-ahead\n   where lengths are indefinite because of the arbitrary symbol, #.\n\nRestrictions and Interpretations of Term Functions\n\n   1.  Terms specifying indefinite lengths, through the use of the #\n         symbol must be separated by some type-specific data such as a\n         literal.  (A literal isn't specifically required, however.  An\n         arbitrary number of ASCII characters could be terminated by a\n         non-ASCII character.)  # is legal only in the input stream, not\n         in the output stream.\n\n   2.  Truncation and padding is as follows:\n         a)  Character to character (A \u003c--\u003e E) conversion is left\n             justified and truncated or padded on the right with blanks.\n         b)  Character to numeric and numeric to numeric conversions are\n             right-justified and truncated or padded on the left with\n             zeros.\n         c)  Numeric to character conversion is right-justified and\n             left-padded with blanks.\n\n   3.  The following are ignored in a form definition over the control\n         connection.\n         a)  TAB, carriage return, etc.\n         b)  blanks except within quotes.\n         c)  /* string */ is treated as comments except within quotes.\n\n   4.  The following defaults prevail where the term part is omitted.\n\n\n\nAnderson, et al.                                               [Page 15]\n\f\nRFC 138               Data Reconfiguration Service          April 1971\n\n\n         a)  The replication expression defaults to one.\n         b)  The data type defaults to type B.\n         c)  The value expression of an input stream term defaults to\n             the value found in the input stream, but the input stream\n             must conform to data type and length expression.  The value\n             expression of an output stream term defaults to padding\n             only.\n         d)  The length expression defaults to the size of the quantity\n             determined by replication expression, data type, and value\n             expression.\n         e)  Control defaults to the next sequential term if a term is\n             successfully applied; else control defaults to the next\n             sequential rule.  If _where_ evaluates to an undefined\n             _label_ the form fails.\n\n   5.  Arithmetic expressions are evaluated left-to-right with no\n         precedence.\n\n   6.  The following limits prevail.\n\n         a)  Binary lengths are \u003c= 32 bits\n         b)  Character strings are \u003c= 256 8-bit characters\n         c)  Identifier names are \u003c= 4 characters\n         d)  Maximum number of identifiers is \u003c= 256\n         e)  Label integers are \u003e= 0 and \u003c= 9999\n\n   7.  Value and length operators product 32-bit binary integers.  The\n         value operator is currently intended for converting A or E type\n         decimal character strings to their binary correspondents.  For\n         example, the value of E'12' would be 0......01100.  The value\n         of E'AB' would cause the form to fail.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAnderson, et al.                                               [Page 16]\n\f\nRFC 138               Data Reconfiguration Service          April 1971\n\n\nTERM AND RULE SEQUENCING\n\n   Sequencing may be explicitly controlled by including control in a\n   term.\n\n        control ::=  :options | \u003cnull\u003e\n        options ::=  S(where) | F(where) | U(where)\n                     S(where) , F(where) |\n                     F(where) , S(where)\n\n        where   ::=  arithmeticexpression | R(arithmeticexpression)\n\n   S, F, and U denote success, fail, and unconditional transfers,\n   respectively.  _Where_ evaluates to a _rule_ label, thus transfer can\n   be effected from within a rule (at the end of a term) to the\n   beginning of another rule.  R means terminate the form and return the\n   evaluated expression to the initiator over the control connection (if\n   still open).\n\n   If terms are not explicitly sequenced, the following defaults\n   prevail.\n\n   1)  When a term fails go to the next sequential rule.\n   2)  When a term succeeds go to the next sequential\n       term within the rule.\n   (3) At the end of a rule, go to the next sequential\n       rule.\n\n   Note in the following example, the correlation between transfer of\n   control and movement of the input pointer.\n\n        1   XYZ(,B,,8:S(2),F(3)) : XYZ ;\n        2   . . . . . . .\n        3   . . . . . . .\n\n   The value of XYZ will never be emitted in the output stream since\n   control is transferred out of the rule upon either success or\n   failure.  If the term succeeds, the 8 bits of input will be assigned\n   as the value of XYZ and rule 2 will then be applied to the same input\n   stream data.  That is, since the complete rule 1 was not successfully\n   applied, then the input stream pointer is not advanced.\n\n\n\n\n\n\n\n\n\n\nAnderson, et al.                                               [Page 17]\n\f\nRFC 138               Data Reconfiguration Service          April 1971\n\n\nIV.  EXAMPLES\n\nREMARKS\n\n   The following examples (forms and also single rules) are simple\n   representative uses of the Form Machine.  The examples are expressed\n   in a term-per-line format only to aid the explanation.  Typically, a\n   single rule might be written as a single line.\n\nFIELD INSERTION\n\n   To insert a field, separate the input into the two terms to allow the\n   inserted field between them.  For example, to do line numbering for a\n   121 character/line printer with a leading carriage control character,\n   use the following form.\n\n   (NUMB.\u003c=\u003e.1);       /*initialize line number counter to one*/\n   1 CC(,E,,1:F(R(99))),  /*pick up control character and save\n                            as CC*/\n                          /*return a code of 99 upon exhaustion*/\n   LINE(,E,,121 : F(R(98)))    /*save text as LINE*/\n   :CC,               /*emit control character*/\n   (,E,NUMB,2),       /*emit counter in first two columns*/\n   (,E,E\".\",1),       /*emit period after line number*/\n   (,E,LINE,117),     /*emit text, truncated in 117 byte field*/\n   (NUMB.\u003c=.NUMB+1:U(1));    /*increment line counter and go to\n                               rule one*/;;\n\nDELETION\n\n   Data to be deleted should be isolated as separate terms on the left,\n   so they may be omitted (by not emitting them) on the right.\n\n   (,B,,8),           /*isolate 8 bits to ignore*/\n   SAVE(,A,,10)       /*extract 10 ASCII characters from\n                        input stream*/\n   :(,E,SAVE,);      /*emit the characters in SAVE as EBCDIC\n                       characters whose length defaults to the\n                       length of SAVE, i.e., 10, and advance to\n                       the next rule*/\n\n   In the above example, if either input stream term fails,\n   the next sequential rule is applied.\n\nVARIABLE LENGTH RECORDS\n\n   Some devices, terminals and programs generate variable length\n   records.  To following rule picks up variable length EBCDIC records\n\n\n\nAnderson, et al.                                               [Page 18]\n\f\nRFC 138               Data Reconfiguration Service          April 1971\n\n\n   and translates them to ASCII.\n\n   CHAR(,E,,#),       /*pick up all (an arbitrary number of)\n                        EBCDIC characters in the input stream*/\n   (,X,X\"FF\",2)       /*followed by a hexadecimal literal,\n                        FF (terminal signal)*/\n   :(,A,CHAR,),       /*emit them as ASCII*/\n   (,X,X\"25\",2);      /*emit an ASCII carriage return*/\n\nSTRING LENGTH COMPUTATION\n\n   It is often necessary to prefix a length field to an arbitrarily long\n   character string.  The following rule prefixes an EBCDIC string with\n   a one-byte length field.\n\n   Q(,E,,#),          /*pick up all EBCDIC characters*/\n   TS(,X,X\"FF\",2)     /*followed by a hexadecimal literal, FF*/\n   :(,B,L(Q)+2,8),    /*emit the length of the characters\n                        plus the length of the literal plus\n                        the length of the count field itself,\n                        in an 8-bit field*/\n   Q,                 */emit the characters*/\n   TS;                */emit the terminal*/\n\nTRANSPOSITION\n\n   It is often desirable to reorder fields, such as the following\n   example.\n\n   Q(,E,,20), R(,E,,10) , S(,E,,15), T(,E,,5) : R, T, S, Q ;\n\n   The terms are emitted in a different order.\n\nCHARACTER PACKING AND UNPACKING\n\n   In systems such as HASP, repeated sequences of characters are packed\n   into a count followed by the character, for more efficient storage\n   and transmission.  The first form packs multiple characters and the\n\n\n\n\n\n\n\n\n\n\n\n\n\nAnderson, et al.                                               [Page 19]\n\f\nRFC 138               Data Reconfiguration Service          April 1971\n\n\n   second unpacks them.\n   /*form to pack EBCDIC streams*/\n   /*returns 99 if OK, input exhausted*/\n   /*returns 98 if illegal EBCDIC*/\n   /*look for terminal signal FF which is not a legal EBCDIC*/\n   /*duplication count must be 0-254*/\n   1 (,X,X\"FF\",2 : S(R(99))) ;\n   /*pick up the EBCDIC and initialize count/*\n     CHAR(,E,,1 : F(R(98))) , (CNT .\u003c=. 1) ;\n   /*count consecutive EBCDICs like CHAR*/\n   2 (,E,CHAR,1 : F(3)) , (CNT .\u003c=. CNT+1 : U(2)) ;\n   /*emit count and current character*/\n   3 : (,B,CNT,8), CHAR, (:U(1));\n   /*end of form*/;;\n\n   /*form to unpack EBCDIC streams*/\n   /*look for terminal*/\n   1 (,X,X\"FF\",2 : S(R(99))) ;\n   /*emit character the number of times indicated*/\n   /*by the counter contents*/\n   CNT(,B,,8), CHAR(,E,,1) : (CNT,E,CHAR,CNT:U(1));\n   /*failure of form*/\n   (:U(R(98))) ;;\n\n\nV.  PROPOSED USES OF DATA RECONFIGURATION SERVICE\n\n   The following are some proposed uses of the DRS that were submitted\n   by the sites indicated.\n\n   UCLA\n   1.  Pack/unpack text files.\n   2.  Preprocessor to scan META compiler input.\n   3.  Perhaps graphics.\n\n   MIT\n   1.  Reformatting within file transfer service.\n   2.  Character conversions.\n   3.  Possible graphics service (Evans and Sutherland output\n       format).\n   4.  Reformat arguments of subroutines remote to each other.\n\n   U. OF ILLINOIS\n   1.  Dependent upon remote use of DRS for many remote\n       services.\n\n   SDC\n   1.  Would be essential to data transfer in general.\n\n\n\nAnderson, et al.                                               [Page 20]\n\f\nRFC 138               Data Reconfiguration Service          April 1971\n\n\n   2.  Could be used in relation to data management language.\n\n   UCSB\n   1.  Checkout of I/O formats of file system.\n   2.  Debugging Network services in general.\n   3.  Mapping their services into future standards.\n\n   RAND\n   1.  To describe RJO/RJE message formats at UCSB.\n   2.  To describe RJS message formats at UCLA.\n   3.  To adapt Network to existing services, in general.\n\n   MITRE\n   1.  Character conversions.\n   2.  Testing data formats going into data bases for correct\n       field formatting.\n\n   VI.  IMPLEMENTATION PLANS\n\n   Four sites currently plan to implement and offer the service on an\n   experimental basis.\n\n   1.  MIT    Implementation of forms interpreter in MIDAS\n              (assembly).  Perhaps Tree Meta compiler of\n              forms.  Implementation on PDP-10.\n\n   2.  UCLA   Implementation on SIGMA-7 employing META-7\n              to compile forms.\n\n   3.  UCSB   Implementation on 360/75.\n\n   4.  RAND   Initial implementation on 360/65; compiler to be written\n               in graphics CPS; compiled intermediate forms to be\n               interpreted by assembler language subroutine.  Later\n               implemented on PDP-10.\n\n   In addition to the above sites, the University of Illinois and Mitre\n   plan to experiment with the service.\n\n\n\n\n\n\n\n\n\n\n\n\n\nAnderson, et al.                                               [Page 21]\n\f\nRFC 138               Data Reconfiguration Service          April 1971\n\n\n                                APPENDIX A\n\nNote 1 to the DRS Working Group\n\n   As you recall, we spent considerable time in discussing the use and\n   meaning of the arbitrary symbol, #.  To summarize, it was clear that\n   inclusion of the # in both replication and length expressions led to\n   ambiguities.  We settled on its restricted use in the length\n   expression of an input term, although no one was entirely satisfied\n   with this definition.\n\n   Recently, Jim White has again commented on the #.  Jim feels that it\n   is curious that one can pick up an arbitrary number of EBCDIC\n   characters, for example, but can't pick up an arbitrary number of\n   specific EBCDIC characters such as EBCDIC A's.  Jim feels that a more\n   natural way to interpret the length, value, and replication\n   expressions would be as the IBM OS assembler interprets the\n   attributes of the pseudo instruction, define constant (CD).\n\n   The IBM OS assembler uses the following format.\n\n        1             2              3           4\n   duplication       type        modifiers   nominal value\n     factor\n\n   The duplication factor, if specified, causes the constant to be\n   generated the number of times indicated by the factor.  The type\n   defines the type of constant being specified.  Modifiers describe the\n   length, scaling, and exponent of the constant.  Nominal value\n   supplies the constant described by the subfields that precede it.\n\n   Assume that we use the # only as a duplication factor (replication\n   expression).  Hence, in the example of the form to pack EBCDIC\n   characters, the counter and looping can be eliminated.\n\n   CHAR(,E,,1) ;\n   LEN(#,#,CHAR,1) : (,B,L(LEN)+1,*) , CHAR ;\n\n   The interpretation is that the data type, length expression, and\n   value expression make up the unit value.  This quantity can then be\n   replicated.  As our document now stands, only the data type and value\n   expression make up the unit value.\n\n   The application of a term according to Jim's suggestion is as\n   follows.\n   1.  The data type, value expression, and length expression together\n       specify a unit value, call it x.\n\n\n\n\nAnderson, et al.                                               [Page 22]\n\f\nRFC 138               Data Reconfiguration Service          April 1971\n\n\n   2.  The replication expression specifies the number of times x is to\n       be repeated.  The value of the concatenated xs becomes y of\n       length L.\n   3.  If the term is an input stream term then the value beginning at\n       the current input pointer position.\n   4.  If the input value satisfies the constraints of y over length L\n       then the input value of length L becomes the value of the term.\n\nNote 2 to the DRS Working Group\n\n   There has been recent debate of whether the input pointer should be\n   advanced upon successful completion of a rule (as it now is defined)\n   or upon successful completion of each term.  See the example on page\n   22.  If the input pointer is advanced upon successful completion of a\n   term, then rules become equivalent to terms.\n\n   I would like to for us to discuss at the SJCC both the term\n   attributes and the input pointer advance issues.\n\n                                                John\n\n\n       [ This RFC was put into machine readable form for entry ]\n       [ into the online RFC archives by Katsunori Tanaka 4/99 ]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAnderson, et al.                                               [Page 23]\n\f\n"
}