{
  "series": "Request for Comments",
  "number": "435",
  "howpublished": "RFC 435",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0435",
  "url": "https://www.rfc-editor.org/info/rfc435",
  "title": "Telnet issues",
  "pagetotal": "10",
  "year": "1973",
  "month": "jan",
  "body": "\n\n\n\n\n\nNetwork Working Group                                          B. Cosell\nRequest for Comment: 435                                         BBN-NET\nNIC: 13675                                                     D. Walden\nCategory: TELNET, Protocols, Echoing                             BBN-NET\nReferences: 318, 357                                      5 January 1973\n\n\n                             TELNET Issues\n\n   This RFC discusses a number of TELNET related issues which have been\n   bothering us [1].  The basic, central issue we started from was that\n   of echoing.  We worked downward from our difficulties to discover the\n   basic principles at the root of our unhappiness, and from there\n   worked back upwards to design a scheme which we believe to be better.\n   In this note we will discuss both the alternate scheme and its\n   underlying principles.\n\n   As something of a non sequitur, before discussing echoing we feel it\n   expedient to dismiss one possible stumbling block, outright.  HIDE\n   YOUR INPUT may or may not be a good idea, this question not\n   concerning us at the moment.  Whatever the case, the issue of hiding\n   input is certainly separable from that of echoing.  We, therefore,\n   strongly recommend that a STOP HIDING YOUR INPUT command be\n   sanctioned to replace the multiplexing of this function on the NO\n   ECHO command.  Once this has been done, the pair of commands HIDE\n   YOUR INPUT and STOP HIDING YOUR INPUT can be kept or discarded\n   together, and we can discuss the issue of echoing independently of\n   them.\n\nEchoing\n\n   The basic observation that we made regarding echoing was that servers\n   seem to be optimized to best handle terminals which either do their\n   own echoing or do not, but not both.  Therefore, the present TELNET\n   echoing conventions, which prohibit the server from initiating a\n   change in echo mode, seemed overly confining.  The servers are\n   burdened with users who are in the 'wrong' mode, in which they might\n   not otherwise have to be, and users, both human and machine, are\n   burdened with remembering the proper echoing mode, and explicitly\n   setting it up, for all the different servers.  It is our\n   understanding that this prohibition was imposed on the servers to\n   prevent loops from developing because of races which can arise when\n   the server and user both try to set up an echo mode simultaneously.\n   We will describe a method wherein both parties can initiate a change\n   of echo mode and show that the method does not loop.\n\n\n\n\n\n\nCosell \u0026 Walden                                                 [Page 1]\n\f\nRFC 435                      TELNET Issues                5 January 1973\n\n\n   This alternate specification relies on three primary assumptions.\n   First as above, the server, as well as the user, should be able to\n   suggest the echo mode.  Second, all terminals must be able to provide\n   their own echoes, either internally or by means of the local Host.\n   Third, all servers must be able to operate in a mode which assumes\n   that a remote terminal is providing its own echoes.  Both of these\n   last two result from the quest for a universal, minimal basis upon\n   which to build.  It is fairly easy for a Host which normally supplies\n   echoes to disable the appropriate code, but it will difficult for a\n   Host which does not do echoing to integrate such routines into its\n   system similarly, it is easier for a local Host to supply echoes to a\n   terminal which cannot provides its own, but it borders on the\n   impossible to undo echoing in a terminal which has automatic echoing\n   built into it.\n\n   Our proposed specification would use the present ECHO and NO ECHO\n   commands as follows: ECHO, when sent by the server to the user, would\n   mean 'I'll echo to you' ECHO, when sent by the user to the server,\n   would mean 'You echo to me'.  NO ECHO, when sent by the server to the\n   user, would mean 'I'll not echo to you'; NO ECHO, when sent by the\n   user to the server, would mean 'Don't you echo to me'.  These are, of\n   course, nearly the same meanings that the commands currently have,\n   although most current implementations seem to invert the server-to-\n   user meanings.\n\n   In our specification, whenever a connection is opened both server and\n   user assume that the user is echoing locally.  If the user would, in\n   fact, prefer the server to echo, the user could send off an ECHO\n   command.  Similarly, if the server prefers to do the echoing (for\n   instance, because the server system is optimized for very interactive\n   echoing), the server could send off an ECHO command.  Neither is\n   required to do anything, it is only a matter of preference.  Upon\n   receipt of either command by either party, if that is an admissible\n   mode of operation the recipient should begin operating in that mode,\n   and if such operation reflects a change in mode, it should respond\n   with the same command to confirm that (and when) the changeover took\n   place.  If the received command request an inadmissible mode of\n   operation, then the command's inverse should be sent as a refusal\n   (this must be NO ECHO, since neither party can refuse a change into\n   NO ECHO).  To state these rules more formally:\n\n      1) Both server and user assume that a connection is initially in\n         NO ECHO mode.\n\n      2) Neither party can refuse a request to change into NO ECHO mode.\n\n      3) Either party may send an unsolicited command only to request a\n         change in mode.\n\n\n\nCosell \u0026 Walden                                                 [Page 2]\n\f\nRFC 435                      TELNET Issues                5 January 1973\n\n\n      4) A party only changes its echo mode when it receives an\n         admissible request.\n\n      5) When a command is received, the party replies with its echo\n         mode, unless it did not have to change mode to honor the\n         request.\n\n   Several properties of this scheme are worthy of note:\n\n      1) NO ECHO is retained as the nominal connection mode.  A\n         connection will work in ECHO mode only when both parties agree\n         to operate that way.\n\n      2) The procedure cannot loop.  Regardless of which party (or both)\n         initiates a change, or in what time order, there are at most\n         three commands sent between the parties [2].\n\n      3) Servers are free to specify their preferred mode of operation.\n         Thus, human, or machine, users do not have to learn the proper\n         mode for each server.\n\nThree Principles\n\n   Let us mention the general principles we alluded to at the beginning\n   of this note.  The principles are: default implementation, negotiated\n   options and symmetry.  The principle of default implementation merely\n   states that for all options, defaults are declare which must be\n   implemented.  It is this principle which leads us to seek out the\n   'minimum' for each option (to keep the required burden on everybody\n   as small as possible), and prevents loops in protocol.  The principle\n   of negotiated options merely states that options must be agreed upon\n   by all (both) parties concerned.  It is this principle which dictated\n   the positive/negative acknowledgement scheme.  The principle of\n   symmetry merely states that neither party should have to 'know'\n   whether it is the server or the user.  Our scheme, as described thus\n   far, is not totally symmetrical we will consider this matter in a\n   later section.\n\n   The ECHOING scheme we have described, together with the principles\n   stated above, form the heart of our comments on the TELNET protocol.\n   The remainder of this note consists of further ways in which the\n   protocol can be expanded on the whole, these suggestions are all\n   really only applications and development of the principles we have\n   already put forward.  However, the fecundity of these expansions, and\n   the 'good feel' they have, make us yet more convinced of the '\n   rightness' of our original proposals.\n\n\n\n\n\nCosell \u0026 Walden                                                 [Page 3]\n\f\nRFC 435                      TELNET Issues                5 January 1973\n\n\n   Thus far, we have made a simple, concrete suggestion that we believe\n   should be immediately sanctioned.  Looking beyond that proposal,\n   however, has suggestion a large number of further, more ambitious\n   changes.  The remainder of this RFC describes ideas which we don't\n   feel have the immediacy of the proposal above, but should,\n   nonetheless, be kept in mind if the network community decides to\n   embark on revamping the protocol.\n\nSynchronization\n\n   One complaint we have heard about the present convention for\n   establishing an echoing mode is about the lack of a provision to\n   synchronize a change of echoing mode with the user-to-server data\n   stream our scheme, too, is guilty on this count.  John Davidson of\n   the University of Hawaii has documented, in RFC 357, a more elaborate\n   echoing scheme which doesn't have this problem.  We, however, feel\n   that it is possible to eliminate most of the trouble involved with\n   normal changing of echo mode at a more modest cost than that required\n   by the highly interactive scheme described by Davidson.  We can do\n   this by borrowing a small piece of that scheme.  The rule we would\n   incorporate is that whenever a party initiates a request for a change\n   in echo mode, it then buffers, without transmitting or processing,\n   all data in the user-to-server data stream until it receives an\n   acknowledgement, positive or negative, at which time it deals with\n   the buffered data in the newly negotiated mode.  Since with both our\n   proposed and the current schemes such a request is guaranteed to be\n   acknowledgement, the buffering time is bounded.\n\n   An important aspect of this technique of eliminating the\n   synchronization problem is that it need not ever become part of the\n   official protocol.  Since its operation is entirely internal to the\n   server or user, each may independently weigh the value of elegance\n   against the cost of the required code and buffer space.\n\nOther options\n\n   Abhay Bushan has suggested to us that whether the user and server\n   operate line-at-a-time or character-at-a-time mode (see RFC 318)\n   should also be a negotiated option.  Further, he suggested that\n   whether the terminal follows the TELNET end-of-line convention or not\n   should also be negotiated.  Thus, when a connection is opened, in\n   addition to being set to NO ECHO mode, the terminal would also be set\n   to LINE-AT-A-TIME and EOL modes.  We could augment the command space\n   with the new commands LINE, NO LINE (=CHARACTER), EOL and NO EOL\n   (=separate CR and LF).\n\n\n\n\n\n\nCosell \u0026 Walden                                                 [Page 4]\n\f\nRFC 435                      TELNET Issues                5 January 1973\n\n\n   Once started in this direction, we found several further\n   applications.  HIDE YOUR INPUT could be made an option, as could\n   Davidson's echoing scheme, and even the character set to be used!\n   Consider that an APL subsystem might well want to suggest to its user\n   that EBCDIC be used for the connection.\n\n   In mentionaing that the character set could be negotiated, it was\n   implicit that 7-bit USASCII was the default.  The possibility of\n   having the default be straight binary suggests itself.  If we\n   augmented the protocol with a QUOTE character, the byte after which\n   were to be always interpreted as data, then codes 128-255 could be\n   retained as the 'TELNET command space' independently of the data mode\n   in use by merely prefixing all data bytes in this region with a\n   QUOTE.  If BINARY were a permissible data mode, then it is easy to\n   visualize many higher level protocols, e.g., perhaps, File Transfer\n   and Graphics, being built on top of, and into, the TELNET protocol.\n   What we would have accomplished is to promote TELNET from being a\n   constrained, terminal-oriented protocol to its being a flexible,\n   general protocol for any type of byte oriented communication.  With\n   such a backbone, many of the higher level protocols could be designed\n   and implemented more quickly and less painfully -- conditions which\n   would undoubtedly hasten their universal acceptance and availability\n   [3].\n\n   Looking toward a better world of the future, we have come up with a\n   more compact and flexible command scheme.  We'll describe it after\n   the next section.\n\nSymmetry\n\n   Some of the TENEX group (in particular, Thomas, Burchfiel and\n   Tomlinson) have pointed out to us that although we have made the\n   rules for the protocol symmetrical, we have not made the meanings of\n   the commands symmetrical.  For example, the interpretations of the\n   ECHO command -- 'I'll echo to you' and 'You echo to me' -- implicitly\n   assume that both the server and user know who is which.  This is a\n   problem not only for server-server connections where it is not clear\n   which is the user, but also for user-user connections, e.g., in\n   linking Teletypes together, where it is not clear which is the\n   server.\n\n   Responding to this, we came to understand that there are only five\n   reasonable modes of operation for the echoing on a connection pair\n   [4]:\n\n\n\n\n\n\n\nCosell \u0026 Walden                                                 [Page 5]\n\f\nRFC 435                      TELNET Issues                5 January 1973\n\n\n                         \u003c------------------\u003c\n   A          Process 1                        Process 2\n                         \u003e------------------\u003e\n                         neither end echoes\n\n\n                         \u003c------------------\u003c\n   B          Process 1  \u003c--+                  Process 2\n                            ^\n                         \u003e--^---------------\u003e\n                        one end echoes for itself\n\n\n                         \u003c------------------\u003c\n   C          Process 1  \u003c--------------+     Process 2\n                                        ^\n                         \u003e--------------^---\u003e\n                        one end echoes for the other\n\n\n                         \u003c--------------V---\u003c\n   D          Process 1  \u003c--+           V       Process 2\n                            ^           +---\u003e\n                         \u003e--^---------------\u003e\n                        both ends echo for themselves\n\n\n                         \u003c-----V------------\u003c\n   E          Process 1  \u003c--+  V               Process 2\n                            ^  +------------\u003e\n                         \u003e--^---------------\u003e\n                        one end echoes for both ends\n\n   The TENEX group suggested to us that four commands are sufficient to\n   deal with completely symmetric echoing.  We have actually already\n   mentioned the four commands -- the two possible meanings for each of\n   ECHO and NO ECHO.  Explicitly, the commands would be I'LL ECHO TO\n   YOU, YOU ECHO TO ME, DON'T ECHO TO ME and I'LL NOT ECHO TO YOU.\n   Echoing is now the negotiation of two options, and the initial,\n   default modes are DON'T ECHO TO ME and I'LL NOT ECHO TO YOU.\n\n   In the case where the server or user knows which he is, the\n   modification to the scheme is minimal since the commands never had\n   ambiguous meanings in these cases.  When an 'end' truly doesn't know,\n   then things are a little more complicated -- for example, consider\n   both ends in I'LL ECHO TO YOU mode, but even then the problems are\n   not insurmountable.\n\n\n\n\nCosell \u0026 Walden                                                 [Page 6]\n\f\nRFC 435                      TELNET Issues                5 January 1973\n\n\n   Once the principle of symmetry is adopted, it is no longer possible\n   to use a function in two different ways.  On pages 5 and 6 of RFC\n   318, Postel gives a description of INS and SYNC which indicates that\n   they are used to simulate a 'break' user-to-server, but flush the\n   output buffers server-to-user.  Since we do believe in symmetry, we\n   suggest that the INS/DATA-MARK be treated the same in both directions\n   and that a new CLEAR YOUR BUFFER option be added.\n\nCommand Format\n\n   Extending full symmetry through the other options we have suggested,\n   we can now describes the compacted command format referred to\n   earlier.\n\n   Rather than having four commands for each option (I WILL, I WON'T,\n   YOU DO, YOU DON'T), there would be four 'prefixes' -- WILL, WON'T,\n   DO, DON'T -- which would be used before the single command devoted to\n   each option, WON'T and DON'T being the default modes.  To give an\n   example, assume the codes for WILL and WON'T are 140 and 141, and the\n   codes for ECHO REMOTE and HIDE INPUT are 132 and 133.  Then several\n   of the possible command combinations would be:\n\n                   140 133 -- DO HIDE INPUT\n                   140 132 -- DO ECHO REMOTE\n                   141 132 -- WON'T ECHO REMOTE\n                   141 133 -- WON'T HIDE INPUT\n\n   These are some of the commands that we believe should exist:\n\n   I WILL (140)\n   I WILL NOT (141)\n   YOU DO (142)\n   YOU DO NOT (143)\n   QUOTE (144)\n   SYNC (163)\n   SYNC REPLY (164)\n\n   ECHO REMOTE (132)\n   SEND A CHARACTER-AT-A-TIME (146)\n   SEND INDEPENDENT CR and LF (147)\n   SEND IN EBCDIC (162)\n   HIDE INPUT (133)\n   USE DAVIDSON'S ECHOING STRATEGY (145)\n\n   An important virtue of this command structure, and of our entire\n   viewpoint, is that Hosts need no longer even be aware of what all the\n   options are.  If we call the mode of operation in which every\n   alternative is in its default state the 'NVT', then a site, of\n\n\n\nCosell \u0026 Walden                                                 [Page 7]\n\f\nRFC 435                      TELNET Issues                5 January 1973\n\n\n   course, must handle an NVT, but beyond that if it merely responds no\n   to any command it does not understand, then it can totally ignore\n   options it chooses not to implement.  Thus, options would truly be\n   optional (for a change), not only to the user who may choose not to\n   invoke them, but also to the systems builders who may now choose not\n   to offer them!\n\n   We hereby volunteer to rigorously specify a version of TELNET which\n   embodies the principles we have described and to do so at any level\n   of complexity deemed sufficient by the network community.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCosell \u0026 Walden                                                 [Page 8]\n\f\nRFC 435                      TELNET Issues                5 January 1973\n\n\nAppendix: A Sample Implementation\n\n   The basis scheme we described represents most of what we have been\n   thinking about the further extensions are just that, extensions.  We\n   fear, however, that some who are spiritually in league with us might\n   be frightened off by the magnitude of all the changes we suggest.  To\n   combat this, we here provide an example of how simply and straight-\n   forwardly the basis scheme could be implemented for the TIP [5].\n\n   For each user terminal the TIP would keep three state bits: whether\n   the terminal echoes for itself (NO ECHO always) or not (ECHO mode\n   possible), whether the (human) user prefers to operate in ECHO or NO\n   ECHO mode, and whether the connection to this terminal is in ECHO or\n   NO ECHO mode.  We call these three bits P(hysical), D(esired) and\n   A(ctual).\n\n   When a terminal dials up the TIP, the P-bit is set appropriately, the\n   D-bit is set equal to it, and the A-bit is set to NO ECHO.  The P-\n   and A-bits may be manually reset by direct commands if the user so\n   desires for instance, a user in Hawaii on a 'full-duplex' terminal\n   might know that whatever the preference of a mainland server, because\n   of satellite delay his terminal had better operate in NO ECHO mode --\n   he would direct the TIP to change his D-bit from ECHO to NO ECHO.\n\n   When a connection is opened from the TIP terminal to a server, the\n   TIP would send the server an ECHO command if the MIN (with NO ECHO\n   less than ECHO) of the P- and D-bits is different from the A-bit.  If\n   a NO ECHO or ECHO arrives from the server, the TIP will set the A-bit\n   to the MIN of the received request, the P-bit and D-bit.  If this\n   changes the state of the A-bit, it will send off the appropriate\n   acknowledgement if it does not, then the TIP will send off the\n   appropriate refusal if not changing meant that it had to deny the\n   request (i.e., the MIN of the P- and D- bits was less than the\n   received A- request).  If while a connection is open, the TIP\n   terminal user changes either the P- or D-bit, the TIP will repeat the\n   above tests and send off an ECHO or NO ECHO, if necessary.  When the\n   connection is closed, the TIP would reset the A-bit to NO ECHO.\n\n   While the TIP's implementation would not involve ECHO or NO ECHO\n   commands being sent to the server except when the connection is\n   opened or the user explicitly changes his echoing mode, we would\n   suppose that bigger Hosts might send these commands quite frequently.\n   For instance, if a JOSS subsystem were running, the server might put\n   the user in NO ECHO mode, but while DDT was running, the server might\n   put the user in ECHO mode.\n\n\n\n\n\n\nCosell \u0026 Walden                                                 [Page 9]\n\f\nRFC 435                      TELNET Issues                5 January 1973\n\n\n   [1] We have assumed that TELNET is defined as suggested by Jon Postel\n   in RFC 318.\n\n   [2] Notice that a faulty implementation could achieve the effect of a\n   loop by repeatedly sending a command which has previously been\n   refused.  We consider this a property of the implementation, not of\n   the scheme in general, a command which has be rejected should not be\n   repeated until something changes -- for instance, not until after a\n   different program has been started up.\n\n   [3] Will Crowther, with an eye towards building higher protocols upon\n   TELNET, has suggested that a SYNC command (not to be confused with\n   the existing SYNCH), and a SYNC REPLY be added to TELNET.  For\n   example, a server might want to wait until the output buffer of a\n   user's terminal were empty before doing something like closing the\n   connection or passing the connection to another server.  Although we\n   see no current use for the command pair, they seem to be a handy\n   enough building block that we recommend that they be included.\n\n   [4] It is perhaps appropriate to mention that most of the connections\n   in the network are TELNET connections, which are full duplex.\n   Wouldn't it be reasonable to make all Host/Host protocol connections\n   full duplex, rather than simplex? If, for some reason, one truly\n   needs a simplex connection, the reverse direction can always just be\n   ignored.\n\n   [5] Readers unfamiliar with the TIP may read the TIP Users Guide --\n   NIC 10916.\n\n\n\n\n\n\n\n\n\n\n\n        [This RFC was put into machine readable form for entry]\n    [into the online RFC archives by Helene Morin, Via Genie, 12/99]\n\n\n\n\n\n\n\n\n\n\nCosell \u0026 Walden                                                [Page 10]\n\f\n"
}