{
  "series": "Request for Comments",
  "number": "33",
  "howpublished": "RFC 33",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0033",
  "url": "https://www.rfc-editor.org/info/rfc33",
  "title": "New Host-Host Protocol",
  "pagetotal": "19",
  "year": "1970",
  "month": "feb",
  "body": "\n\n\n\n\n\nNetwork Working Group                                         S. Crocker\nRequest for Comments: 33                                            UCLA\n                                                                 S. Carr\n                                                      University of Utah\n                                                                 V. Cerf\n                                                                    UCLA\n                                                        12 February 1970\n\n\n                         New HOST-HOST Protocol\n\n   Attached is a copy of the paper to be presented at the SJCC on the\n   HOST-HOST Protocol.  It indicates many changes from the old protocol\n   in NWG/RFC 11; these changes resulted from the network meeting on\n   December 8, 1969.  The attached document does not contain enough\n   information to write a NCP, and I will send out another memo or so\n   shortly.  Responses to this memo are solicited, either as NWG/RFC's\n   or personal notes to me.\n\n\n                     HOST-HOST Communication Protocol\n                           in the ARPA Network*\n\n   by C. Stephen Carr\n   University of Utah\n   Salt Lake City, Utah\n\n   and\n\n   by Stephen D. Crocker\n   University of California\n   Los Angeles, California\n\n   and\n\n   by Vinton G. Cerf\n   University of California\n   Los Angeles, California\n\n   *This research was sponsored by the Advanced Research Projects\n   Agency, Department of Defense, under contracts AF30(602)-4277 and\n   DAHC15-69-C-0825.\n\nINTRODUCTION\n\n   The Advanced Research Projects Agency (ARPA) Computer Network\n   (hereafter referred to as the \"ARPA network\") is one of the most\n   ambitious computer networks attempted to date.  [1]  The types of\n\n\n\nCrocker, et. al.                                                [Page 1]\n\f\nRFC 33                   New HOST-HOST Protocol         12 February 1970\n\n\n   machines and operating systems involved in the network vary widely.\n   For example, the computers at the first four sites are an XDS 940\n   (Stanford Research Institute), an IBM 360/75 (University of\n   California, Santa Barbara), an XDS SIGMA-7 (University of California,\n   Los Angeles), and a DEC PDP-10 (University of Utah).  The only\n   commonality among the network membership is the use of highly\n   interactive time-sharing systems; but, of course, these are all\n   different in external appearance and implementation.  Furthermore, no\n   one node is in control of the network.  This has insured reliability\n   but complicates the software.\n\n   Of the networks which have reached the operational phase and been\n   reported in the literature, none have involved the variety of\n   computers and operating systems found in the ARPA network.  For\n   example, the Carnegie-Mellon, Princeton, IBM network consists of\n   360/67's with identical software. [2]  Load sharing among identical\n   batch machines was commonplace at North American Rockwell Corporation\n   in the early 1960's.  Therefore, the implementers of the present\n   network have been only slightly influenced by earlier network\n   attempts.\n\n   However, early time-sharing studies at the University of California\n   at Berkeley, MIT, Lincoln Laboratory, and System Development\n   Corporation (all ARPAA sponsored) have had considerable influence on\n   the design of the network.  In some sense, the ARPA network of time-\n   shared computers is a natural extension of earlier time-sharing\n   concepts.\n\n   The network is seen as a set of data entry and exit points into which\n   individual computers insert messages destined for another (or the\n   same) computer, and from which such messages emerge.  The format of\n   such messages and the operation of the network was specified by the\n   network contractor (BB\u0026N) and it became the responsibility of\n   representatives of the various computer sites to impose such\n   additional constraints and provide such protocol as necessary for\n   users at one site to use resources at foreign sites.  This paper\n   details the decisions that have been made and the considerations\n   behind these decisions.\n\n   Several people deserve acknowledgement in this effort.  J. Rulifson\n   and W. Duvall of SRI participated in the early design effort of the\n   protocol and in the discussions of NIL.  G. Deloche of Thompson-CSF\n   participated in the design effort while he was at UCLA and provided\n   considerable documentation.  J. Curry of Utah and P. Rovner of\n   Lincoln Laboratory reviewed the early design and NIL.  W. Crowther of\n   Bolt, Beranek and Newman, contributed the idea of a virtual net.  The\n   BB\u0026N staff provided substantial assistance and guidance while\n   delivering the network.\n\n\n\nCrocker, et. al.                                                [Page 2]\n\f\nRFC 33                   New HOST-HOST Protocol         12 February 1970\n\n\n   We have found that, in the process of connecting machines and\n   operating systems together, a great deal of rapport has been\n   established between personnel at the various network node sites.  The\n   resulting mixture of ideas, discussions, disagreements, and\n   resolutions has been highly refreshing and beneficial to all\n   involved, and we regard the human interaction as a valuable by-\n   product of the main effect.\n\nTHE NETWORK AS SEEN BY THE HOSTS\n\n   Before going on to discuss operating system communication protocol,\n   some definitions are needed.\n\n      A HOST is a computer system which is a part of the network,\n\n      An IMP (Interface Message Processor) is a Honeywell DDP-516\n      computer which interfaces with up to four HOSTs at a particular\n      site, and allows HOSTs access into the network.  The configuration\n      of the initial four-HOST network is given in figure 1.  The IMPs\n      from a store-and-forward communications network.  A companion\n      paper in these proceedings covers the IMPs in some detail. [3]\n\n   A message is a bit stream less than 8096 bits long which is given to\n   an IMP by a HOST for transmission to another HOST.  The first 32 bits\n   of the message are the leader.  The leader contains the following\n   information:\n\n      (a) HOST\n      (b) Message Type\n      (c) Flags\n      (d) Link Number\n\n   When a message is transmitted from a HOST to its IMP, the HOST field\n   of the leader names the receiving HOST.  When the message arrives at\n   the receiving HOST, the HOST field names the sending HOST.\n\n   Only two message types are of concern in this paper.  Regular\n   messages are generated by a HOST and sent to its IMP for transmission\n   to a foreign HOST.  The other message type of interest is a RFNM\n   (Request-for-Next-Message).  RFNM's are explained in conjunction with\n   links.\n\n   The flag field of the leader controls special cases not of concern\n   here.\n\n\n\n\n\n\n\nCrocker, et. al.                                                [Page 3]\n\f\nRFC 33                   New HOST-HOST Protocol         12 February 1970\n\n\n   The link number identifies over which of 256 logical paths (links)\n   between the sending HOST and the receiving HOST the message will be\n   sent.  Each link is unidirectional and is controlled by the network\n   so that no more than one message at a time may be sent over it.  This\n   control is implemented using RFNM messages.  After a sending HOST has\n   sent a message to a receiving HOST over a particular link, the\n   sending HOST is prohibited from sending another message over that\n   same link until the sending HOST receives a RFMN.  The RFNM is\n   generated by the IMP connected to the receiving HOST, and the RFNM is\n   sent back to the sending HOST after the message has entered the\n   receiving HOST.  It is important to remember that there are 356 links\n   in each direction and that no relationship among these is imposed by\n   the network.\n\n   The purpose of the link and RFMN mechanism is to prohibit individual\n   users from overloading an IMP or a HOST.  Implicit in this purpose is\n   the assumption that a user does not use multiple links to achieve a\n   wide band, and to a large extent the HOST-HOST protocol cooperates\n   with this assumption.  An even more basic assumption, of course, is\n   that the network's load comes from some users transmitting sequences\n   of messages rather than many users transmitting single messages\n   coincidently.\n\n   In order to delimit the length of the message, and to make it easier\n   for HOSTs of differing word lengths to communicate, the following\n   formatting procedure is used.  When a HOST prepares a message for\n   output, it creates a 32-bit leader.  Following the leader is a binary\n   string, called marking, consisting of an arbitrary number of zeros,\n   followed by one.  Marking makes is possible for the sending HOST to\n   synchronize the beginning of the text message with its word\n   boundaries.  When the last bit of a message has entered an IMP, the\n   hardware interface between the IMP and HOST appends a one followed by\n   enough zeros to make the message length a multiple of 16 bits.  These\n   appended bits are called padding.  Except for the marking and\n   padding, no limitations are placed on the text of a message.  Figure\n   2 shows a typical message sent by a 24-bit machine.\n\nDESIGN CONCEPTS\n\n   The computers participating in the network are alike in two important\n   respects: each supports research independent of the network, and each\n   is under the discipline of a time-sharing system.  These facts\n   contributed to the following design philosophy.\n\n   First, because the computers in the network have independent purposes\n   it is necessary to preserve decentralized administrative control of\n   the various computers.  Since all of the time-sharing supervisors\n   possess elaborate and definite accounting and resource allocation\n\n\n\nCrocker, et. al.                                                [Page 4]\n\f\nRFC 33                   New HOST-HOST Protocol         12 February 1970\n\n\n   mechanisms, we arranged matters so that these mechanisms would\n   control the load due to the network in the same way that they control\n   locally generated load.\n\n   Second, because the computers are all operated under time-sharing\n   disciplines, it seemed desirable to facilitate basic interactive\n   mechanisms.\n\n   Third, because this network is used by experienced programmers it was\n   imperative to provide the widest latitude in using the network.\n   Restrictions concerning character sets, programming languages, etc.\n   would not be tolerated and we avoided such restrictions.\n\n   Fourth, again because the network is used by experienced programmers,\n   it was felt necessary to leave the design open-ended.  We expect that\n   conventions will arise from time to time as experience is gained, but\n   we felt constrained not to impose them arbitrarily.\n\n   Fifth, in order to make network participation comfortable, or in some\n   cases, feasible, the software interface to the network should require\n   minimal surgery on the HOST operating system.\n\n   Finally, we except the assumption stated above that network use\n   consists of prolonged conversations instead of one-shot requests.\n\n   These considerations led to the notions of connections, a Network\n   Control Program, a control link, control commands, sockets, and\n   virtual nets.\n\n   A connection is an extension of a link.  A connection connects two\n   processes so that output from one process is input to the other.\n   Connections are simplex, so two connections are needed if two\n   processes are to converse in both directions.\n\n   Processes within a HOST communicate with the network through a\n   Network Control Program (NCP).  In most HOSTs, the NCP will be a part\n   of the executive, so that processes will use system calls to\n   communicate with it.  The primary function of the NCP is to establish\n   connections, break connections, switch connections, and control flow.\n\n   In order to accomplish its tasks, a NCP in one HOST must communicate\n   with a NCP in another HOST.  To this end, a particular link between\n   each pair of HOSTs has been designated as the control link.  Messages\n   received over the control link are always interpreted by the NCP as a\n   sequence of one or more control commands.  As an example, one of the\n   kinds of control commands is used to assign a link and initiate a\n\n\n\n\n\nCrocker, et. al.                                                [Page 5]\n\f\nRFC 33                   New HOST-HOST Protocol         12 February 1970\n\n\n   connection, while another kind carries notification that a connection\n   has been terminated.  A partial sketch of the syntax and semantics of\n   control commands is given in the next section.\n\n   A major issue is how to refer to processes in a foreign HOST.  Each\n   HOST has some internal naming scheme, but these various schemes often\n   are incompatible.  Since it is not practical to impose a common\n   internal process naming scheme, an intermediate name space was\n   created with a separate portion of the name space given to each HOST.\n   It is left to each HOST to map internal process identifiers into its\n   name space.\n\n   The elements of the name space are called sockets.  A socket forms\n   one end of a connection, and a connection is fully specified by a\n   pair of sockets.  A socket is specified by the concatenation of three\n   numbers:\n\n      (a) a user number (24 bits)\n      (b) a HOST number (8 bits)\n      (c) AEN (8 bits)\n\n   A typical socket is illustrated in Figure 3.\n\n   Each HOST is assigned all sockets in the name space which have field\n   (b) equal to the HOST's own identification.\n\n   A socket is either a receive socket or a send socket, and is so\n   marked by the lower-order bit of the AEN (0 = receive, 1 = send).\n   The other seven bits of the AEN simply provide a sizable population\n   of sockets for each used number at each HOST.  (AEN stands for\n   \"another eight-bit number\")\n\n   Each user is assigned a 24-bit user number which uniquely identifies\n   him throughout the network.  Generally this will be the 8-bit HOST\n   number of his home HOST, followed by 16 bits which uniquely identify\n   him at that HOST.  Provision can also be made for a user to have a\n   user number not keyed to a particular HOST, an arrangement desirable\n   for mobile users who might have no home HOST or more than one home\n   HOST.  This 24-bit user number is then used in the following manner.\n   When a user signs onto a HOST, his user number is looked up.\n   Thereafter, each process the user creates is tagged with his user\n   number.  When the user signs onto a foreign HOST via the network, his\n   same user number is used to tag processes he creates in that HOST.\n   The foreign HOST obtains the user number either by consulting a table\n   at login time, as the home HOST does, or by noticing the\n   identification of the caller.  The effect of propagating the user's\n   number is that each user creates his own virtual net consisting of\n   processes he has created.  This virtual net may span an arbitrary\n\n\n\nCrocker, et. al.                                                [Page 6]\n\f\nRFC 33                   New HOST-HOST Protocol         12 February 1970\n\n\n   number of HOSTs.  It will thus be easy for a user to connect his\n   processes in arbitrary ways, while still permitting him to connect\n   his processes with those in other virtual nets.\n\n   The relationship between sockets and processes is now describable\n   (see Figure 4).  For each user number at each HOST, there are 128\n   send sockets and 128 receive sockets.  A process may request from the\n   local NCP the use of any one of the sockets with the same user\n   number; the request is granted if the socket is not otherwise in use.\n   The key observation here is that a socket requested by a process\n   cannot already be in use unless it is by some other process within\n   the same virtual net, and such a process is controlled by the same\n   user.\n\n   An unusual aspect of the HOST-HOST protocol is that a process may\n   switch its end of a connection from one socket to another.  The new\n   socket may be in any virtual net and at any HOST, and the process may\n   initiate a switch either at the time the connection is being\n   established, or later.  The most general forms of switching entail\n   quite complex implementation, and are not germane to the rest of this\n   paper, so only a limited form will be explained.  This limited form\n   of switching provides only that a process may substitute one socket\n   for another while establishing a connection.  The new socket must\n   have the same user number and HOST number, and the connection is\n   still established to the same process.  This form of switching is\n   thus only a way of relabelling a socket, for no charge in the routing\n   of messages takes place.  In the next section we document the system\n   calls and control commands; in the section after next, we consider\n   how login might be implemented.\n\nSYSTEM CALLS AND CONTROL COMMANDS\n\n   Here we sketch the mechanisms of establishing, switching and breaking\n   a connection.  As noted above, the NCP interacts with user processes\n   via system calls and with other NCPs via control commands.  We\n   therefore begin with a partial description of system calls and\n   control commands.\n\n   System calls will vary from one operating system to another, so the\n   following description is only suggestive.  We assume here that a\n   process has several input-output paths which we will call ports.\n   Each port may be connected to a sequential I/O device, and while\n   connected, transmits information in only one direction.  We further\n   assume that the process is blocked (dismissed, slept) while\n   transmission proceeds.  The following is the list of system calls:\n\n\n\n\n\n\nCrocker, et. al.                                                [Page 7]\n\f\nRFC 33                   New HOST-HOST Protocol         12 February 1970\n\n\n            Init      \u003cport\u003e, \u003cAEN 1\u003e, \u003cAEN 2\u003e, \u003cforeign socket\u003e\n\n      where \u003cport\u003e is part of the process issuing the Init\n                     _\n            \u003cAEN 1\u003e   |\n      and             +- are 8-bit AEN's (see Figure 2)\n            \u003cAEN 2\u003e   |\n                     _|\n\n            The first AEN is used to initiate the connection; the second\n            is used while the connection exists.\n\n            \u003cforeign socket\u003e is the 40-bit socket name of the distant\n            end of the connection.\n\n            The lower-order bits of \u003cAEN 1\u003e and \u003cAEN 2\u003e must agree, and\n            these must be the complement of the lower-order bit of\n            \u003cforeign socket\u003e.\n\n            The NCP concatenates \u003cAEN 1\u003e and \u003cAEN 2\u003e each with the user\n            number of the process and the HOST number to form 40-bit\n            sockets.  It then sends a Request for Connection (RFC)\n            control command to the distant NCP.  When the distant NCP\n            responds positively, the connection is established and the\n            process is unblocked.  If the distant NCP responds\n            negatively, the local NCP unblocks the requesting process,\n            but informs it that the system call has failed.\n\n            Listen \u003cport\u003e, \u003cAEN 1\u003e\n\n      where \u003cport\u003e and \u003cAEN 1\u003e are as above.  The NCP retains the ports\n            and \u003cAEN 1\u003e and blocks the process.  When an RFC control\n            command arrives naming the local socket, the process is\n            unblocked and notified that a foreign process is calling.\n\n            Accept \u003cAEN 2\u003e\n\n            After a Listen has been satisfied, the process may either\n            refuse the call or accept it and switch it to another\n            socket.  To accept the call, the process issues the Accept\n            system call.  The NCP then sends back an RFC control\n            command.\n\n            Close \u003cport\u003e\n\n            After establishing a connection, a process issues a Close to\n            break the connection.  The Close is also issued after a\n            Listen to refuse a call.\n\n\n\nCrocker, et. al.                                                [Page 8]\n\f\nRFC 33                   New HOST-HOST Protocol         12 February 1970\n\n\n            Transmit \u003cport\u003e, \u003caddr\u003e\n\n            If \u003cport\u003e is attached to a send socket, \u003caddr\u003e points to a\n            message to be sent.  This message is preceded by its length\n            in bits.\n\n            If \u003cport\u003e is attached to a receive socket, a message is\n            stored at \u003caddr\u003e.  The length of the message is stored\n            first.\n\nControl Commands\n\n   A vocabulary of control commands has been defined for communication\n   between Network Control Programs.  Each control command consists of\n   an 8-bit operation code to indicate its function, followed by some\n   parameters.  The number and format of parameters is fixed for each\n   operation code.  A sequence of control commands destined for a\n   particular HOST can be packed into a single control message.\n\n      RFC   \u003cmy socket 1\u003e, \u003cmy socket 2\u003e.\n\n            \u003cyour socket\u003e, (\u003clink\u003e)\n\n   This command is sent because a process has executed either an Init\n   system call or an Accept system call.  A link is assigned by the\n   prospective receiver, so it is omitted if \u003cmy socket 1\u003e is a send\n   socket.\n\n   There is distinct advantage in using the same commands both to\n   initiate a connection (Init) and to accept a call (Accept).  If the\n   responding command were different from the initiating command, then\n   two processes could call each other and become blocked waiting for\n   each other to respond.  With this scheme, no deadlock occurs and it\n   provides a more compact way to connect a set of processes.\n\n      CLS      \u003cmy socket\u003e, \u003cyour socket\u003e\n\n   The specified connection is terminated\n\n      CEASE    \u003clink\u003e\n\n   When the receiving process does not consume its input as fast as it\n   arrives, the buffer space in the receiving HOST is used to queue the\n   waiting messages.  Since only limited space is generally available,\n   the receiving HOST may need to inhibit the sending HOST from sending\n   any more messages over the offending connection.  When the sending\n   HOST receives this command, it may block the process generating the\n   messages.\n\n\n\nCrocker, et. al.                                                [Page 9]\n\f\nRFC 33                   New HOST-HOST Protocol         12 February 1970\n\n\n      RESUME   \u003clink\u003e\n\n   This command is also sent from the receiving HOST to the sending HOST\n   and negates a previous CEASE.\n\nLOGGING IN\n\n   We assume that within each HOST there is always a process in\n   execution which listens to login requests.  We call this process the\n   logger, and it is part of a special virtual net whose user number is\n   zero.  The logger is programmed to listen to calls on socket number\n   0.  Upon receiving a call, the logger switches it to a higher (even)\n   numbered sockets, and returns a call to the socket numbered one less\n   than the send socket originally calling.  In this fashion, the logger\n   can initiate 127 conversations.\n\n   To illustrate, assume a user whose identification is X'010005' (user\n   number 5 at UCLA) signs into UCLA, starts up one of his programs, and\n   this program wants to start a process at SRI.  No process except the\n   logger is currently willing to listen to our user, so he executes\n\n         Init, \u003cport\u003e = 1, \u003cAEN 1\u003e = 7, \u003cAEN 2\u003e = 7,\n\n               \u003cforeign socket\u003e = 0\n\n   His process is blocked, and the NCP at UCLA sends\n\n         RFC   \u003cmy socket 1\u003e = X'0100050107',\n\n               \u003cmy socket 2\u003e = X'0100050107',\n\n               \u003cyour socket\u003e = X'000000200'\n\n   The logger at SRI is notified when this message is received, because\n   it has previously executed\n\n         Listen   \u003cport\u003e = 9, \u003cAEN 1\u003e = 0.\n\n   The logger then executes\n\n         Accept   \u003cAEN 2\u003e = 88.\n\n\n\n\n\n\n\n\n\n\nCrocker, et. al.                                               [Page 10]\n\f\nRFC 33                   New HOST-HOST Protocol         12 February 1970\n\n\n   In response to the Accept, the SRI NCP sends\n\n         RFC   \u003cmy socket 1\u003e = X'0000000200'\n\n               \u003cmy socket 2\u003e = X'0000000258'\n\n               \u003cyour socket\u003e = X'0100050107'\n\n               \u003clink\u003e = 37\n\n   where the link has been chosen from the set of available links.  The\n   SRI logger than executes\n\n         Init     \u003cport\u003e = 10\n\n               \u003cAEN 1\u003e = 89, \u003cAEN 2\u003e = 89,\n\n               \u003cforeign socket\u003e = X'0100050106'\n\n   which causes the NCP to send\n\n         RFC   \u003cmy socket 1\u003e = X'0000000259'\n\n               \u003cmy socket 2\u003e = x'0000000259'\n\n               \u003cyour socket\u003e = X'0100050106'\n\n   The process at UCLA is unblocked and notified of the successful Init.\n   Because SRI logger always initiates a connection to the AEN one less\n   than it has just been connected to, the UCLA process then executes\n\n         Listen   \u003cport\u003e = 11\n\n               \u003cAEN 1\u003e = 6\n\n   and when unblocked\n\n         Accept   \u003cAEN 2\u003e = 6\n\n   When these transactions are complete, the UCLA process is doubly\n   connected to the logger at SRI.  The logger will then interrogate the\n   UCLA process, and if satisfied, create a new process at SRI.  This\n   new process will be tagged with user number X'010005', and both\n   connections wil be switched to the new process.  In this case,\n   switching the connections to the new process corresponds to \"passing\n   the console down\" in many time-sharing systems.\n\n\n\n\n\nCrocker, et. al.                                               [Page 11]\n\f\nRFC 33                   New HOST-HOST Protocol         12 February 1970\n\n\nUSER LEVEL SOFTWARE\n\n   At the user level, subroutines which manage data buffer and format\n   input designed for other HOSTs are provided.  It is not mandatory\n   that the user use such subroutines, since the user has access to the\n   network system calls in his monitor.\n\n   In addition to user programming access, it is desirable to have a\n   subsystem program at each HOST which makes the network immediately\n   accessible from a teletype-like device without special programming.\n   Subsystems are commonly used system components such as text editors,\n   compilers and interpreters.  An example of a network-related\n   subsystem is TELNET, which will allow users at the University of Utah\n   to connect to Stanford Research Institute and appear as regular\n   terminal users.  It is expected that more sophisticated subsystems\n   will be developed in time, but this basic one will render the early\n   network immediately useful.\n\n   A user at the University of Utah (UTAH) is sitting at a teletype\n   dialed into the University's PDP-10/50 time-sharing system.  He\n   wishes to operate the Conversational Algebraic Language (CAL)\n   subsystem on the XDS-940 at Stanford Research Institute (SRI) in\n   Menlo Park, California.  A typical TELNET dialog is illustrated in\n   Figure 5.  The meaning of each line of dialogue is discussed here.\n\n      (i)      The user signs in at UTAH\n\n      (ii)     The PDP-10 run command starts up the TELNET subsystem at\n               the user's HOST.\n\n      (111)    The user identifies a break character which causes any\n               message following the break to be interpreted locally\n               rather than being sent on the foreign HOST.\n\n      (iv)     The TELNET subsystem will make the appropriate system\n               calls to establish a pair of connections to the SRI\n               logger.  The connections will be established only if SRI\n               accepts another foreign user.\n\n   The UTAH user is now in the pre-logged-in state at SRI.  This is\n   analogous to the standard teletype user's state after dialing into a\n   computer and making a connection but before typing anything.\n\n      (v)      The user signs in to SRI with a standard login command.\n               Characters typed on the user's teletype are transmitted\n               unaltered through the PDP-10 (user HOST) and on to the\n               940 (serving HOST).  The PDP-10 TELNET will have\n               automatically switched to full-duplex, character-by-\n\n\n\nCrocker, et. al.                                               [Page 12]\n\f\nRFC 33                   New HOST-HOST Protocol         12 February 1970\n\n\n               character transmission, since this is required by SRI's\n               940.  Full duplex operation is allowed for by the PDP-10,\n               though not used by most Digital Equipment Corporations\n               subsystems.\n\n      (vi) and (vii) The 940 subsystem, CAL, is started.\n\n   At this point, the user wishes to load a local CAL file into the 940\n   CAL subsystem, from the file system on his local PDP-10.\n\n      (viii)   CAL is instructed to establish a connection to UTAH in\n               order to receive this file.  \"NETWRK\" is a predefined 940\n               name similar in nature to \"PAPER TYPE\" or \"TELETYPE\".\n\n      (ix)     Finally, the user types the break character (#) followed\n               by a command to his PDP-10 TELNET program, which sends\n               the desired file to SRI from Utah on the connection just\n               established for this purpose.  The user's next statement\n               is in CAL again.\n\n   The TELNET subsystem coding should be minimal for it is essentially a\n   shell program built over the network system calls.  It effectively\n   established a shunt in the user HOST between the remote user and a\n   distant serving HOST.\n\n   Given the basic system primitives, the TELNET subsystem at the user\n   HOST and a manual for the serving HOST, the network can be profitably\n   employed by remote users today.\n\nHIGHER LEVEL PROTOCOL\n\n   The network poses special problems where a high degree of interaction\n   is required between the user and a particular subsystem in a foreign\n   HOST.  These problems arise due to heterogeneous consoles, local\n   operating systems overhead, and network transmission delays.  Unless\n   we use special strategies it may be difficult or even impossible for\n   a distant user to make use of the more sophisticated subsystems\n   offered.  While these difficulties are especially severe in the area\n   of graphics, problems may arise even for teletype interaction.  For\n   example, suppose that a foreign subsystem is designed for teletype\n   consoles connected by telephone, and then this subsystem becomes\n   available to network users.  This subsystem might have the following\n   characteristics.\n\n      1. Except for echoing and correction of mistyping, no action is\n         taken until a carriage return is typed.\n\n\n\n\n\nCrocker, et. al.                                               [Page 13]\n\f\nRFC 33                   New HOST-HOST Protocol         12 February 1970\n\n\n      2. All characters except \"^\", and \"\u003c-\" and carriage returns are\n         echoed as the character is typed.\n\n      3. \u003c- causes deletion of the immediately preceding character, and\n         is echoed as that character.\n\n      4. ^ causes all previously typed characters to be ignored.  A\n         carriage return and line feed are echoed.\n\n      5. A carriage return is echoed as a carriage return followed by a\n         line feed.\n\n   If each character typed is sent in its own message, then the\n   characters\n\n      H E L L O \u003c- \u003c- P c.r.\n\n   cause nine messages in each direction.  Furthermore, each character\n   is handled by a user level program in the local HOST before being\n   sent to the foreign HOST.\n\n   Now it is clear that if this particular example were important, we\n   would quickly implement rules 1 to 5 in a local HOST program and send\n   only complete lines to the foreign HOST.  If the foreign HOST program\n   could not be modified so as to not generate echoes, then the local\n   program could not only echo properly, it could also throw away the\n   later echoes from the foreign HOST.  However, the problem is not any\n   particular interaction scheme; the problem is that we expect many of\n   these kinds of schemes to occur.  We have not found any general\n   solutions to these problems, but some observations and conjectures\n   may lead the way.\n\n   With respect to heterogeneous consoles, we note that although\n   consoles are rarely compatible, many are equivalent.  It is probably\n   reasonable to treat a model 37 teletype as the equivalent of an IBM\n   2741.  Similarly, most storage scopes will form an equivalence class,\n   and most refresh display scopes will form another.  Furthermore, a\n   hierarchy might emerge with members of one class usable in place of\n   those in another, but not vice versa.  We can imagine that any scope\n   might be an adequate substitute for a teletype, but hardly the\n   reverse.  This observation leads us to wonder if a network-wide\n   language for consoles might be possible.  Such a language would\n   provide for distinct treatment of different classes of consoles, with\n   semantics appropriate to each class.  Each site could then write\n   interface programs for its consoles to make them look like network\n   standard devices.\n\n\n\n\n\nCrocker, et. al.                                               [Page 14]\n\f\nRFC 33                   New HOST-HOST Protocol         12 February 1970\n\n\n   Another observation is that a user evaluates an interactive system by\n   comparing the speed of the system's responses with his own\n   expectations.  Sometimes a user feels that he has made only a minor\n   request, so the response should be immediate; at other times he feels\n   he has made a substantial request, and is therefore willing to wait\n   for the response.  Some interactive subsystems are especially\n   pleasant to use because a great deal of work has gone into tailoring\n   the responses to the user's expectations.  In the network, however, a\n   local user level process intervenes between a local console and a\n   foreign subsystem, and we may expect the response time for minor\n   requests to degrade.  Now it may happen that all of this tailoring of\n   the interaction is fairly independent of the portion of the subsystem\n   which does the heavy computing or I/O.  In such a case, it may be\n   possible to separate a subsystem into two sections.  One section\n   would be a \"front end\" which formats output to the user, accepts his\n   input, and controls computationally simple responses such as echoes.\n   In the example above, the program to accumulate a line and generate\n   echoes would be the front end of some subsystem.  We now take notice\n   of the fact that the local HOSTs have substantial computational\n   power, but our current designs make use of the local HOST only as a\n   data concentrator.  This is somewhat ironic, for the local HOST is\n   not only poorly utilized as a data concentrator, it also degrades\n   performance because of the delays it introduces.\n\n   These arguments have led us to consider the possibility of a Network\n   Interface Language (NIL) which would be a network-wide language for\n   writing the front end of interactive subsystems.  This language would\n   have the feature that subprograms communicate through network-like\n   connections.  The strategy is then to transport the source code for\n   the front end of a subsystem to the local HOST, where it would be\n   compiled and executed.\n\n   During preliminary discussions we have agreed that NIL should have at\n   least the following semantic properties not generally found in other\n   languages.\n\n      1. Concurrency.  Because messages arrive asynchronously on\n         different connections, and because user input is not\n         synchronized with subsystem output, NIL must include semantics\n         to accurately model the possible concurrencies.\n\n      2. Program Concatenation.  It is very useful to be able to insert\n         a program in between two other programs.  To achieve this, the\n         interconnection of programs would be specified at run time and\n         would not be implicit in the source code.\n\n\n\n\n\n\nCrocker, et. al.                                               [Page 15]\n\f\nRFC 33                   New HOST-HOST Protocol         12 February 1970\n\n\n      3. Device substitutability.  It is usual to define languages so\n         that one device may be substituted for another.  The\n         requirement here is that any device can be modeled by a NIL\n         program.  For example, if a network standard display controller\n         manipulates tree-structures according to messages sent to it\n         then these structures must be easily implementable in NIL.\n\n   NIL has not been fully specified, and reservations have been\n   expressed about its usefulness.  These reservations hinge upon our\n   conjecture that it is possible to divide an interactive system into a\n   transportable front end which satisfies a user's expectations at low\n   cost and a more substantial stay-at-home section.  If our conjecture\n   is false, then NIL will not be useful; otherwise it seems worth\n   pursuing.  Testing of this conjecture and further development of NIL\n   will take priority after low level HOST-HOST protocol has stabilized.\n\nHOST/IMP INTERFACING\n\n   The hardware and software interfaces between HOST and IMP is an area\n   of particular concern for the HOST organizations.  Considering the\n   diversity of HOST computers to which a standard IMP must connect, the\n   hardware interface was made bit serial and full-duplex.  Each HOST\n   organization implements its half of this very simple interface.\n\n   The software interface is equally simple and consists of messages\n   passed back and forth between the IMP and HOST programs.  Special\n   error and signal messages are defined as well as messages containing\n   normal data.  Messages waiting in queues in either machine are sent\n   at the pleasure of the machine in which they reside with no concern\n   for the needs of the other computer.\n\n   The effect of the present software interface is the needless\n   rebuffering of all messages in the HOST in addition to the buffering\n   in the IMP.  The messages have no particular order other than arrival\n   times at the IMP.  The Network Control Program at one HOST (e.g.,\n   UTAH) needs waiting RFNM's before all other messages.  At another\n   site (e.g., SRI), the NCP could benefit by receiving messages for the\n   user who is next to be run.\n\n   What is needed is coding representing the specific needs of the HOST\n   on both sides of the interface to make intelligent decisions about\n   what to transmit next over the channel.  With the present software\n   interface, the channel in one direction once committed to a\n   particular message is then locked up for up to 80 milliseconds!  This\n   approaches one teletype character time and needlessly limits full-\n   duplex, character by character, interactions over the net.  At the\n   very least, the IMP/HOST protocol should be expended to permit each\n   side to assist the other in scheduling messages over the channels.\n\n\n\nCrocker, et. al.                                               [Page 16]\n\f\nRFC 33                   New HOST-HOST Protocol         12 February 1970\n\n\nCONCLUSIONS\n\n   At this time (February 1970) the initial network of four sites is\n   just beginning to be utilized.  The communications system of four\n   IMPs and wide band telephone lines have been operational for two\n   months.  Programmers at UCLA have signed in as users of the SRI 940.\n   More significantly, one of the authors (S. Carr) living in Palo Alto\n   uses the Salt Lake PDP-10 on a daily basis by first connecting to\n   SRI.  We thus have first hand experience that remote interaction is\n   possible and is highly effective.\n\n   Work on the ARPA network has generated new areas of interest.  NIL is\n   one example, and interprocess communication is another.  Interprocess\n   communication over the network is a subcase of general interprocess\n   communication in a multiprogrammed environment.  The mechanism of\n   connections seems to be new, and we wonder whether this mechanism is\n   useful even when the processes are within the same computer.\n\nREFERENCES\n\n   1     L. ROBERTS\n         \"The ARPA network\"\n         Invitational Workshop on Networks of Computers Proceedings\n         National Security Agency 1968 p 115 ff\n\n   2.    R M RUTLEDGE et al\n         \"An interactive network of time-sharing computers\"\n         Proceedings of the 24th National Conference\n         Association for Computing Machinery 1969 p 431 ff\n\n   3.    F E HEART  R E KAHN  S M ORNSTEIN  W R CROWTHER\n         D C WALDEN\n         \"The interface message processors for the ARPA network\"\n         These Proceedings\n\nLIST OF FIGURES\n\n   Figure 1  Initial network configuration\n\n   Figure 2  A typical message from a 24-bit machine\n\n   Figure 3  A typical socket\n\n   Figure 4  The relationship between sockets and processes\n\n   Figure 5  A typical TELNET dialog.\n\n             Underlined characters are those types by the user.\n\n\n\nCrocker, et. al.                                               [Page 17]\n\f\nRFC 33                   New HOST-HOST Protocol         12 February 1970\n\n\n                                 SRI\n                                _____\n                               /     \\\n                              |  XDS  |\n                              |  940  |\n                               \\_____/\n                                  |\n                            +----------+\n                            |    IMP   |\n                            +----------+\n                             /   |    \\\n                            /    |     \\\n                           /     |      \\  +----+    _____\n                          /      |       \\ | I  |   /     \\\n       ______     +----+ /       |        \\| M  |--|  DEC  |\n      /      \\    | I  |/        |         | P  |  | PDP-10|\n     |   IBM  |---| M  |         |         +----+   \\_____/\n     | 360/75 |   | P  |\\        |\n      \\______/    +----+ \\       |                    UTAH\n                          \\      |\n        UCSB               \\     |\n                          +----------+\n                          |    IMP   |\n                          +----------+\n                              |\n                           ___|___\n                          /       \\\n                         |   XDS   |\n                         |(sigma)-7|\n                          \\_______/\n\n                            UCLA\n\n   Figure 1 Initial network configuration\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCrocker, et. al.                                               [Page 18]\n\f\nRFC 33                   New HOST-HOST Protocol         12 February 1970\n\n\n   |\u003c------------ 24bits -----------\u003e|\n   |                                 |\n   +---------------------------------+\n   |                                 |\n   |        Leader (32 bits)         |\n   |               __________________|\n   |              | 100 ---    ----0 |\u003c----16 bits of marking\n   +--------------+------------------+\n   |                                 |\n   |                                 |\n   |   Text of messages (96 bits)    |\n   |                                 |\n   +------------------------+--------+\n   | 100-----          ----0|\n   +-------^----------------+\n           |\n           |______16 bits of padding added\n                  by the interface\n\n   Figure 2  A typical message from a 24-bit machine\n\n\n\n          24                    8          8\n   +----------------------+-----------+----------+\n   |  User Number         |           |          |\n   +----------------------+-----------+----------+\n                                |          |___AEN\n                                |\n                                |___HOST number\n   Figure 3 A typical socket\n\n\n\n              |\u003c--- connection ---\u003e|\n   +---------+                      +---------+\n   |         |        link          |         |\n   | process |--(|--------------|)--| process |\n   |         |   ^              ^   |         |\n   +---------+   |              |   +---------+\n                 |              |\n             send socket    receive socket\n\n   Figure 4 The relationship between sockets and processes\n\n         [ This RFC was put into machine readable form for entry ]\n          [ into the online RFC archives by Lorrie Shiota 08/00]\n\n\n\n\nCrocker, et. al.                                               [Page 19]\n\f\n"
}