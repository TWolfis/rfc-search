{
  "series": "Request for Comments",
  "number": "150",
  "howpublished": "RFC 150",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0150",
  "url": "https://www.rfc-editor.org/info/rfc150",
  "title": "Use of IPC Facilities: A Working Paper",
  "pagetotal": "11",
  "year": "1971",
  "month": "may",
  "body": "\n\n\n\n\n\nRichard Bl. Kalin                            Network Working Group\nMIT Lincoln Laboratory                       Request for Comments #150\n5 May 1971                                   NIC 6754\n\n\nTHE USE OF IPC FACILITIES\n\n***A WORKING PAPER***\n\nThis material has not been reviewed for public release and is intended\nonly for use within the ARPA network. It should not be quoted or cited\nin any publication not related to the ARPA network.\n\nINTRODUCTION\n\n      It is our hypothesis that the goals of interprocess communication\nare more complex than commonly realized, and that until this complexity\nis more fully understood, there will be no satisfactory implementations.\nThe objective of an IPC design must be more than that of providing a\nfacility for moving bits between otherwise independent user programs, a\nvariety of other constraints must also be satisfied.\n\n      These constraints are dictated by the eventual usage of the\nfacility. Any design that will sustain this usage pattern can be a\nsatisfactory one. If it does so efficiently, it will be said to be well\ndesigned. Furthermore, it is unimaginable that a large design effort,\nundertaken without a complete understanding of the usage it must serve,\nwill ever be well designed or even satisfactorily designed.\n\n      This paper undertakes the exposition of the types of usage to\nwhich an IPC facility would be subjected, in hopes that such a\ndiscussion will clarify the goals being pursued and will provide a\nbenchmark for gauging various implementation strategies. The difficulty\nof this task should not be underestimated. The only experience available\nfor us to draw upon is from very primitive and overly constrained IPC\nimplementations. Extrapolation from this limited usage environment to\nmore general notions has as yet no basis in real experience. Such\nspeculation is therefore subject to enormous oversight and misguided\nperspective.\n\n      In compiling this paper, it was necessary to imagine what services\na process might want from an IPC facility. The areas recognized include:\n 1) the exchange of bit encoded information via channels.\n 2) the establishment, deletion, and reassignment of these channels.\n 3) the ability to debug errors and suspected errors.\n 4) the potential to improve running efficiency.\n 5) the capacity to avoid storage allocation deadlocks.\n 6) the aided recovery from transmission errors.\n\n\n\n                                                                [Page 1]\n\f\nRFC #150                 Use of IPC Facilities                5 May 1971\n\n\nThis list is known to be incomplete. Some areas, such as understood to\nbe intelligently discussed. In other cases, omissions should be blamed\non simple oversight.\n\n      Because of these obvious problems, one should not consider any\ndocument of this kind as either authoritative or final. For this reason,\nthis paper is being kept as a computer based textfile, and so will\nremain subject to editting and rerelease whenever new insights become\nunderstood. We hope that it can remain an accurate and up to date\nstatement of the goals to which any group of IPC implementers can aspire\nand, as such, can be a guidebook to the problems that must be faced.\n\n      For several reasons no attempt shall be made here to design\nsuitable solutions to the problems raised. To be useful, such solutions\nmust be machine dependent. A so called 'general solution' would actually\nbe too clumsy and inefficient to be of any value. Secondly, we take the\npoint of view of the user, who need not be aware of the manner in which\nhis demands are carried out, so long as they can be accomplished.\nFinally, we are trying to stay aloof from the eccentricities of present\nday machine organization.\n\nIn our attempt to be implementation independent, we are admittedly\ntreading a fuzzy line. Our characterization of usage patterns presumes\nboth a system/process software organization and a computing milieu\ncapable of supporting it. Although this does not appear to significantly\naffect the generality of the document, some care must be exercised in\nthe selection of host machines.\n\n               *****\n\n      In the rest of this paper, we attempt to characterize the types of\nusage that should be anticipated by an IPC facility. The organization is\ninto titled sections, each section discussing some aspect of the\nexpected usage.\n\nABILITY TO USE VARIOUS SOURCES OF WAKEUP INFORMATION\n\n      Most processes exhibit preferences toward certain quantities of\ninput data. This preference is reflected in the amount of computing time\nthat can be expended for a given amount of input. For example, a\ncharacter translation routine might prefer eight bit quantities of\ninput. With seven or less bits no processing is possible, but once a\ncomplete character is available an entire translation cycle can\ncommence. This preference is independent of the function of the routine.\nOtherwise equivalent routines could be written that would accept one bit\nat a time. In other examples, a command interpreter might require a\ncomplete line of input, a linking loader a complete file.\n\n\n\n\n                                                                [Page 2]\n\f\nRFC #150                 Use of IPC Facilities                5 May 1971\n\n\n      Every executive system must face the problem of deciding at what\ntimes enough input is available for a given routine for it to run\nefficiently. This decision can not be taken lightly. Issuing a wakeup to\na dormant process carries with it considerable overhead -- room in core\nstorage must be made available, the program must be swapped into memory,\ntables must be updated, active registers exchanged, and the entire\nprocedure done in reverse once the process has finished. To issue a\nwakeup when there is insufficient input for the program is inefficient\nand wasteful. The amount of computing that can be done does not justify\nthe overhead that must be expended.\n\n      The problem of determining a priori the best time to issue a\nwakeup has no general solution. It depends critically upon the\nrelationship between waiting costs and running costs. Attempts to make\nreasonable predictions must contend with the tradeoff between accuracy\nand overhead. The more system code that must be run, the more overhead\nincurred and the less the final prediction means.\n\n      Although there is no general solution, help is available to the\nscheduler in specific cases. A commonly found instance is that of using\nthe receiving process to specify the number of bits that it is\nexpecting. Thus, a process may inform the supervisor/scheduler that it\nrequires fifty bits of input from some source before it is able to\ncontinue. The process can then go into the shade and it will be awakened\nwhen the required input is available.\n\n      In cases where input lengths are predetermined, this technique is\nquite satisfactory. Elsewhere, problems arise. In the case of unknown\ninput sizes, too short a prediction will give rise to the inefficiencies\nof premature scheduling, and too long a prediction may produce input\ndeadlocks.\n\n      Under these circumstances it is common to have the process tell\nthe scheduler a simple criterion that can be applied to determine if\nthere is sufficient input -- the appearance of a carriage return in the\nteletype input stream, for example. The criterion is tested either by\nsystem routines or by a low overhead user supplied routine (which in\nturn must have a criterion of its own for being awakened).  Once the\ncriterion is met, the main routine is awakened and processing continues.\n\n      Sometimes the system and user criteria work in conjunction with\none another. A user may specify an maximum character count,\ncorresponding to available buffer size, and the system may look for line\nterminators. Wakeups to the user process may appear from either source.\nAt other times the system may preempt the user's criterion. For example,\nif a process while trying to put a single character into a full buffer\nis forced into shade, it will typically not be awakened again until\nbuffer has been almost emptied. Even though the user program only wished\n\n\n\n                                                                [Page 3]\n\f\nRFC #150                 Use of IPC Facilities                5 May 1971\n\n\nroom for a single character, the system imposed a much stronger\ncriterion, namely room for N characters, on the assumption other calls\nto output characters will follow. Thus the program is forced into\noutputting in bursts and, rather than going into the shade and being\nawakened N times, each time when there is only room to output one\ncharacter, the program is awakened once and sends N characters. Program\nefficiency is appropriately improved.\n\n      A third source of criteria for deciding when to awaken the user\nprocess is the device or routine that is producing the input data. This\nsource is frequently utilized in hardware design. Many computer\nperipherals have the ability to send an end of record indication. For\nvariable length uninterpreted records this is an absolute necessity. For\nfixed length records it is a convenient double check. In the world of\ninterprocess communication an analogous feature should be available. If\nthe routine that is generating the data knows how much the receiving\nroutine will require, then this information should be made available for\nscheduling purposes. Implementing this requires a standardized way of\ndenoting logical boundaries on the stream of data flowing, through a\ncommunication channel. The markers must be recognizable by the\nscheduler/supervisor in the receiving host computer so that wakeups can\nbe issued as desired. To simplify the task of input interpretation,\nmarker pacement should also be visible to the receiving process.\n\n      The data between boundaries we shall call a logical message, since\nit is a natural unit of information exchange and since the markers\ntravel with the data through the channel. The additional information the\nmarkers provide about data flow yield many useful consequences.\nConsider, for example, two processes that always exchange 100 bit long\nlogical messages. If the receiving process is able to determine the\nlength of each logical message that arrives, there is available a simple\nfacility for error detection. If a 99 bit message arrives, it is obvious\nthat a bit has been dropped somewhere.\n\n      It should be noted that it is not always possible for the\nreceiving process to compute the positions of boundary markers in the\ninput stream. there is no reason that the information implicit is marker\nposition must also be found as part of the coded input data. Even in\ncases in which there is coding redundancy, it may be more difficult to\nextract boundary information from the rest of the input than it is to\nuse the markers explicitly.\n\nABILITY TO SEND PARTS OF LOGICAL MESSAGES\n\n      Any IPC facility, in which user storage is at all constrained, can\nnot require a process to send an entire logical message at one time. The\nconcept is only introduced to facilitate the issuing of wakeups to a\nreceiving process. What are convenient input quanta for the receiving\n\n\n\n                                                                [Page 4]\n\f\nRFC #150                 Use of IPC Facilities                5 May 1971\n\n\nprocess may not be convenient output quanta for the sending one.\nconsider the case of a process running on a small machine and sending\nmessages to a process on a large task-multiplexed machine. For\nefficiency, the receiving process requires large quantities of input\ndata at a time. Buffer space in the address space of the sending process\ncan not hold much data. The only answer is to allow the sending process\nto dump its logical message in parts and with the last part to indicate\nthat it is the end of a message.\n\nABILITY TO RECEIVE A LOGICAL MESSAGE IN PARTS\n\n      In the reverse of the above situation, a receiving process may not\nhave sufficient buffer space available to accept an entire message at\nonce. It should be possible under these circumstances to elect to accept\nthe message in parts. This is also necessary in the case of messages\nthat are too long to be buffered by the system. Unless part of the\nmessage is accepted by the receiving process, the transmission can never\nbe completed. This device also serves for the removal of very long\nmessages that appear by error in the input stream.\n\nABILITY TO FIND OUT IF A MESSAGE CAN BE SENT\n\n      If left unchecked, a routine can easily generate messages faster\nthan they can be consumed. Since any given amount of buffer capacity can\nbe quickly exhausted, there must be a way for the system to limit the\nrate at which a process produces messages. This implies that at times a\nprocess trying to send a message may be prevented from doing so because\nof buffer inavailability. If the process is forced into the shade, the\npause should not come without warning. There should be a way for the\nprocess to learn in advance if the message can be sent. A program may\nhave better things to do than wait for a buffer to become available.\n\nABILITY TO GET A GUARANTEE OF OUTPUT BUFFER SPACE\n\n      A process should be able to get guarantee from the system that a\nmessage of a certain size can be sent. This allows the process to know\nbefore a computation is made that the results can be successfully\noutput. This allocation should remain either until it is depleted or\nuntil it is changed by another allocation request.\n\n      This particular user option is sure to raise the wrath of legions\nof system programmers. From their point of view, the empty buffer space\nthat is being preallocated is necessarily being wasted. For although it\ncontains no messages, it is not available for other uses. The user, on\nthe other hand, does not correlate 'empty' with 'wasteful' nor 'full'\nwith 'efficient'. A process needs empty output buffers as much as it\nneeds full input ones. Both are resources necessary to sustain\nprocessing.\n\n\n\n                                                                [Page 5]\n\f\nRFC #150                 Use of IPC Facilities                5 May 1971\n\n\nABILITY TO FIND OUT ABOUT OUTSTANDING MESSAGES\n\n      A process that is sending messages over a channel should be able\nto find out how many of those messages have not yet been accepted by the\nuser process at the far end and whether or not this number can decrease.\nIdeally, it should also be able to determine the number of bits left in\nany partially accepted message, but the overhead necessary to implement\nthis on conventional systems may be too great to be tolerated.\n\n      The count returned can be useful both dynamically and for post\nmortems. Used in debugging a remote process, it allows inputs on\nnormally concurrent channels to be presented one at a time and in any\ngiven order. In this way one could, for example, verify that the same\nresults are produced regardless of the order in which the inputs arrive.\n\n      If there is a failure of a receiving process, this mechanism\nallows a sending process to determine the last input accepted before the\nprocess died. Even between operational processes it provides a user\nmanaged way for the transmitting process to slow down and let the\nreceiver catch up with it. By pinpointing bottlenecks, it can be used to\ndetect design mismatches.\n\n      Unless the channel has no outstanding messages or it is dead,\nthere is the possibility that concurrently with the request the\nreceiving process will accept another message. This being the case, the\ncount returned can not be assumed to be exact but must be considered as\nonly an upper bound.\n\nABILITY TO GET WAKEUPS WHEN MESSAGES ARE ACCEPTED\n\n      In conjunction with the above it should be possible for a user\nprocess to be alerted when the number of messages that have been sent\nover a particular channel and not accepted at the far end falls below a\nspecified threshold. Thus a process, upon discovering that twenty\nmessages are still outstanding, can elect to enter the shade until this\nnumber has fallen to less than five. By doing so the process can run in\n'burst mode'. Rather than being swapped in and out of core fifteen times\nand each time being allowed to send one message, it is loaded once and\nsends fifteen messages. There is no penalty for doing this since the\nbottleneck on throughput is at the receiving process. If swapping costs\nfor the local process are significant, there may be considerable\neconomic advantage to this mode of operation.\n\n      If the remote process dies or issues a channel 'close', the count\nof undelivered messages becomes frozen. If the receiving process is\nexpecting this type of wakeup, it should get one at this time even\nthough the count has not reached the desired threshold. The process is\nthus alerted to do a postmortem on the channel.\n\n\n\n                                                                [Page 6]\n\f\nRFC #150                 Use of IPC Facilities                5 May 1971\n\n\nABILITY TO LEARN ABOUT MESSAGES QUEUED FOR INPUT\n\n      A process should be able to learn of the status of the Nth logical\nmessage queued on a given input channel. It should a least be able to\ndetermine if it is available, whether or not it is complete, how long it\nis and what it contains.\n\n      This facility allows a program to make general preparations before\naccepting a message. It offers some escape from being put into the\nawkward position of having accepted input and not being able to dispose\nof it. If for example, it is known that processing the message will\nresult in two more messages being sent, then it is advantageous to get\nguarantees that the output can be generated before the input is\naccepted.\n\n      Under circumstances in which one end of a channel is moved from\none process to another, for example, moving a teletype connection\nbetween a user program and a debugging program, this ability to scan\nahead in the input stream allows a process to check whether or not\npending input is really meant for it. If it is, the input will then be\naccepted normally, otherwise, the end of the channel must be first moved\nto another receiving process.\n\n      Accepting input should be viewed as a grave responsibility, not to\nbe undertaken unless there is reasonable assurance that the input can be\nprocessed. One of the first rules of asynchronous system design is to\ndetect errors as soon as possible. If propagated, the tangled results\nmay be hopeless to unravel.\n\nABILITY TO LEARN HOW MANY MESSAGES ARE WAITING\n\n      A process should be able to determine how many messages are\nleft to be processed on a given input channel. Two uses are readily\nthought of. Given pending inputs on several channels a process should be\nable to exercise preference. One decision might be to take input first\nfrom the channel with the most messages queued. This might have the\neffect of increasing throughput since by freeing message buffers the\nremote transmitting process might be allowed to run. Another possibility\nmight be that the receiving process has some control over the sending\nprocess and, upon observing the backlog on inputs, it could tell that\nprocess to slow down.\n\n      Assuming that the remote process is still able to send messages,\nthe number of inputs reported is only a lower bound. New inputs may be\nadded concurrently. If the foreign process has died or has otherwise\nclosed the connection then the bound can be made exact. The local\nprocess should be able to learn when it is exact.\n\n\n\n\n                                                                [Page 7]\n\f\nRFC #150                 Use of IPC Facilities                5 May 1971\n\n\nGUARANTEE THAT INPUT WILL STAY AVAILABLE\n\n      This requirement states that if a process has been told that it is\nable to receive N messages on a given channel, that those messages are\nreally available and buffered within the host machine. If promised to a\nuser process, messages should not mysteriously become unavailable. An\nexample of how this might happen is illustrated in RFC60.  There, during\na panic for buffer space, messages are destroyed and reported as being\nin error. They are later recovered from backup copies contained in the\nforeign host.\n\nABILITY TO RECEIVE A WAKEUP WHEN INPUTS ARRIVE\n\n      A process should be able to enable a wakeup when the number of\nmessages queued on an input channel exceeds a specified value or has\nreached its maximum value. This allows a program to process input in a\nburst mode fashion and to economize on swapping costs. It also permits\ninputs to be combined in a simple manner. If, for example, two inputs\nare needed before anything can be done, then the appropriate interrupt\ncan be easily generated.\n\n      The same interrupt should be generated if the maximum number of\ninputs have been received. Two cases are distinguished. Either the\nforeign process has closed the channel and is therefore not sending more\nmessages, or the system will not allocate more buffers until some input\nis accepted. In this way the process can be informed that there is no\npoint in waiting for the condition it anticipates.\n\nABILITY TO SPECIFY SPECIAL WAKEUPS\n\n      A process, when trying to run efficiently, should be able to\nspecify arbitrarily complicated wakeup conditions. This allows a user\nmanaged way of minimizing the number of premature wakeups. This\ngenerality is perhaps most easily provided for by allowing the main\nprocess to designate a small low overhead interrupt driven routine that\nwill check for the desired conditions and issue a wakeup to the main\nprocess whenever they are met.\n\nABILITY TO MEASURE CHANNEL CAPACITY\n\n      There has been much discussion about the measure of a data stream\nand in the heat of committee, much confusion has been generated. It is\nour feeling that, within the present domain of discussion, there is no\nsingle measure of the capacity of a message channel. Two completely\northogonal concepts must be measured -- 1) the number of messages\nbuffered and 2) the number of bits of encoded data represented. The\nsystem overhead associated with each is very much implementation\ndependent and hence no general equation can express the measure of one\n\n\n\n                                                                [Page 8]\n\f\nRFC #150                 Use of IPC Facilities                5 May 1971\n\n\nin terms of the other. By making an arbitrary assumption (eg. a message\nboundary equals 100 bits of buffer), a system runs the risk of excluding\nnew nodes that are unable to meet the old criterion.\n\nABILITY TO FIND OUT MAXIMUM CHANNEL CAPACITY\n\n      There should be provided a system call that enables a user process\nto learn of the maximum current capacity of any given channel. This\nshould be reported as a pair of numbers, namely the maximum bit count\nand the maximum message count.\n\nABILITY TO CONSTRAIN CHANNEL CAPACITY\n\n      A process using a channel should be able to set new bounds on the\ncapacity of a given channel. If possible the system should try to meet\nthis bound. It should be noted that the actual bounds imposed must meet\nthe constraints of at least four different sources -- local and remote\nuser process, local and remote system -- by setting a arbitrarily high\nbound, no guarantee is made that it can be met. Similarly, a low bound\ncan not always be met until buffered messages are consumed.\n\n      Thus a receiving process, by setting the current message bound to\nzero, effectively disables the transmission of new messages. Thus,\nwithout the cooperation of the transmitting process, message generation\ncan be temporarily disabled, while outstanding message buffers are\nflushed. Later the message allocation can be raised to its original\nlimit and transmission can be resumed.\n\nABILITY TO CLOSE A CHANNEL AT ANY TIME\n\n      A process should be able to close down a channel at any time. If\nthe process has died, the system should be able to close all open\nchannels for it. For channels over which the process was receiving data,\npending input should be thrown away and indications returned to the\ntransmitting system marking the channel as dead and identifying the last\ndata item accepted. This identification will be in terms of the number\nof logical messages discarded and the number of bits left in the oldest\nmessage.\n\n      If a process closes a channel over which it had been sending,\nbuffered output should be sent normally, and with it should be sent an\nindication that this is all of the input that will ever appear.\n\n\n\n\n\n\n\n\n                                                                [Page 9]\n\f\nRFC #150                 Use of IPC Facilities                5 May 1971\n\nABILITY TO GIVE AWAY CHANNEL PRIVILEGES\n\n      The right to perform any of the operations discussed here is\nnormally reserved by the process that established the channel. At times\nthat process may wish to transfer some of its delegated power to another\nprocess, especially in an environment where one process may spawn\nanother and resources must be passed to the newly created process.\n\n      Schemes for such reassignment can become arbitrarily complicated.\nOne could, for example, assign each of the various aspects of usage\nindividually and then separately assign the various rights of\nreassignment. Fortunately it is not always necessary that it become so\nelaborate, it is expected that in most cases the following simple\nstrategy can suffice. The ability to close a channel is retained\nexclusively by the process that established the channel. If the channel\nis still open when the process dies, it is automatically closed by the\nsystem. All other uses of the channel remain outside system control. The\nchannel is known by name and all processes to which the name has been\ngiven may make use of the channel. It is left to user level coordination\nto insure that only one process is actually making use of it at any one\ntime.\n\nABILITY TO INITIATE CHANNEL CREATION\n\n      For most cases channel establishment can be handled quite simply.\nA process announces to its local system that it listening on a \nspecified channel. It is connected to the first remote process that\n'dials' the right number. Identification of the caller takes place\nonly after the channel has been established. In the event of a wrong\nnumber, the channel can be closed and the listening resumed. Callers\ntrying to reach preestablished channels will get a 'busy signal'.\n\n      To 'dial' a remote process a process must specify a channel on\nwhich it is listening and a remote number. The system will then\nattempt to establish the connection. The channel will become 'busy'\nduring this time.\n\n      For processes that prefer to avoid the complications of\nidentifying remote callers, an additional feature can be added. By\nspecifying both the local and remote channel identifiers a process can\ntransfer to the system the responsibility for screening callers for\nthe proper identification. The connection will only be accepted from\nthe caller specified.\n\n\n                                                                [Page 10]\n\f\nRFC #150                 Use of IPC Facilities                5 May 1971\n\n\nABILITY TO REPORT TRANSMISSION ERRORS\n\n      If after prescanning an input message a process should decide\nthat it contains some sort of transmission error, it should be able to\nreject the message. The system should then invoke any internal error\nrecovery mechanism that it may have implemented.\n\nPOSTSCRIPT\n\n      The author welcomes any comments, questions, or corrections to\nthis document. Even the most informal note or telephone call will be\nappreciated. Especially of interest are opinions about the usefulness\nof the discussion and wether or not there should be more papers\ndirected at other of the basic questions of computer networking. If\nthe consensus tends to the affirmative, then others are encouraged to\ncontribute working papers on the problems of flow control, error\nhandling, process ownership, accounting, resource control, and the\nlike.\n\n\nRBK/TX2\n\n\n         [ This RFC was put into machine readable form for entry ]\n         [ into the online RFC archives by Michael Baudisch 9/97 ] \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                                [Page 11]\n\f\n\n"
}