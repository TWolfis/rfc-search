{
  "series": "Request for Comments",
  "number": "70",
  "howpublished": "RFC 70",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0070",
  "url": "https://www.rfc-editor.org/info/rfc70",
  "title": "Note on Padding",
  "pagetotal": "9",
  "year": "1970",
  "month": "oct",
  "body": "\n\n\n\n\n\nNetwork Working Group                                      S. Crocker\nRequest for Comments #70                                   UCLA\n                                                           15 October 70\n\n                           A Note on Padding\n\nThe padding on a message is a string of the form 10*.  For Hosts with\nword lengths 16, 32, 48, etc., bits long, this string is necessarily in\nthe last word received from the Imp.  For Hosts with word lengths which\nare not a multiple of 16 (but which are at least 16 bits long), the 1\nbit will be in either the last word or the next to last word.  Of\ncourse if the 1 bit is in the next to last word, the last word is all\nzero.\n\nAn unpleasant coding task is discovering the bit position of the 1 bit\nwithin its word.  One obvious technique is to repeatedly test the\nlow-order bit, shifting the word right one bit position if the\nlow-order bit is zero.  The following techniques are more pleasant.\n\nIsolating the Low-Order Bit\n\nLet W be a non-zero word, where the word length is n.  Then W is of the\nform\n\n            x....x10....0\n            \\__ __/\\__ __/\n               V      V\n             n-k-1    k\n\nwhere 0\u003c=k\u003cn\n\nand the x's are arbitrary bits.\n\nAssuming two's complement arithmetic,\n\n            W-1    =       x....x01....1\n                           _    _\n             -W    =       x....x10....0\n              _            _    _\n              W    =       x....x01....1\n\nBy using AND, OR and exclusive OR with various pairs of these\nquantities, useful new forms are obtained.\n\nFor example,\n\n\n\n\n\n\n                                                                [Page 1]\n\f\nNetwork Working Group      A Note on Padding                      RFC 70\n\n\n            W AND W-1       xx...x00....0\n                           \\__ __/\\__ __/\n                              V      V\n                            n-k-1    k\n\nthus removing the low-order 1 bit;\n\nalso W AND -W =           0....010....0\n                         __ __/__ __/\n                            V      V\n                          n-k-1    k\n\nthus isolating the low-order bit.\n\nBelow, we will focus solely on this last result; however, in a\nparticular application it may be advantageous to use a variation.\n\nDetermining the Position of an Isolated Bit\n\nThe two obvious techniques for finding the bit position of an isolated\nbit are to shift repetitively with tests, as above, and to use floating\nnormalization hardware.  On the PDP-10, in particular, the JFFO\ninstruction is made to order*.  On machines with hexadecimal\nnormalization, e.g. IBM 360's and XDS Sigma 7's, the normalization\nhardware may not be very convenient.  A different approach uses\ndivision and table look-up.\n                                                              k\nA word with a single bit on has an unsigned integer value of 2  for\n                                         k\n0\u003c=k\u003cn.  If we choose a p such that mod(2 ,p) is distinct for each\n\n0\u003c=k\u003cn, we can make a table of length p which gives the correspondence\n             k\nbetween mod(2 ,p) and k.  The remainder of this paper is concerned with\n\nthe selection of an appropriate divisor p for each word length n.\n\n\n\n\n*Some of the CDC machines have a \"population count\" instruction which\n                                               k\ngives the number of bits in a word.  Note the 2 -1 has exactly k bits\n\non.\n\n\n\n\n\n\n                                                                [Page 2]\n\f\nNetwork Working Group      A Note on Padding                      RFC 70\n\n\nExample\n\n   Let n = 8 and p = 11\n\n      Then\n\n                 0\n            mod(2, 11)     =    1\n                 1\n            mod(2, 11)     =    2\n                 2\n            mod(2, 11)     =    4\n                 3\n            mod(2, 11)     =    8\n                 4\n            mod(2, 11)     =    5\n                 5\n            mod(2, 11)     =   10\n                 6\n            mod(2, 11)     =    9\n                 7\n            mod(2, 11)     =    7\n\n      This yields a table of the form\n\n         remainder             bit position\n\n             0                       --\n\n             1                        0\n\n             2                        1\n\n             3                       --\n\n             4                        2\n\n             5                        4\n\n             6                       --\n\n             7                        7\n\n             8                        3\n\n             9                        6\n\n            10                        5\n\n\n\n                                                                [Page 3]\n\f\nNetwork Working Group      A Note on Padding                      RFC 70\n\n\nGood Divisors\n\nThe divisor p should be as small as possible in order to minimize the\n\nlength of the table.  Since the divisor must generate n distinct\n\nremainders, the divisor will certainly need to be at least n.  A\n\nremainder of zero, however, can occur only if the divisor is a power of\n                                               j\n2.  If the divisor is a small power of 2, say 2  for j \u003c n-1, it will\n\nnot generate n distinct remainders; if the divisor is a larger power of\n                                       n-1     n\n2, the correspondence table is either 2    or 2  in length.  We can\n\nthus rule out zero as a remainder value, so the divisor must be at\n\nleast one more than the word length.  This bound is in fact achieved\n\nfor some word lengths.\n\nLet R(p) be the number of distinct remainders p generates when divided\ninto successively higher powers of 2.  The distinct remainders all occur\nfor the R(p) lowest powers of 2.  Only odd p are interesting and the\nfollowing table gives R(p) for odd p between 1 and 21.\n\n      p     R(p)                                p     R(p)\n\n      1      1                                 13     12\n\n      3      2                                 15      4\n\n      5      4                                 17      8\n\n      7      3                                 19     18\n\n      9      6                                 21      6\n\n      11     10\n\nThis table shows that 7, 15, 17 and 21 are useless divisors because\nthere are smaller divisors which generate a larger number of distinct\nremainders.  If we limit our attention to p such that p \u003e p' =\u003e\nR(p) \u003e R(p'), we obtain the following table of useful divisors for\np \u003c 100.\n\n\n\n\n\n                                                                [Page 4]\n\f\nNetwork Working Group      A Note on Padding                      RFC 70\n\n\n      p     R(p)                                p     R(p)\n\n      1      1                                 29     28\n\n      3      2                                 37     36\n\n      5      4                                 53     52\n\n      9      6                                 59     58\n\n      11     10                                61     60\n\n      13     12                                67     66\n\n      19     18                                83     82\n\n      25     20\n\nNotice that 9 and 25 are useful divisors even though they generate only\n6 and 20 remainders, respectively.\n\nDetermination of R(p)\n\nIf p is odd, the remainders\n\n           0\n      mod(2 ,p)\n           1\n      mod(2 ,p)\n\n           .\n           .\n           .\n                                                               t\nwill be between 1 and p-1 inclusive.  At some power of 2, say 2 , there\n                                                       k    t\nwill be a repeated remainder, so that for some k \u003c t, 2  = 2  mod p.\n       t+1    k+1\nSince 2    = 2    mod p\n       t+2    k+2\nand   2    = 2    mod p\n\n           .\n           .\n           .\n          etc.\n                                          0    t-1\nall of the distinct remainders occur for 2 ...2   .  Therefore, R(p)=t.\n\n\n\n                                                                [Page 5]\n\f\nNetwork Working Group      A Note on Padding                      RFC 70\n\n\nNext we show that\n\n      R(p)\n     2     = 1 mod p\n                      R(p)    k\nWe already know that 2     = 2  mod p\n\nfor some 0\u003c=k\u003cR(p).  Let j=R(p)-k so 0\u003cj\u003c=R(p).  Then\n\n      k+j           k\n     2           = 2  mod p\n      j  k          k\nor   2 *2        = 2  mod p\n       j     k\nor   (2 -1)*2    =  0 mod p\n                       k                                     j\nNow p does not divide 2  because p is odd, so p must divide 2 -1.  Thus\n\n       j\n      2 -1        =  0 mod p\n       j\n      2           =  1 mod p\n\nSince j is greater than 0 by hypothesis and since ther is no k other\nthan 0 less than R(p) such that\n\n       k    0\n      2  = 2  mod p,\n\n                         R(p)\nwe must have j=R(p), or 2     = 1 mod p.\n                                                       k\nWe have thus shown that for odd p, the remainders mod(2 ,p) are unique\nfor k = 0, 1,..., R(p)-1 and then repeat exactly, beginning with\n\n       R(p)\n      2     = 1 mod p.\n\nWe now consider even p.  Let\n\n              q\n      p = p'*2 ,\n                                k                     k          k\nwhere p' is odd.  For k\u003cq, mod(2 ,p) is clearly just 2  because 2 \u003cp.\n\nFor k\u003e=q,\n          k       q      k-q\n     mod(2 ,p) = 2 *mod(2   ,p').\n\n\n\n                                                                [Page 6]\n\f\nNetwork Working Group      A Note on Padding                      RFC 70\n\n\nFrom this we can see that the sequence of remainders will have an\n                             q-1\ninitial segment of 1, 2, ...2    of length q, and repeating segments of\n\nlength R(p').  Therefore, R(p) = q+R(p').  Since we normally expect\n\n     R(p) ~ p,\n\neven p generally will not be useful.\n\nI don't know of a direct way of choosing a p for a given n, but the\nprevious table was generated from the following Fortran program run\nunder the SEX system at UCLA.\n\n\n\n            0\n                    CALL IASSGN('OC ',56)\n            1       FORMAT(I3,I5)\n                    M=0\n                    DO 100 K=1,100,2\n                    K=1\n                    L=0\n            20      L=L+1\n                    N=MOD(2*N,K)\n                    IF(N.GT.1) GO TO 20\n                    IF(L.LE.M) GO TO 100\n                    M=L\n                    WRITE(56,1)K,L\n            100     CONTINUE\n                    STOP\n                    END\n\n      Fortran program to computer useful divisors\n\nIn the program, K takes on trial values of p, N takes on the values of\nthe successive remainders, L counts up to R(p), and M remembers the\nprevious largest R(p).  Execution is quite speedy.\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                                [Page 7]\n\f\nNetwork Working Group      A Note on Padding                      RFC 70\n\n\nResults from Number Theory\n\nThe quantity referred to above as R(p) is usually written Ord 2 and is\n                                                             p\nread \"the order of 2 mod p\".  The maximum value of Ord 2 is given by\n                                                      p\nEuler's phi-function, sometimes called the totient.  The totient of a\n\npositive integer p is the number of integers less than p which are\n\nrelatively prime to p.  The totient is easy to compute from a\n\nrepresentation of p as a product of primes:\n\n               n      n        n\n     Let p = p  1 * p  2 ... p  k\n              1      2        k\n\nwhere the p  are distinct primes.  Then\n           i\n                          k -1               k -1                 k -1\n     phi(p) = (p - 1) * p  1   * (p - 1) * p  2   ... (p - 1) * p  k\n                1        1         2        2           k        k\n\nIf p is prime, the totient of p is simply\n\n     phi(p) = p-1.\n\nIf p is not prime, the totient is smaller.\n\nIf a is relatively prime to p, then Euler's generalization of Fermat's\ntheorem states\n\n      phi(m)\n     a       = 1 mod p.\n\nIt is this theorem which places an upper bound Ord 2, because Ord 2 is\n                                                  p              p\nthe smallest value such that\n\n      Ord 2\n     2   p  = 1 mod p\n\nMoreover it is always true that phi(p) is divisible by Ord 2.\n                                                          p\n\n\n\n\n\n\n                                                                [Page 8]\n\f\nNetwork Working Group      A Note on Padding                      RFC 70\n\n\nAcknowledgements\n\nBob Kahn read an early draft and made many comments which improved the\nexposition.  Alex Hurwitz assured me that a search technique is\nnecessary to compute R(p), and supplied the names for the quantities\nand theorems I uncovered.\n\n\n       [ This RFC was put into machine readable form for entry ]\n       [ into the online RFC archives by Guillaume Lahaye and  ] \n                          [ John Hewes 6/97 ]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                                [Page 9]\n\f\n"
}