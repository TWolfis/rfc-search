{
  "series": "Request for Comments",
  "number": "387",
  "howpublished": "RFC 387",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0387",
  "url": "https://www.rfc-editor.org/info/rfc387",
  "title": "Some experiences in implementing Network Graphics Protocol Level 0",
  "pagetotal": "5",
  "year": "1972",
  "month": "aug",
  "body": "\n\n\n\n\n\nNetwork Working Group                                  Karl C. Kelley\nRequest for Comments:  387                                Jaacov Meir\nNIC:  11359                                                   8/10/72\nCategories:  D.6, F\nObsoletes:\nReferences:  RFC #292\n\n\n   SOME EXPERIENCES IN IMPLEMENTING NETWORK GRAPHICS PROTOCOL LEVEL 0\n\n\n    We are in the process of implementing NGP-0 at several hosts.  For\nthe time being, we are forced to consider the remote host as the \"last\nintelligent machine\". We are attempting to translate NGP-0 to a machine\ndependent code for the Computek display. The remote hosts are CCN, UCSD,\nand soon RANDCSG. More comments about that work will be made in\nsubsequent RFC's. The concern of this RFC is twofold:\n\n    1.  Clarify the coordinate number system.\n\n    2.  Puzzle over how to do TEXTR string without either:\n\n        a.  Reading current position and saving it while the text string\n            is being output, or\n\n        b.  Monitoring the beam position for each NGP command and saving\n            this information somewhere.\n\n    An appendix to this RFC will outline the conversion from the NGP\ncoordinate system to the floating point arithmetic on the PDP-1O.\n\nThe Coordinate Data\n\n    The document for NGP-0 (RFC 292) does not say specifically that the\nformat of coordinate data is the same whether the command is in absolute\nor relative mode. The only thing stated is that they are in two's\ncomplement notation with the leftmost bit being the sign bit.  It is\npossible to use two different 2's complement schemes:\n\n\n\n\n\n\n\n\n\n\n\n\n\nKelley \u0026 Meir                                                   [Page 1]\n\f\nRFC 387      Experience Implementing Net Graphics Protocol   August 1972\n\n\n           System A                            System B\n    (Absolute Coordinates)              (Relative Coordinates)\n\n  -1 -2 -3                 -16         0 -1 -2                 -15\n -2  2  2  ...          ...2         -2  2  2  ...             2\n +--+--+--+--+---------+--+--+       +--+--+--+--+---------+--+--+\n |  |  |  |  |         |  |  |       |  |  |  |  |         |  |  |\n +--+--+--+--+---------+--+--+       +--+--+--+--+---------+--+--+\n ^                                      ^\n\n\n .0111 ...............11 = +1/2-e    0.11 ..............11 = 1-e\n\n .00 .................01 = +e        0.100 .............00 = 1/2\n\n .00 .................0 = 0          0.00...............01 = e\n\n .111 ................11 = -e        0.00 ..............00 = 0\n\n .100 ................   = 1/2       1.11 ..............11 = -e\n\n                                     1.10 ..............00 = -1/2\n\n                                     1.00 ..............01 = -1+e = -(1-e)\n\n                                     1.00 ..............00 = -1\n\n\n               -16                               -15\n Where:    e = 2                     Where:  e = 2\n\n                          -16                           -15\n Range:    -1/2 to +1/2 - 2          Range:  -1 to +1 - 2\n\n    I submit that one could interpret the requirement for absolute\ncoordinate data to be in the range -1/2 to +1/2 - e as requiring that\ntwo different number systems should be used.  Thinking along those\nlines, System A has the advantage that you never get handed a number out\nof range, which saves some checking worries.  It also has one whole bit\nmore of precision.\n\n    I further submit that having two systems to contend with merely\nclouds the issue and requires extra coding.  It makes more sense just to\nstick with System B above.  Among the advantages in its use are:\n\n    1.  The single system can handle both absolute and relative\n        coordinates.\n\n\n\n\nKelley \u0026 Meir                                                   [Page 2]\n\f\nRFC 387      Experience Implementing Net Graphics Protocol   August 1972\n\n\n    2.  If an absolute coordinate exceeds range, simply forcing the sign\n        bit on causes a nice wrap-around.\n\n    3.  The representation is the same as the mantissa for floating\n        point numbers on most machines.  Notice, however, that mantissas\n        of normalized floating point numbers are not in the range for\n        absolute coordinates.  The program will have to shift the\n        mantissa until exponent is 0.\n\n    It may be that few of us interpreted the NGP document to mean two\nnumber systems were needed.  If that is the case, so much the better.\nIn any case, until shaken from the position by the overwhelming force of\ncontrary logic, we will, in all of our implementations, use System B\nabove for both absolute and relative coordinates.\n\nThe TEXTR Command\n-----------------\n\n    The last paragraph on page 4 of RFC 292 says, \"...a command be\nincluded only if its output is a function solely of the current command\nand the \"beam position\" current at the start of the command.  In other\nwords, the interpreter for level 0 need have no internal storage for\n'modes' or pushdown stacks.\"\n\n    In the case of the Computek display, most of the NGP commands\ncorrespond to capabilities of the device. The lone exception is the\nTEXTR command. There are two ways to know what beam position to return\nto after the string is displayed. One way is to read the cursor position\nfrom the display just before doing the string output. This is no good\nbecause it requires reading from the device (which we can't do until\ninput protocols are implemented). Also, on this device, the cursor\nposition is accurate only to within 4 scope points.\n\n    The second way to know what beam position to return to is to monitor\nall motions of the beam in software. Thus our implementations of NGP-0\nto Computek translations will employ a software X register and Y\nregister. On absolute commands, the registers will be set to the\ncoordinates for that command.  On relative commands, the coordinate data\nwill be added to the registers.  At the beginning and end of picture,\nthese registers will be set to 0.\n\n    The TEXTR command will also cause these software beam registers to\nbe changed.  That is, the X register will be incremented for each\ncharacter of the string to correspond to what is happening in the\ndisplay itself.\n\n\n\n\n\n\nKelley \u0026 Meir                                                   [Page 3]\n\f\nRFC 387      Experience Implementing Net Graphics Protocol   August 1972\n\n\n                                APPENDIX\n\n                     NGP-0 to PDP-10 Floating Point\n                     ------------------------------\n\n       The NGP-0 looks at all data numbers (X and Y parameters) as a\nfraction number in the following format (16 bits per number).\n\n\n             +--+--+--+--+--+--+-----------------+--+--+--+--+\n             |  |  |  |  |  |  | ...         ... |  |  |  |  |\n             +--.--+--+--+--+--+-----------------+--+--+--+--+\nBit position   0  1  2  3 ......                        14 15\n\n\n\nwith the binary point assumed between bits 0 and 1.  Bit 0 is the sign\nbit and all negative numbers are represented as their two's complement.\nThe PDP-10 machine code representation of fractions in floating point\n(mantissa part) is very similar to the above (with one exception--the\nnumber -1), so the transformation could be obtained simply by two\noperations, move and substitute.\n\n\n                         Data (X,Y) Conversion\n                         ---------------------\n\n   NGP (extreme points)                    Floating Point (PDP-10)\n\n        (16 bits)                                 (36 bits)\n                                           exp   mantissa\n\n1/2   0.1000 . . . . . .0              0 10000000  10 . . . . . .0\n\n-1/2  1.1000 . . . . . .0              1 01111111  10 . . . . . .0\n\n-1    1.00   . . . . . .0              1 01111101  10 . . . . . .0\n                                                        Special case\n\n1-e   0.11   . . . . . .1              0 10000000  1111 . . . . .1\n\n\n\n\n\n\n\n\n\n\n\nKelley \u0026 Meir                                                   [Page 4]\n\f\nRFC 387      Experience Implementing Net Graphics Protocol   August 1972\n\n\n    Translation from NGP into floating point for PDP-1O:\n\n    1.  Move sign bit (leftmost one) to sign bit.\n\n    2.  Move fraction part (15 bits) to mantissa part (left justified;\n        fill with zero's to right).\n\n    3.  Fill in exponent part (8 bits) according to:\n\n        a.  If positive number      exp = 10000000 = (80) hex\n\n        b.  If negative number      exp = 01111111 = (7F) hex\n\n        c.  Exception _in_only_ one number\n\n            -1 in NGP (negative sign and fraction all zero's)\n\n            (1)  mantissa becomes same as -1/2\n\n            (2)  exponent becomes the one's complement of (82) hex\n                 = (7D) hex\n\n    The methods of conversion will remain the same regardless of the\n    number of bits (up to 24) that are used for the NGP fraction.\n\n\n\n         [ This RFC was put into machine readable form for entry ]\n         [ into the online RFC archives by Alex McKenzie with    ]\n         [ support from GTE, formerly BBN Corp.             9/99 ]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nKelley \u0026 Meir                                                   [Page 5]\n\f\n"
}