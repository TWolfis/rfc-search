{
  "series": "Request for Comments",
  "number": "11",
  "howpublished": "RFC 11",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0011",
  "url": "https://www.rfc-editor.org/info/rfc11",
  "title": "Implementation of the Host - Host Software Procedures in GORDO",
  "pagetotal": "23",
  "year": "1969",
  "month": "aug",
  "body": "\n\n\n\n\n\nNetwork Working Group                                         G. Deloche\nRequest for Comments: 11                                            UCLA\n                                                             August 1969\n\n\n                   Implementation of the Host - Host\n                      Software Procedures in GORDO\n\nTABLE OF CONTENTS\n\n   Chapter                                                        Page\n   -------                                                        ----\n   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . .   1\n   2.  HOST - HOST Procedures . . . . . . . . . . . . . . . . . .   2\n       2.1  Generalities  . . . . . . . . . . . . . . . . . . . .   2\n       2.2  Connections and Links . . . . . . . . . . . . . . . .   2\n            2.2.1  Definitions  . . . . . . . . . . . . . . . . .   2\n            2.2.2  Connection types . . . . . . . . . . . . . . .   3\n       2.3  Message Structure . . . . . . . . . . . . . . . . . .   5\n       2.4  User Transactions . . . . . . . . . . . . . . . . . .   6\n            2.4.1  List of transactions   . . . . . . . . . . . .   7\n            2.4.2  HOST-HOST protocol and control messages  . . .   8\n   3.  Implementation in GORDO  . . . . . . . . . . . . . . . . .  11\n       3.1  Introduction to GORDO . . . . . . . . . . . . . . . .  11\n            3.1.1  GORDO file system  . . . . . . . . . . . . . .  11\n            3.1.2  GORDO process  . . . . . . . . . . . . . . . .  12\n       3.2  Software Organization Overview  . . . . . . . . . . .  12\n       3.3  Software Description  . . . . . . . . . . . . . . . .  13\n            3.3.1  Data structures  . . . . . . . . . . . . . . .  13\n                   3.3.1.1  Allocation tables . . . . . . . . . .  13\n                   3.3.1.2  Buffer pages  . . . . . . . . . . . .  16\n            3.3.2  Programs . . . . . . . . . . . . . . . . . . .  18\n                   3.3.2.1  Handler . . . . . . . . . . . . . . .  18\n                   3.3.2.2  Network . . . . . . . . . . . . . . .  19\n       3.4  Software Procedures . . . . . . . . . . . . . . . . .  20\n            3.4.1  Description of some typical sequences  . . . .  20\n\n   Appendix A:  Flowcharts  . . . . . . . . . . . . . . . . . . .  23\n\n   [[RFC Editor Note: [s] represents subscript s]]\n\n1.  INTRODUCTION\n\n   This technical note concentrates upon (1) the HOST-HOST procedures\n   and (2) the implementation of the corresponding programs in GORDO\n   (Operating System of the UCLA HOST).\n\n\n\n\n\nDeloche                                                         [Page 1]\n\f\nRFC 11          Host - Host Software Procedures in GORDO     August 1969\n\n\n   The first section is closely related to the BBN reports No. 1822 and\n   1763[1] and specifies the HOST functions for exchanging messages.  It\n   mostly deals with links and connections, message structure,\n   transactions, and control messages.\n\n   The second section is software oriented; it explains how the HOST\n   functions are implemented and integrated into GORDO.  It is involved\n   with data structures, programs, buffers, interrupt processing, etc.\n\n   [1]  Parts of this section are taken from or referred to those\n   reports.\n\n2.  HOST-HOST PROCEDURES\n\n2.1  Generalities\n\n   The basic idea is that several users, at a given HOST, should\n   simultaneously be able to utilize the network by time-sharing its\n   physical facilities.\n\n   This implies that within each HOST operating system, there must exist\n   a special program that multiplexes outgoing messages from the users\n   into the network and distributes incoming messages to the appropriate\n   users.  We will call this special program the Network program.\n\n2.2  Links and Connections  (See figure 1)\n\n   2.2.1  Definitions\n\n   It is convenient to consider the Network as a black box - a system\n   whose behavior is known but whose mechanisms are not - for\n   communicating messages between remote users rather than between pairs\n   of HOST computers.\n\n      (a)  Logical connections\n\n         We define a logical connection as being a communication path\n         linking two users at remote HOST[s].\n\n         With that concept, a user (user program) in a HOST computer can\n         (1) establish several logical connections to any remote HOST\n         users, and (2) send or receive messages over those connections.\n\n         Connections appear to users as full duplex.\n\n         One of the purposes of the Network program is to serve the\n         users in establishing, identifying, and maintaining these\n         connections.\n\n\n\nDeloche                                                         [Page 2]\n\f\nRFC 11          Host - Host Software Procedures in GORDO     August 1969\n\n\n      (b)  Logical links\n\n         Each logical connection is made of a pair of directional links:\n         one for transmitting, the other for receiving.\n\n         Those links, called logical links, are established by the\n         Network programs and used by them.\n\n         Note here that users are only interested in connections and are\n         completely unaware of links.  Relationships between links and\n         connections are carried out by the Network program.\n\n         One of the advantages to define a connection as a pair of\n         directional links is that a HOST will have the capability to\n         loop himself through its IMP (it opens a connection to\n         himself).  This feature can be useful for debugging purposes.\n\n         Further on through this paper we will not use any more the\n         attribute logical when referring either to links or\n         connections.\n\n   2.2.2  Connection types\n\n   In order to reach a high flexibility in utilizing the Network there\n   is advantage to classify the connections.\n\n   Three types of connections are distinguished:  (a) control\n   connection, (b) primary connection, and (c) auxiliary connection.\n\n      (a)  Control connection\n\n      This connection has a special status and is unique between a pair\n      of HOST[s], e.g., if the Network includes x HOST[s], there are at\n      most x control connections issued from one HOST.\n\n      This connection is used by remote Network programs for passing\n      control messages back and forth.  Control messages are basic to\n      the establishment/deletion of standard connections.  (See 2.4.2)\n\n      Note here that this control connection is the only connection\n      which is not used by the HOST users.\n\n      Let us describe now the standard connections.\n\n\n\n\n\n\n\n\nDeloche                                                         [Page 3]\n\f\nRFC 11          Host - Host Software Procedures in GORDO     August 1969\n\n\n      (b)  Primary connection\n\n      These connections connect remote users.\n\n      A primary connection:\n\n            * Is unique between a pair of users and is the first to be\n               established.\n\n            * Is \"teletype-like\", i.e.:\n               - ASCII characters are transmitted;\n               - Echoes are generated by the remote HOST;\n               - The receiving HOST[s] scan for break characters;\n               - The transmission rate is slow (less than 20\n               characters/sec).\n\n            * Is mainly used for transmitting control commands, e.g.,\n               for log-in into a remote HOST operating system.\n\n      (c) Auxiliary connection\n\n         These connections also connect remote users:\n\n         An auxiliary connection:\n\n            * Is opened in parallel to a primary connection and is not\n               unique, i.e., several auxiliary connections can be\n               established between users.\n\n            * Is used for transmitting large volumes of data (file\n               oriented).\n\n            * Is used either for binary or character transmission.\n\n             [Figure 1 - Links and Connections - see PDF file]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDeloche                                                         [Page 4]\n\f\nRFC 11          Host - Host Software Procedures in GORDO     August 1969\n\n\n2.3  Message Structure\n\n   The HOST[s] communicate with each other via messages.  A message may\n   vary in length up to 8095 bits (See down below the structure).\n   Larger transmission must therefore be broken up by HOST users into a\n   sequence of such messages.\n\n      A message structure is identified on figure 2.\n\n      It includes the following:\n\n      (1) A leader (32 bits): Message type, Source/Destination HOST,\n          link number.  (See BBN report No. 1822, pp 13, 17)\n\n      (2) A marketing (32 bits when sent by the Sigma 7) for starting a\n          message text on a word boundary.  (See BBN report No. 1822,\n          pp. 17, 19)\n\n      (3) The message text (Max: 8015 bits for the Sigma 7).  It mostly\n          consists of user's text.  However, it may represent\n          information for use by the Network programs.  (Control\n          messages, see 2.4.2)\n\n      (4) A checksum (16 bits).  Its purpose is to check, at the HOST\n          level, the right transmission of a message.  (Changes in bit\n          pattern or packet transposition; packets are defined in BBN\n          report No. 1763, p. 13)  See down below for checksum\n          calculation.\n\n      (5) A padding for solving word length mismatch problems.  (See BBN\n          report No. 1822, p. 17, 19.).  As far as software is\n          concerned, padding is only involved at message reception for\n          delineating message ends.  (At transmission the hardware takes\n          care of the padding.)\n\n   Remark:\n\n      Checksum calculation:\n\n      The last 16 bits of every message sent by a HOST is a checksum.\n      This checksum is computed on the whole message including any\n      marking, but excluding the 32 bit leader and any padding.  To\n      compute the checksum:\n\n      1.  Consider the message to be padded with zeroes to a length of\n          8640 bits.\n\n      2.  Section the 8640 bits into six 1440-bit segments, S0, S1...S5.\n\n\n\nDeloche                                                         [Page 5]\n\f\nRFC 11          Host - Host Software Procedures in GORDO     August 1969\n\n\n      3.  Section each 1440-bit segment S into 90 16-bit elements, T0,\n          T1...T89.\n\n      4.  Define a function [(+)], which takes two 16-bit elements as\n          inputs and outputs a 16-bit element.  This function is defined\n          by\n\n          Tm [(+)] Tn = Tm [(+)] Tn, if Tm + Tn \u003c 2[exp 16]\n\n          Tm [(+)] Tn = Tm [(+)] Tn - 2[exp 16] + 1, if Tm + Tn \u003e= 2[exp\n          16]\n\n      5.  For each 1440-bit segment Si compute Ci = K(Si), where\n\n          K(S) = T0 [(+)] T1 + ..... T89\n\n      6.  Computer C =\n          C0[(+)]C1[(+)]C1[(+)]C2[(+)]C2[(+)]C2[(+)]C2....[(+)]C5\n\n          (Notice that C1[(+)]C1 is just C1 rotated left one bit)\n\n   The number C is the checksum.  The reason the Ci are rotated by i\n   bits is to detect packet transposition.\n\n    [Figure 2 - Format of a message sent by the Sigma 7 - see PDF file]\n\n2.4  User Transactions\n\n   From what has been discussed until here, the Network appears to a\n   user as a bunch of connections.  Let us now explain how one can make\n   use of these connections.\n\n   First, we are going to describe the set of transactions that a user\n   should be able to access for utilizing the connection facilities.\n\n   Then, we are going to explain the role of the Network program for the\n   execution of these transactions.  This will cover a HOST-HOST\n   protocol in which control messages are exchanged between network\n   programs.\n\n   For explanation purposes those transactions are represented, at the\n   user level, in the form of subroutine calls and parameters.  However,\n   this does not imply at all that the implementation will closely\n   follow this pattern.  (We are more involved here with the description\n   than the implementation aspect, see chapter 3.)\n\n\n\n\n\n\nDeloche                                                         [Page 6]\n\f\nRFC 11          Host - Host Software Procedures in GORDO     August 1969\n\n\n   2.4.1  List of transactions\n\n   Listed below are the descriptions of subroutines that could be at\n   user's disposal for creating/breaking connections and\n   transmitting/receiving data over them.  This set of subroutines can\n   be considered as a kind of interface between the user level and the\n   network program level.\n\n   (a)  Open primary connection:\n\n        OPENPRIM (CONNECTID, HOSTID, BUFFADDR, [OPT])\n        CONNECTID:  Connection identification #\n        HOSTID:  Remote HOST identification #\n        BUFFADDR:  Buffer address for incoming messages.\n        OPT:  Options such as message required after successful\n              connection establishment, \"full echo\" (each message is\n              transmitted back by the remote HOST for checking purpose),\n              etc.\n\n        Remark: [  ] means optional\n\n   (b) Open auxiliary connection\n\n        OPENAUX (CONNECTID, BUFFADDR, N, [OPT])\n        CONNECTID:  Connection identification #, i.e., the\n                    identification of the corresponding primary\n                    connection (First a user has to open a primary\n                    connection).\n        BUFFADDR:  Same meaning as above.\n        N:  Number of auxiliary connections that should be opened.\n        OPT:  Same meaning as above.\n\n   (c)  Transmission over connection\n\n        TRANSM (CONNECTID, NO, BUFFADDR, N, [OPT])\n        CONNECTID:  Connection identification #\n        NO:  Connection #.  The primary connection is always referred to\n             as being NO=0.  An auxiliary connection number corresponds\n             to the order in which it has been established.  (The first\n             auxiliary opened is referred to by NO=1, the second by\n             NO=2, etc.)\n        BUFFADDR:  Buffer address of the message to be transmitted.\n        N:  Message size (byte number)\n        OPT:  Options such as data type (characters vs. binary), trace\n              bit, etc.\n\n\n\n\n\n\nDeloche                                                         [Page 7]\n\f\nRFC 11          Host - Host Software Procedures in GORDO     August 1969\n\n\n   (d)  Close connection\n\n        CLOSE (CONNECTID, [N], [NO])\n        CONNECTID: Connection identification #.\n        N:  Number of connections to be closed.  If omitted all\n            connections in use by the user, included the primary link,\n            are closed.\n        NO:  In case of N different from zero this number indicates the\n             auxiliary connection # to be closed.\n\n   2.4.2  HOST-HOST protocol and control messages\n\n   The HOST-HOST protocol is carried out by the Network programs.  It\n   mainly involves the execution of the previous transactions (initiated\n   by users) and covers a HOST-HOST dialogue.\n\n   This dialogue fulfills control procedures for opening or breaking\n   connections and consists in exchanging control messages over the\n   control link.  A control message has a structure identical to that of\n   a regular message; it only differs from it by the text which is for\n   use by Network programs instead of users.\n\n   Let us insist that this control procedure is completely unrelated to\n   transmission control procedures implemented in the IMP computers.  We\n   are here at the HOST level (Network programs), and therefore control\n   messages, that are going to be described below, are transmitted over\n   the IMP[s] like regular messages.\n\n   Consider now the previous transactions and describe for each of them\n   which messages are exchanged over which links.  Each case will be\n   explained by means of trivial examples.\n\n   We suppose that a HOST(x) user wants to a remote HOST(y) program\n   called URSA.\n\n      (a)  Open a primary connection: (OPENPRIM)\n\n      The HOST (x)'s Network program, waken up (See 3.3) by a use for\n      opening a primary connection, starts a dialogue with the HOST\n      (y)'s Network program.\n\n        (i)  HOST(x) sends the following control message:\n\n             HOST(x)       Control link                      HOST(y)\n                         --------------------\u003e\n                           ENQ PRIM 0 1 2\n\n\n\n\n\nDeloche                                                         [Page 8]\n\f\nRFC 11          Host - Host Software Procedures in GORDO     August 1969\n\n\n             ENQ:     Enquiry for connection establishment (one ASCII\n                      character)\n             PRIM:    Connection type: primary (one special character)\n             0 1 2:   Outgoing link #.  It is a decimal number (3 ASCII\n                      characters), e.g., link #12.\n\n                      This link # has been determined by the HOST(x)\n                      Network program (See implementation: 3.3)\n\n        (ii) HOST(y) acknowledges by sending back the following control\n                      message:\n\n             HOST(x)        Control link                     HOST(y)\n                         \u003c------------------------\n                          ACK ENQ PRIM 0 1 2 0 1 5\n\n             ACK:     Positive acknowledgment (one ASCII character)\n             ENQ PRIM 0 1 2:  Same meaning as above.  This part of the\n                      message is returned for checking purposes.\n             0 1 5:   Incoming link #.  It follows the same pattern as\n                      the outgoing link #.  This link # has been\n                      determined by the HOST(y) Network program.\n\n                      Now the connection is established; it will use\n                      links #12 and 15 for exchanging user messages.\n                      The connection is said to be in a pre-log-in\n                      state, i.e., the remote HOST(y) expects its\n                      standard log-in procedures.\n\n      (b)  Transmission over primary connection: (TRANSM)\n\n         By means of TRANSM subroutines referring to the primary\n         connection, the HOST(x) user is able to sign-in into the\n         HOST(y) operating system and then to call for the URSA program\n         (HOST(y) user program).\n\n         The Network programs at both ends will use the link #12 and #15\n         for passing along messages.  These messages are standard\n         messages whose contents serve for log in sequence.\n\n         A trivial example could be:\n\n             HOST(x)     Prim. Link #12                       HOST(y)\n                         ----------------------------\u003e\n                         ! S I G N - I N : X X\n\n\n\n\n\n\nDeloche                                                         [Page 9]\n\f\nRFC 11          Host - Host Software Procedures in GORDO     August 1969\n\n\n             HOST(x)     Prim. Link #15                       HOST(y)\n                         \u003c--------------------------\n                         ! ! R E A D Y\n\n             HOST(x)     Prim. Link #12                       HOST(y)\n                         ----------------------------\u003e\n                           ! U R S A\n\n      (c)  Open an auxiliary connection: (OPENAUXI)\n\n         In a very similar manner as (a) an auxiliary connection is\n         established between HOST(x) and HOST(y).  For so doing control\n         messages are exchanged over the control link.\n\n             HOST(x)           Control link                  HOST(y)\n                         ------------------------------\u003e\n                               ENQ AUX 0 2 5\n\n             HOST(x)           Control link                  HOST(y)\n                         \u003c--------------------------------\n                             ACK ENQ AUX 0 2 5 0 2 1\n\n         Now the auxiliary connection is established, it will use links\n         #25 and 21 for exchanging standard messages.\n\n      (d)  Transmission over auxiliary connection: (TRANSM)\n\n         By means of TRANSM subroutines referring to the auxiliary\n         connection, the users at both ends can exchange data:\n\n             HOST(x)        Aux. Link #25                    HOST(y)\n                         --------------------------------\u003e\n                               X X ..... X X\n\n             HOST(x)         Aux. Link #21                   HOST(y)\n                         \u003c--------------------------------\n                             X ......... X\n\n         etc.......\n\n      (e)  Close connections: (CLOSE)\n\n         This is carried out in a similar manner as (a).  The user calls\n         a CLOSE subroutine and then the Network programs at both ends\n         exchange control messages.\n\n\n\n\n\n\nDeloche                                                        [Page 10]\n\f\nRFC 11          Host - Host Software Procedures in GORDO     August 1969\n\n\n             HOST(x)           Control Link                  HOST(y)\n                         -----------------------------\u003e\n                               EOT 0 0 1 0 1 2\n\n             EOT:     End of transmission (one ASCII character)\n             0 0 1 :  No. of connections to be closed (3 decimal ASCII\n                       characters)\n             0 1 2 :  Outgoing link # to be closed.\n\n             Then HOST(y) acknowledges back as in (a).\n\n             HOST(x)           Control Link                  HOST(y)\n                         \u003c-----------------------------\n                            ACK EOT 0 0 1 0 1 2 0 1 5\n\n         Remark 1 - In (a), (c), and (e) HOST(y) may answer back a\n         message including a negative acknowledgement character NAK\n         instead of ACK.  This for many various reasons such as: wrong\n         sequence, connection already opened, and so forth.  The message\n         could be NAK IND, where IND is an alphanumerical character\n         indicating, in a coded form, why the previous block has been\n         refused.  Upon receiving back such acknowledgments HOST(x) will\n         repeat its message until HOST(y) accepts it.  An emergency\n         procedure will take place if too many successive \"NAK messages\"\n         occur.\n\n         Remark 2 - On each of the above illustrations (arrows) only the\n         message text is represented.  In fact, complete messages (with\n         leader, marking, padding...) are exchanged over these links.\n\n\n3.  IMPLEMENTATION IN GORDO\n\n3.1  Introduction to GORDO\n\n   GORDO is a time-sharing system implemented on SDS Sigma 7.  We\n   outline below some of the characteristics relevant to our paper.\n\n   3.1.1  GORDO file system\n\n   The file system is page oriented.  It is composed of files and\n   directories.  A file consists of a heading and a number of pages\n   which compose the body of the file.  A directory consists of a number\n   of entries that point to either files or other directories.\n\n\n\n\n\n\n\nDeloche                                                        [Page 11]\n\f\nRFC 11          Host - Host Software Procedures in GORDO     August 1969\n\n\n   3.1.2  GORDO process\n\n   *  A process is a program (procedures and data) plus its logical\n      environment.  In other words a process is a program which is known\n      and controlled by the GORDO scheduler.\n\n   *  A user (a job) may have several processes as different as\n      compiler, loader, editor, application program, etc.  A process is\n      created through a system call (FORK).\n\n   *  The space a process can refer to is the Virtual Space of 128k word\n      length.  A part (8k) of it is reserved for the operating system,\n      the other part (120k) is directly accessed by the user.  This\n      later may fill or modify its part of the virtual space upon\n      'coupling'.  (See below: service calls) pages taken from different\n      files.  Figure 3 illustrates this coupling.\n\n   *  A process can request for services by means of system calls.  The\n      system calls relevant to our paper are:\n\n         WAKE    for awaking (set active) a sleeping process\n         SLEEP   for putting asleep another process (or itself)\n         COUPLE  for coupling a page from the file space to the virtual\n                 space.\n\n   *  A process ordinarily runs in slave mode.  However if it is set up\n      as an I/O process it can access privileged instructions.\n\n   *  Processes can share data through files attached to \"mail box\"\n      directories.\n\n   Remark:  Through this note the words process and program are used\n   inter-changeably.\n\n          [Figure 3 - Virtual Space and Coupling - see PDF file]\n\n3.2  Software Organization Overview\n\n   Figure 4 illustrates the overall organization.\n\n   The system is based upon two main programs: the \"Network\" and the\n   \"Handler\".\n\n   The Handler is an I/O interrupt routine closely related to the IMP-\n   HOST hardware interface.  It serves the Network process in\n   transmitting an receiving network messages.\n\n   The Network process carries out most of the work.\n\n\n\nDeloche                                                        [Page 12]\n\f\nRFC 11          Host - Host Software Procedures in GORDO     August 1969\n\n\n   Its main function is to satisfy the users' requests for opening/\n   closing connections and transmitting/receiving network messages.  For\n   so doing,\n\n   *  it establishes, identifies, and breaks the links upon using the\n      allocation tables (HOST, CONNECT, INPUT LINK; see 3.3.1.1)\n\n   *  it is aware of the presence of new users upon exploring the\n      Network mail box directory;\n\n   *  it communicates with active users by means of shared pages through\n      which messages and requests are exchanged (connection shared\n      pages);\n\n\n   *  it formats incoming/outgoing messages in a working page.  This\n      working page has an extension (emergency ring);\n\n   *  it communicates with the Handler by means of a shared page (I/O\n      communication page) which contains the I/O communication buffers.\n\n        [Figure 4 - Software organization overview - see PDF file]\n\n3.3  Software Description\n\n3.3.1  Data Structures\n\n   3.3.1.1  Allocation tables: HOST, CONNECT, INPUT LINK\n\n      The Network program establishes, identifies, and breaks links and\n      connections upon using 3 tables:\n\n      A table sorted by remote HOST #.\n\n      A table sorted by connection #.\n\n      A table sorted by input link #.\n\n        (a) HOST table (see figure 5)\n\n            It is a bit table indicating the free outgoing links.  It\n            has the following characteristics:\n\n            *  Location: Disc resident\n\n            *  Coupling: Coupled to the Network process virtual space.\n\n            *  Size:  As many slots as remote HOST[s].\n\n\n\nDeloche                                                        [Page 13]\n\f\nRFC 11          Host - Host Software Procedures in GORDO     August 1969\n\n\n            *  Slot structure: As many bits as possible outgoing links\n                               to a remote HOST, i.e., 256.\n\n            *  Access: Indexing.  Each slot is accessed through a remote\n                       HOST #.\n\n            *  Specific feature:  Throughout the whole table no more\n                                  than 64 bits can be turned on.  This\n                                  figure corresponds to the maximum\n                                  number of outgoing links that can be\n                                  activated at one time (No matter what\n                                  is the number of remote HOST[s]).\n\n        (b)  CONNECT table\n\n            This table keeps track of all the connections' environment.\n\n            It has the following characteristics:\n\n            *  Location:  Disc resident\n\n            *  Coupling:  Couples to the Network process virtual space\n\n            *  Size:  As many slots as connections in use.\n\n            *  Slot structure:  See figure 6.  Each slot is 2 word\n                                length\n\n            *  Access:  Indexing.  Each slot is accessed through a\n                        connection #.  See 3.4 the way it is handled.\n\n            *  Specific feature 1:  The slot structure corresponding to\n                                    a primary connection is not\n                                    identical to that of an auxiliary\n                                    connection (See figure 7).  This\n                                    because user identifications and\n                                    requests are done through primary\n                                    shared pages.\n\n            *  Specific feature 2:  This table is handled in parallel\n                                    with the connection pages (See 3.3.2\n                                    (b))\n\n\n\n\n\n\n\n\n\nDeloche                                                        [Page 14]\n\f\nRFC 11          Host - Host Software Procedures in GORDO     August 1969\n\n\n            *  Specific feature 3:  This table is mainly used for\n                                    transmitting messages.  (For each\n                                    connection it contains the outgoing\n                                    link # and remote HOST #, i.e., all\n                                    the information required for\n                                    transmitting a message.)\n\n        (c)  INPUT LINK table\n\n            This table keeps track of all the incoming (input) links and\n            so is closely related to the CONNECT table.\n\n                  [Figure 5 - HOST table - see PDF file]\n\n         [Figure 6 - CONNECT table: Slot structure - see PDF file]\n\n       [Figure 7 - INSERT LINK table: Slot structure - see PDF file]\n\n   It has the following characteristics:\n\n   *  Location:  Disc resident.\n\n   *  Coupling:  Coupled to the Network process virtual space.\n\n            *  Size:  As many slots as incoming links, i.e., as\n                      connections\n\n            *  Slot structure:  See figure 7.  Each slot is 1 word\n                                length\n\n            *  Access:  Hashing.  The hashed key value is mainly based\n                        upon the incoming link # and the remote HOST #.\n\n            *  Specific feature 1:  This table is also used for\n                                    momentarily memorizing the\n                                    connection number while establishing\n                                    the next connection.  See 3.4 the\n                                    way it is handled.\n\n            *  Specific feature 2:  This table is primarily used upon\n                                    receiving messages.  (For each\n                                    incoming link it contains the\n                                    corresponding connection #, i.e.,\n                                    indirectly the user identification\n                                    to which the message should be\n                                    passed along)\n\n\n\n\n\nDeloche                                                        [Page 15]\n\f\nRFC 11          Host - Host Software Procedures in GORDO     August 1969\n\n\n      3.3.1.2  Buffer pages\n\n      All the pages that are now to be described contain two buffers\n      (input and output).  These buffers are used for either passing\n      along or processing messages.\n\n      The size of each of these buffers should at least be equal to that\n      of a message, i.e., 8095 bits.  We have chosen a buffer size of\n      253 words (8096 bits) so that both of the buffers are included\n      within one page (512 words).  The 6 remaining words of the page\n      are generally used for control.\n\n      A typical buffer page structure is identified on figure 8.\n\n      (a)  I/O communication page\n\n         See figure 9.\n\n         This I/O communication page is used as an interface between the\n         Handler and the Network program.\n\n         In the buffers of this page the messages are assembled (input)\n         or de-assembled (output) word by word by the Handler, e.g., a\n         \"ready to go\" message, sorted by the Network program in the\n         output buffer, is shipped out word by word by the Handler.\n\n         Main characteristics:\n\n         *  Location:  Resident in core: Locked page\n         *  Coupling:  Coupled to the Network process virtual space\n         *  Content: * Input buffer (253 words) for incoming messages\n                       Output buffer (253 words) for outgoing messages\n                     * Input control zone (6 half words)\n                     * Output control zone (6 half words)\n         *  Structure:  See figure 9.\n         *  Specific feature: * The input buffer is filled by the\n                                Handler (read from hardware) and emptied\n                                by the Network program\n                              * Vice versa for the output buffer\n\n      (b)  Connection shared pages (User-Network shared zone)\n\n         General features:\n\n         *  There are as many shared pages as connections.\n\n         *  These pages shared between the network and the user\n            processes constitute a communication zone for (1) passing\n\n\n\nDeloche                                                        [Page 16]\n\f\nRFC 11          Host - Host Software Procedures in GORDO     August 1969\n\n\n            the messages back and forth, and (2) exchanging control\n            information, e.g., a request for establishing new\n            connections.\n\n         Main characteristics:\n\n         *  Location:  Disc resident\n         *  Coupling:  Coupled to both a user process virtual space and\n            the\n                          network process virtual space.\n         *  Content: - Input buffer (253 words) for incoming messages\n                      - Output buffer (253 words) for outgoing messages\n                      - Input control zone (6 half words)\n                      - Output control zone (6 half words)\n         *  Structure:  See figure 10.\n         *  Specific feature 1: - The input buffer is filled by the\n                                  Network and emptied by the user.\n                                - Vice versa for the output buffer.\n         *  Specific feature 2:  The control zone corresponding to a\n                                  primary connection shared page differs\n                                  from that of an auxiliary connection.\n                                  This because it is via a \"primary\n                                  connection control zone\" that\n                                  auxiliary connection establishment\n                                  requests are transmitted to the\n                                  Network process.\n\n      (c)  Working page\n\n         General feature:\n\n         *  This page allows the Network and the Handler programs to\n         work independently on different messages and so contributes to\n         an overlapping.  For instance, when the Handler is busy\n         transmitting a message to the hardware, the Network program can\n         format (leader, marking, etc.) the reset message to be shipped\n         out, so that it can reinitiate the Handler as soon as it is\n         free.\n\n         Main characteristics:\n\n         *  Location:  Disc resident\n         *  Coupling:  Coupled to the Network process virtual space\n         *  Content:  - Input buffer (253 words) for incoming messages\n                      - Output buffer (253 words) for outgoing messages\n\n\n\n\n\n\nDeloche                                                        [Page 17]\n\f\nRFC 11          Host - Host Software Procedures in GORDO     August 1969\n\n\n         Remark:\n\n         During reception it may happen that a user program is not ready\n         to accept a new message.  In that case, to avoid clogging up\n         the system, the Network stores momentarily the incoming message\n         in one of the buffer of the emergency ring.  (If this ring is\n         full a help routine will be invoked.)\n\n         During emission all operations are synchronized with the\n         RFNM[s], therefore such procedures need not be provided.  (The\n         Network program allows a user to re-emit only when having\n         received the RFNM of the previous transmitted message.)\n\n             [Figure 8 - Typical buffer page - see PDF file]\n\n       [Figure 9 - I/O Communication page structure - see PDF file]\n\n       [Figure 10 - Connection shared page structure - see PDF file]\n\n3.3.2  Programs\n\n   3.3.2.1  Handler program\n\n      General features:\n\n      It is an I/O interrupt routine which drives the IMP/HOST hardware\n      interface in order to transmit or receive messages.  Transmission\n      and reception are carried out in a full duplex mode.\n\n      Main characteristics:\n\n      *  Location:  Core resident.  The Handler is in the same memory\n                    zone as the operating system and can be considered\n                    as part of it.\n\n      *  Initiation: By the IMP-HOST hardware interrupt.  This interrupt\n                     is triggered either:\n\n                     * during transmission when a message word is\n                       completely sent to the IMP\n\n                     * during reception when a message word has been\n                       completely received from the IMP\n\n                     * during idle time when the hardware received\n                       either a 'start input' or 'start output' order\n                       from the Sigma 7 CPU.  Those orders are issued by\n                       the Network program for provoking interrupts back\n\n\n\nDeloche                                                        [Page 18]\n\f\nRFC 11          Host - Host Software Procedures in GORDO     August 1969\n\n\n                       (consequently for indirectly initiating the\n                       Handler).\n\n      *  Main functions: * Empties the output buffer upon transmitting\n                           its content (outgoing message to the IMP.\n                           This operation is carried out word by word\n                           (32 bits) and makes use of \"Write\" orders for\n                           driving the HOST-IMP hardware.\n\n                         * Fills the input buffer with data received\n                           from HOST-IMP hardware (incoming message).\n                           This operation is also carried out word by\n                           word and makes use of \"Read\" orders for\n                           driving the HOST-IMP hardware.\n\n                         * Wakes up the Network program when any of the\n                           previous operations is complete.\n\n   3.3.2.2  Network program\n\n      General features:\n\n      This program serves the user for opening/closing connections and\n      transmitting/receiving messages.  It uses the Handler as an aid\n      for inter-facing with the hardware.\n\n      For the GORDO point of view it is a regular process and treated as\n      such.\n\n      Main characteristics:\n\n      *  Location:  Disc resident.  More precisely it is on disc when\n                    asleep and called in core when awakened by a\n                    program.\n      *  Initiation:  It is initiated through 'WAKE' service calls\n                      issued either by a user process or by the Handler.\n      *  Main functions: * Establishes/deletes outgoing connections upon\n                           users' requests.  For so doing it sends\n                           control messages (see 2.4.2) to remote\n                           HOST[s] in order to get links\n                           established/released; it then notifies back\n                           the users.\n                         * Insures the processing of incoming control\n                           messages (transmitted over control links),\n                           e.g., for contributing to\n                           establishments/deletions of connections\n                           (those requested by remote HOSTS).\n\n\n\n\nDeloche                                                        [Page 19]\n\f\nRFC 11          Host - Host Software Procedures in GORDO     August 1969\n\n\n                         * Prepares transmission of outgoing messages.\n                           It picks up text messages from shared pages\n                           (the messages are stored there by users),\n                           formats them (adds leader, marking,\n                           checksum..), and passes them along to the\n                           Handler for transmission.\n                         * Insures delivery of incoming messages.  It is\n                           the opposite of the above operation.  The\n                           users to which the messages should be\n                           delivered are identified through the leaders.\n\n      *  Virtual space configuration:  See figure 11.\n\n      *  Specific feature:  It is integrated as an I/O process, so that\n                            it can access privileged instruction (RD/WD\n                            for indirectly initiating the Handler).\n\n        [Figure 11 - Network Process Virtual Space - see PDF file]\n\n3.4  Software Procedures\n\n   The detailed software procedures are given on the flowcharts attached\n   with Appendix A.\n\n   However, to get a quick understanding of the implementation we list\n   below some typical software procedures.\n\n3.4.1  Description of some typical sequences\n\n   Consider some of the transactions at user's disposal (See 2.4) and\n   point out the basic software procedures they imply.  For each case we\n   will delineate (i) what the user program does and (ii) what the\n   Network program does.\n\n   (a)  Open a primary link (See also 2.4.2)\n\n         (i)  What the user program does[1]:\n\n              *  it stores in the Network mail box directory the name of\n                 a file, e.g., DATA;\n              *  it couples the first page of this file to its virtual\n                 space;\n              *  it stores information in this page (its job/process #,\n                 the remote HOST #, e.g., (i));\n              *  it wakes up the Network process;\n              *  it goes to sleep.\n\n\n\n\n\nDeloche                                                        [Page 20]\n\f\nRFC 11          Host - Host Software Procedures in GORDO     August 1969\n\n\n         (ii) What the Network program does:\n\n              *  it explores the Network mail box directory and accesses\n                 the file DATA;\n              *  it couples the first page of this file to its virtual\n                 space (Shared Zone, see 3.3.1.2).  Suppose this page to\n                 be kth in the shared zone; k is the internal connection\n                 #;\n              *  it explores the ith slot of the new HOST table (See\n                 3.3.1.1 (a)) and selects the first bit = 0, e.g., the\n                 (alpha)th bit; alpha corresponds to the outgoing link\n                 #;\n              *  it stores information (job/process #, remote HOST #\n                 (i), outgoing link # (alpha)) in the kth slot of the\n                 CONNECT table (See 3.3.1.2).\n              *  it momentarily stores the connection # (k) in the INPUT\n                 LINK table.  This is carried out upon creating an entry\n                 in this table (Hashing the key value:  \"outgoing link #\n                 (alpha) + remote HOST # (i) + outgoing flag\".);\n              *  it prepares the message text ENQ PRIM 0 0 a and formats\n                 a complete message in adding leader, marking, checksum,\n                 etc.;\n              *  it checks the Handler state (bit in I/O locked page).\n                 If the Handler is free, it stores the 'ready to go'\n                 control message in the output buffer of the I/O locked\n                 page, initiates the Handler, and goes to sleep.  Else\n                 it goes to sleep.\n\n   After a while the Handler wakes up the Network process because it has\n   received a complete message.  We suppose this message be the control\n   message sent by the remote HOST for acknowledging the establishment\n   of the connection.  The message text should be:\n\n            ACK ENQ PRIM 0 0 alpha 0 0 beta\n\n   where beta is the incoming link #.  (See 2.4.2)\n\n   Let's see now what the Network program does when receiving the above\n   control message:\n\n              *  it retrieves the connection # previously stored in the\n                 INPUT LINK table upon re-hashing the same key value\n                 (See above).  Also it deletes this entry;\n              *  it creates an entry in the INPUT LINK table for the\n                 incoming link.  For so doing it hashes the key value:\n                 \"incoming link # (beta]) + remote HOST # (i) +\n                 \"incoming flag\".  In this entry it stores the HOST #\n                 (i), the incoming link # (beta), and connection # (k);\n\n\n\nDeloche                                                        [Page 21]\n\f\nRFC 11          Host - Host Software Procedures in GORDO     August 1969\n\n\n              *  it updates the kth slot of the CONNECT table in storing\n                 the incoming link # (beta);\n              *  it turns on the 'net-user' bit in the kth shared page\n                 (page corresponding to the primary connection that has\n                 just been opened) and wakes up the user process;\n              *  it goes to sleep.\n\n   (b)  Transmit a message over primary link\n\n         (i)  What the user program does[1].\n\n              *  it stores the message text in the output buffer of the\n                 primary connection shared page (see 3.3.1.2);\n              *  it turns on the 'user-net' bit of this page and wakes\n                 up the Network process;\n              *  it goes to sleep.\n\n         (ii) What the Network program does:\n\n              *  it looks for user request, i.e., it explores in\n                 sequence the connection shared pages and selects the\n                 one that has its 'user-net' bit turned on.  Suppose k\n                 be the selected page # on the shared list, K is the\n                 connection #;\n              *  it determines the request type in testing the 'request\n                 bits' of the shared page k.  It finds out that it is a\n                 request for transmitting a message.\n              *  it takes the message text from the output buffer of the\n                 shared page k, formats it into a complete message and\n                 transmits to the Handler in a very similar way as above\n                 (See Open a primary link).\n              *  it goes to sleep.\n\n      [1]  Remark:  In a first phase the user will directly write the\n                    network functions in his program.  Later on\n                    subroutines will be put at user's disposal.  These\n                    subroutines will be very close to those described in\n                    2.4.\n\n\n\n\n\n\n\n\n\n\n\n\n\nDeloche                                                        [Page 22]\n\f\nRFC 11          Host - Host Software Procedures in GORDO     August 1969\n\n\nAPPENDIX A\n\n   Flowcharts\n\n                       [see PDF file for flowcharts]\n\n       [ This RFC was put into machine readable form for entry ]\n          [ into the online RFC archives by Bob German 8/99 ]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDeloche                                                        [Page 23]\n\f\n"
}