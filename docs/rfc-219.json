{
  "series": "Request for Comments",
  "number": "219",
  "howpublished": "RFC 219",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0219",
  "url": "https://www.rfc-editor.org/info/rfc219",
  "title": "User's View of the Datacomputer",
  "pagetotal": "7",
  "year": "1971",
  "month": "sep",
  "body": "\n\n\n\n\n\nNetwork Working Group                                          R. Winter\nRequest for Comments: 219                                            CCA\nNIC: 7549                                               3 September 1971\nCategory:\nUpdates: None\nObsoletes: None\n\n                    User's View of the Datacomputer\n\nMEMORANDUM\n\nTO: Datacomputer Design File\n\nFROM: R.A. Winter\n\nSUBJECT: User's View of the Datacomputer\n\nDate: September 3, 1971\n\n________________________________________________________________________\n\nIntroduction\n\n   The datacomputer is a specialized node of the ARPA network that is\n   dedicated to the management of a large, shared database.  By large we\n   mean several trillion bits of data, of which at least one trillion\n   are on-line.  Shared may mean, for some files, shared by nearly all\n   the users in the ARPA network.\n\n   The name, datacomputer, derives from the idea that the system is\n   dedicated to data handling.  Though the processor is capable of\n   general computation, it will not be used for that purpose.  The\n   processor, like the mass storage device, is only a component of an\n   integrated system, which appears to the user as a black box.\n\n   There is one language for addressing the black box: data language.\n   This language defines everything it can do.\n\n   All the information presented in this memorandum is about the first\n   of a series of service offerings.  We use the term access method to\n   refer collectively to a structure and the operations on it.  Being\n   too modest to call the first one AM-1 (Access Method-1) we named it\n   DCAM-1 (Datacomputer Access Method-d).  We expect subsequent DCAMs to\n   generalize DCAM-1.  If the need arises, we will design parallel\n   services.  All services will use the same data language.\n\n\n\n\n\n\nWinter                                                          [Page 1]\n\f\nRFC 219             User's View of the Datacomputer       September 1971\n\n\nSystem Overview\n\n   The users of the datacomputer are programs running on other\n   computers, retrieving data from, and storing it in, the data base.\n   The environments, capabilities, and applications of these programs\n   vary widely; however, a chief design goal is to allow them to share\n   the data.\n\n   There is further variation among users in physical connection.\n   Remotely-located users' access is over a narrow link to the data-\n   computer's low-speed port.  Local users are connected to the high-\n   speed port through a link 80 times wider.\n\n   Through its ports, the datacomputer accepts two kinds of input: data\n   and requests for services.  Data is output through the ports as\n   requested.\n\n   In the data base, descriptions are stored separately from the data,\n   and data elements are named, typed and ordered according to them.  A\n   measure of structure independence is obtained by writing access\n   requests in terms of the symbolic names of items in the data\n   description.\n\n   Directories are maintained by the system.  A hierarchical naming\n   scheme is used, and access controls for privacy and data integrity\n   are provided.\n\n   Redundant copies of data and/or journals of changes are maintained by\n   the system and used to effect recovery under system control in case\n   of system error.  These facilities can be operated under user control\n   if there is external error.\n\n   Since the datacomputer's only interface with the outside world is\n   through its ports, it sees the universe as a group of data streams.\n   Specifically, these are record streams, if one views all transactions\n   (in the data transfer protocol sense) as records.  Associated with\n   each record stream is a data description, allowing the datacomputer\n   to parse the records into named, typed elements.\n\n   Thus all data elements--stream elements and data base--are named and\n   fully described.  Data type conversion proceeds automatically, as a\n   function of old and new data types, and optional information supplied\n   by the user.  Reconfiguration above the element level is a matter of\n   arrangement of elements in records; a full set of capabilities is\n   provided for this.  In general, the using program is concerned with\n   the configuration of the stream records that comprise its interface\n   with the datacomputer.  The internal configuration of data affects\n   the user only as it limits the data's accessibility or malleability.\n\n\n\nWinter                                                          [Page 2]\n\f\nRFC 219             User's View of the Datacomputer       September 1971\n\n\n   In fact, the user should not generally have to be aware of the\n   internal data configuration.\n\n   Although support on some level for all types of applications is\n   attempted, the first implementation gives particular attention to\n   large, simply-organized, shared files.  Emphasis is placed on\n   allowing the user of such files to describe precisely what data is\n   really of interest to him, so that nothing but the desired\n   information is transmitted.  This is crucial for avoiding overload of\n   the narrow link, and is accepted as a central design goal.\n\nData Base Organization\n\n   The database contains all information stored in the datacomputer.  It\n   is a set of files, which are named, physically distinct, collections\n   of data.\n\n   The location of one file, the file directory, is known to the system.\n   It contains the names, locations, and certain attributes of all the\n   other files.  Access to this file is restricted.\n\n   Internally, each file has its own organization, but each organization\n   is a particular application of a general model.  The particular\n   application is defined by a file description associated with the\n   file.\n\n   In the general model, each file contains uniquely numbered records.\n   Each record contains named fields.  A field of a certain name may\n   occur more than once in a given record, and a unique number is\n   associated with each occurrence.  A field contains an elementary\n   piece of data, the value of the field.\n\n   The records are variable in format and size.  Fields are variable in\n   length.\n\n   In addition to the records themselves; each file can contain an\n   index.  The system maintains the index to the specifications of the\n   user.  Conceptually, the index contains lists of pointers to records\n   having certain properties.  A typical list might point to the records\n   containing the field STATE with the value MASSACHUSETTS.\n\n   The system supplies a unique, permanent, identifier for each record.\n   This identifier maps trivially into a location in the file, or at\n   worst, into a small region in which the record can be quickly\n   located.  The identifier is used to pointers to the record, both from\n   the index and from other records.\n\n\n\n\n\nWinter                                                          [Page 3]\n\f\nRFC 219             User's View of the Datacomputer       September 1971\n\n\n   Besides the physical ordering, defined by record location, a logical\n   ordering will be maintained on request by the system.  This can be\n   based on some simple function of record contents, such as the value\n   of certain fields.  Alternatively, the user can compute the function,\n   and simply supply the result (for example, by saying \"insert this\n   record after that one\").  Retrieval from such ordered files can be\n   made either in physical or logical order.\n\n   In all such ordered files, if insertions are made, space must be\n   reserved for them and garbage collection must be done periodically.\n   A single field value is viewed as a homogeneous string of characters\n   or basic data units.  It is described by giving the type (e.g.,\n   ASCII, BIT, binary integer, etc.) and the length is some unit\n   associated with the type.  When the length of a field is constant\n   throughout the file, it is stored in the file description; otherwise\n   it appears with each occurrence of the field.  The type of a field is\n   constant.\n\n   The information in the file description is sufficient to parse a\n   record into (field name, value) pairs.  Also, given such a set of\n   pairs, and a file description, the system can produce a record\n   satisfying the description.  Mapping in either direction, there is\n   only one possible result.\n\n   With a record, a file description, and a (field name, value) pair to\n   store in the record, there is also only one new record that can\n   result.\n\n   Thus a file description defines all the possible formats for a record\n   from a particular file.\n\nStream Organization\n\n   Streams are sequences of records passed from using programs to the\n   datacomputer or vice versa.  The format of the records is defined as\n   in the file description.  Thus streams have the same organization as\n   files, except they cannot be indexed.  The operations defined on\n   streams are more limited than those defined on files, since the\n   records must be accessed in sequence.\n\n   There is no concept of permanent storage for streams.  The records\n   move past the datacomputer one at a time, as though they were on a\n   conveyor belt.\n\n\n\n\n\n\n\n\nWinter                                                          [Page 4]\n\f\nRFC 219             User's View of the Datacomputer       September 1971\n\n\n   One record, the current record, is available to the datacomputer in\n   each stream.  To begin formatting the subsequent record in an output\n   stream, the datacomputer transmits the current record.  To access the\n   next record in an input stream, the datacomputer relinquishes access\n   to the current one.\n\nOperations\n\n   When the user is interested in the contents of his whole file in\n   solving the problem at hand, the datacomputer's job is simple in\n   terms of information retrieval.  There may be reformatting or\n   reordering, but location of the right data to operate on is trivial.\n   However, this will not be the standard usage of the datacomputer,\n   particularly for the remote user.\n\n   For most problems, the datacomputer expects to subset the file before\n   doing anything else.  The larger the file compared to the subset, the\n   less acceptable it is to transact with the full file in order to form\n   the subset.  And the datacomputer will have such enormous files that\n   using anything but a very small subset in one problem is most\n   unusual.  Thus, subsetting without examining the entire file is a\n   fundamental requirement.\n\n   Normally, the subset will be considered formed when a list of the\n   relevant record id's or record addresses is known.\n\n   The index of the datacomputer file can be thought of as a collection\n   of primitive record id lists that the file designer expected to be\n   useful in forming interesting subsets.  The values of all important\n   fields can be indexed.  For example, every word in a field containing\n   a string of text might be indexed.  In fact, an arbitrary function of\n   the contents of the record, or the relation of the record to other\n   records can be indexed.\n\n   The common logical operators (AND, OR and NOT) are defined for record\n   subsets.  Arbitrarily complex expressions of them can be evaluated\n   with relatively little processor time or I/O.  The ease of this\n   operation results from careful design of the index and strategies,\n   the most important of which is the parallel evaluation of the Boolean\n   functions on large groups of records.  Certain statistical\n   operations--like counting the number of records satisfying a certain\n   Boolean condition--can be done directly on the index.  This can be\n   used to derive question-answering strategies heuristically, or can be\n   the direct input to a statistical study.\n\n   Once the index has done all it can in subsetting, attention turns to\n   the records themselves.  Certain conditions cannot be evaluated using\n   the index; an obvious case is the selection of records based on the\n\n\n\nWinter                                                          [Page 5]\n\f\nRFC 219             User's View of the Datacomputer       September 1971\n\n\n   value of an unindexed field.  Also, certain data structures cannot be\n   explicitly represented in the file:record:field model.  These must be\n   constructed by the user, out of groups of records linked by pointers,\n   or using other special mechanisms.  The class of operations that is\n   useful in further record selection consists of field content testing,\n   pointer chasing, simple computation in the numerical and symbolic\n   senses, and various operations below the data element level, such as\n   pattern matching, string manipulation, etc.  Such operations require\n   a control structure approaching that of the general purpose higher\n   level language.  It is our intention to make all of this available,\n   though not with the goal of providing a computation facility, but\n   rather, a data management facility that is capable of using as much\n   knowledge as the programmer can supply.\n\n   A simple set of primitives is required for file maintenance in the\n   data structure we are talking about.  The operations are:\n\n      1. add a field/record\n      2. delete a field/record\n      3. replace a field/record.\n\n   The difficult part, as in retrieval, is locating the element to be\n   operated on.   Notice that individual record formats can be changed\n   at will: the set of possible formats is limited only by the file\n   description.\n\n   When record contents are changed, index entries that are a function\n   of them must be changed also.  When the function determining what is\n   to be indexed is part of the file description, the maintenance of the\n   index is automatically performed by the system.  Otherwise, this is\n   the responsibility of the user.\n\n   All fields in a record can be optional, variable length, allowed to\n   occur an arbitrary number of times (up to some fixed limit for each\n   field).  Fields can be present and later be deleted from any record.\n   Fields can be added to the file description at any time.  The only\n   reason for limiting the flexibility of a record format is to reduce\n   storage.\n\nApplications\n\n   The system outlined here is intended to be suitable for many\n   applications; some examples are:\n\n   1. Storage and retrieval of dumps and other unstructured files.  The\n      system will happily pack away your one enormous record, as quickly\n      and painlessly as possible.\n\n\n\n\nWinter                                                          [Page 6]\n\f\nRFC 219             User's View of the Datacomputer       September 1971\n\n\n   2. Applications that would normally be set up on tape:  sequentially\n      accessed files that are copied over when they are changed.  Most\n      record formats should be able to remain just as they are.  If you\n      want to operate this way, the datacomputer imposes no overhead\n      (such as indexing) on you.  The datacomputer willingly acts as\n      unsophisticated as a tape drive; it will pass your file, adding\n      and changing records as it copies them.  It will pull off the\n      interesting ones, reconfigure if desired, and transmit them to\n      you.  When you describe the data, you have solved the data sharing\n      problem for this application.\n\n   3. Simple-minded direct access applications.  The great hairy index\n      structure neatly degenerates to imitate indexed sequential, simple\n      directly-addressed files, and other old standbys in the direct\n      access world.\n\n   4. Text/document retrieval.  The indexing is made for this kind of\n      applications.  In addition, documents can point to subdocuments,\n      related documents, etc.\n\n   5. Content-oriented, rapid retrieval applications are the specialty\n      of the house.\n\n   6. Large data bases used for statistical analysis or modeling such as\n      the census, the common social science data bases, etc.\n\n   7. Applications in which data element groups (such as records) are\n      related in a complex fashion, and the intelligence of the\n      datacomputer, which is close to the data and remote from the\n      computational facility, can be put to good use.\n\n   In all of these, an important consideration is size.  We hope to\n   handle these applications properly on the datacomputer, even when the\n   files are of extraordinary size.\n\n\n        [ This RFC was put into machine readable form for entry   ]\n        [ into the online RFC archives by Sandy Ginoza 9/2001.    ]\n        [ Original has hand-written note in Postel's handwriting: ]\n        [ \"Received 21 Sept 71\".                                  ]\n\n\n\n\n\n\n\n\n\n\n\nWinter                                                          [Page 7]\n\f\n"
}