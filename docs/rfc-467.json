{
  "series": "Request for Comments",
  "number": "467",
  "howpublished": "RFC 467",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0467",
  "url": "https://www.rfc-editor.org/info/rfc467",
  "title": "Proposed change to Host-Host Protocol: Resynchronization of connection status",
  "pagetotal": "7",
  "year": "1973",
  "month": "feb",
  "body": "\n\n\n\n\n\nNetwork Working Group                                       J. Burchfiel\nRequest for Comments: 467                                   R. Tomlinson\nNIC: 14741                                       Bolt Beranek and Newman\n                                                        20 February 1973\n\n                 Proposed Change To Host-Host Protocol\n                Resynchronization Of Connection Status\n\nI. Introduction\n\n   The current Host-Host protocol (NIC #8246) contains no provisions for\n   resynchronizing the status information kept at the two ends of each\n   connection.  In particular, if either host suffers a service\n   interruption, or if a control message is lost or corrupted in an\n   interface or in the subnet, the status information at the two ends of\n   the connection will be inconsistent.\n\n   Since the current protocol provides no way to correct this condition,\n   the NCP's at the two ends stay \"confused\" forever.  A frequent and\n   frustrating symptom of this effect is the \"lost allocate\" phenomenon,\n   where the receiving NCP believes that it has bit and message\n   allocations outstanding, while the sending NCP believes that it does\n   not have any allocation.  As a result, information flow over that\n   connection can never be restarted.\n\n   Use of the Host-Host RST (reset) command is inappropriate here, as it\n   destroys all connections between the two hosts.  What is needed is a\n   way to reset only the affected connection without disturbing any\n   others.\n\n   A second troublesome symptom of inconsistency in status information\n   is the \"half-closed\" connection: after a service interruption or\n   network partitioning, one NCP may believe that a connection is still\n   open, while the other believes that the connection is closed. (Does\n   not exist.)  When such an inconsistency is discovered, the \"open\" end\n   of the connection should be closed.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBurchfiel                                                       [Page 1]\n\f\nRFC 467                                                    February 1973\n\n\nII. The RCR and RCS Commands\n\n   To achieve resynchronization of allocation, we propose the addition\n   of the following two commands to the host-host protocol.\n\n         8           8\n   +-----------+-----------+\n   |    RCS    |   link    |   Reset connection by sender\n   +-----------+-----------+\n\n         8           8\n   +-----------+-----------+\n   |    RCR    |   link    |   Reset connection by receiver\n   +-----------+-----------+\n\n   The RCS command is sent from the host sending on \"link\" to the host\n   receiving on \"link\".  This command may be sent whenever the sending\n   host desires to re-synch the status information associated with the\n   connection.  Some circumstances in which the sending Host may choose\n   to do this are:\n\n      1.) After a timeout when there is traffic to move but no\n      allocation. (Assumes that an allocation has been lost)\n\n      2.) When an inconsistent event occurs associated with that\n      connection (e.g. an outstanding allocation in excess of 2^32 bits\n      or 2^16 messages.\n\n   The mechanics of re-synchronizing the allocations is simply:\n\n      1.) Empty all messages and allocates from the \"pipeline\".\n\n      2.) Zero the variables at both ends indicating bit and message\n      allocation.\n\n      3.) Restart allocate/message exchanges in the normal way.\n\n   This resynchronization scheme is race-free because the RCS and RCR\n   commands are used as a positive acknowledgement pair.\n\nIII. Resynchronization by Sender\n\n   To initiate resynchronization, the sending NCP should:\n\n      1.) Put the connection in a \"waiting-for-RCR-reply\" state.  No\n      more regular messages may be transmitted over this connection\n      until the RCR reply is received.\n\n\n\n\nBurchfiel                                                       [Page 2]\n\f\nRFC 467                                                    February 1973\n\n\n      2.) Wait until the message pipeline is empty, i.e. until a RFNM\n      has been received for each regular message sent over this\n      connection.  This synchronizes the control and data activity, and\n      also assures that the data stream will not be corrupted during the\n      control re-synchronization exchange.\n\n      3.) Send the RCS command.\n\n      4.) Continue to process allocates normally, updating the variables\n      which indicate outstanding bit and message allocation.\n\n   When the receiving NCP receives the RCS, it should:\n\n      1.) Zero the variables indicating outstanding bit and message\n      allocation.\n\n      2.) Reset the connection to the state which indicates readiness to\n      accept a message.\n\n      3.) Confirm the re-synchronization by sending the RCR reply.\n\n      4.) Reconsider bit and message allocation, and send an ALL command\n      for any allocation it cares to do.\n\n   When the sending host receives the RCR reply, it should:\n\n      1.) Zero the variables indicating outstanding bit and message\n      allocate.\n\n      2.) Put the connection into the \"ready-to-send-message\" state in\n      preparation for any forthcoming ALL commands.\n\n   At this point, the \"pipeline\" contains no messages and no allocates,\n   and the outstanding allocation variables at both ends are in\n   agreement. (With value zero)\n\nIV. Resynchronization By Receiver\n\n   The re-synchronization sequence may be triggered by the receiving\n   NCP.  Such resynchronization could be initiated manually by TIP and\n   TELNET users who are expecting output but receiving none.  Again\n   assuming that allocation has been lost, the appropriate action is to\n   reset the connection by sending an RCR command.  This action is also\n   appropriate if an inconsistent event occurs with respect to the\n   connection.  (e.g. arrival of a message which exceeds allocation).\n\n\n\n\n\n\nBurchfiel                                                       [Page 3]\n\f\nRFC 467                                                    February 1973\n\n\n   To initiate re-synchronization, the receiving NCP should:\n\n      1.) Put the connection into a \"waiting-for-RCS-reply\" state.  No\n      more allocates may be transmitted for this connection until the\n      RCS reply is received.\n\n      2.) Send the RCR command.\n\n      3.) Continue to process regular messages normally, updating the\n      variables which indicate outstanding bit and message allocation.\n\n   When the sending NCP receives the RCR command, it should:\n\n      1.) Wait until the message pipeline is empty, i.e. until the RFNM\n      has been received for each regular message sent over the\n      connection.  This synchronizes the control and data activity, and\n      also assures that the data stream will not be corrupted during the\n      control re-synchronization exchange.\n\n      2.) Zero the variables indicating outstanding bit and message\n      allocation.\n\n      3.) Put the connection into the \"ready-to-send-message\" state in\n      preparation for any forthcoming ALL commands.\n\n      4.) Confirm the re-synchronization by sending the RCS reply.\n\n   When the receiving host receives the RCS reply, it should:\n\n      1.) Zero the variables indicating outstanding bit and message\n      allocation.\n\n      2.) Reset the connection to the state which indicates readiness to\n      accept a message.\n\n      3.) Reconsider bit and message allocation, and send an ALL command\n      for any allocation it cares to do.\n\nV. Simultaneous Resynchronization\n\n   This specification for a re-synchronization exchange is guaranteed to\n   restore the allocation information at the two ends to a consistent\n   state.  This happens correctly whether the re-synchronization is\n   triggered by the sender, the receiver, or both at the same time.\n   When both ends initiate a command at the same time, (the RCS and RCR\n   commands cross in the pipeline) each interprets the other's command\n   as a confirmation reply; thus, the resynchronization happens\n   correctly independent of the relative timing.\n\n\n\nBurchfiel                                                       [Page 4]\n\f\nRFC 467                                                    February 1973\n\n\n   The essential factor here is that when either end receives the reset\n   request, it is sure that the other end will take no further actions\n   which could affect the allocation variables.  The activity which\n   occurs during simultaneous resynchronization by both ends is as\n   follows:\n\n   The sending NCP:\n\n      1. Puts the connection into a \"waiting-for-RCR-reply\" state.  No\n      more regular messages may be transmitted over this connection\n      until the RCR reply is received.\n\n      2. Waits until the message pipeline is empty, i.e. until a RFNM\n      has been received for each regular message sent over this\n      connection.  This synchronizes the control and data activity, and\n      also assures that the data stream will not be corrupted during the\n      control re-synchronization exchange.\n\n      3. Sends the RCS command.\n\n      4. Continues to process allocates normally, updating the variables\n      which indicate outstanding bit and message allocation.\n\n   Concurrently with 1, 2, 3 and 4 above, the receiving NCP:\n\n      5. Puts the connection into a \"waiting-for-RCS-reply\" state.  No\n      more allocates may be transmitted for this connection until the\n      RCS reply is received.\n\n      6. Sends the RCR command.\n\n      7. Continues to process regular messages normally.\n\n   The RCS and RCR commands cross somewhere in the pipeline.  When the\n   sender receives the RCR command, it interprets it as a reply to its\n   own RCS command.  It then:\n\n      8. Zeroes the variables indicating outstanding bit and message\n      allocation.\n\n      9. Puts the connection into the \"ready-to-send-message\" state in\n      preparation for any forthcoming ALL commands.\n\n   Concurrently with 8 and 9 above, the receiving NCP will receive the\n   RCS command.  It will interpret it as a reply to its own RCR command.\n   It then:\n\n\n\n\n\nBurchfiel                                                       [Page 5]\n\f\nRFC 467                                                    February 1973\n\n\n      10. Zeroes the variables indicating outstanding bit and message\n      allocation.\n\n      11. Resets the connection to the state which indicates readiness\n      to accept a message.\n\n      12. Reconsiders bit and message allocation, and sends an ALL\n      command for any allocation it cares to do.\n\nVI. The Problem Of Half-closed Connections\n\n   The above procedures provide a way to resynchronize a connection\n   after a brief lapse by a communications component, which results in\n   lost messages or allocates for an open connection.\n\n   A longer and more severe interruption of communication may result\n   from a partitioning of the subnet or from a service interruption on\n   one of the communicating hosts.  It is undesirable to tie up\n   resources indefinitely under such circumstances, so the user is\n   provided with the option of freeing up these resources (including\n   himself) by unilaterally dissolving the connection.  Here\n   \"unilaterally\" means sending the CLS command and closing the\n   connection without receiving the CLS acknowledgement.  Note that this\n   is legal only if the subnet indicates that the destination is dead.\n\n   When service is restored after such an interruption, the status\n   information at the two ends of the connection is out of\n   synchronization.  One end believes that the connection is open, and\n   may proceed to use the connection.  The disconnecting end believes\n   that the connection is closed (does not exist), and may proceed to\n   re-initialize communication by opening a new connection (RTS or STR\n   command) using the same local socket.\n\n   The re-synchronization needed here is to properly close the open end\n   of the connection when the inconsistency is detected.  We propose to\n   accomplish this by changing the semantics of three existing host-host\n   protocol commands.\n\nVII. Redefinition of RTS, STR, ERR (link) to Handle Half-closed\n   Connections\n\n   The \"missing CLS\" situation described above can manifest itself in\n   two ways.  The first way involves action taken by the NCP at the\n   \"open\" end of the connection.  It may continue to send regular\n   messages on the link of the half-closed connection, or control\n   messages referencing its link.  The NCP at the \"closed\" end should\n   respond with the ERR message, specifying that the link is unknown.\n   (Error code = 5 does not correspond to an open connection).  On\n\n\n\nBurchfiel                                                       [Page 6]\n\f\nRFC 467                                                    February 1973\n\n\n   receipt of such an ERR message, the NCP at the \"open\" end should\n   close the connection by modifying its tables, (without sending any\n   CLS command) thereby bringing both ends into agreement.\n\n   The second way this inconsistency can show up involves actions\n   initiated by the NCP at the \"closed\" end.  It may (thinking the\n   connection is closed) send an STR or RTS to reopen the connection.\n   The NCP at the \"open\" end will detect an inconsistency when it\n   receives such an RTS or STR command, because it specifies the same\n   foreign socket as an existing open connection.  In this case, the NCP\n   at the \"open\" end should close the connection (without sending any\n   CLS command) to bring the two ends into agreement before responding\n   to the RTS/STR.\n\nVIII. Conclusions\n\n   The scheme presented in Section II to resynchronize allocation has\n   one very important property: the data stream is preserved through the\n   exchange.  Since no data is lost, it is safe to initiate re-\n   synchronization from either end at any time.  When in doubt, re-\n   synchronize.\n\n   The changes in the semantics of RTS, STR, and ERR(code 5) commands\n   provide the synchronization needed to complete the closing of \"half-\n   closed\" connections.\n\n   The protocol changes above will make the host-host protocol far more\n   robust, in that useful work can continue in spite of lapses by the\n   communications components.\n\n\n         [ This RFC was put into machine readable form for entry ]\n            [ into the online RFC archives by Via Genie 08/00]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBurchfiel                                                       [Page 7]\n\f\n"
}