{
  "series": "Request for Comments",
  "number": "333",
  "howpublished": "RFC 333",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0333",
  "url": "https://www.rfc-editor.org/info/rfc333",
  "title": "Proposed experiment with a Message Switching Protocol",
  "pagetotal": "26",
  "year": "1972",
  "month": "may",
  "body": "\n\n\n\n\n\nNetwork Working Group                                       Bob Bressler\nRequest for Comments: 333                           MIT/Dynamic Modeling\nNIC # 9926                                                    Dan Murphy\nCategory: C9 (experimentation)                                 BBN/TENEX\nObsoletes: 62                                                Dave Walden\nUpdates: none                                                    BBN/IMP\n                                                             15 May 1972\n\n\n        A PROPOSED EXPERIMENT WITH A MESSAGE SWITCHING PROTOCOL\n\n\nCONTENTS\n\n   Introduction ..................................................  1\n   Some Background ...............................................  2\n   References ....................................................  3\n   MSP Specification .............................................  4\n   Issue .........................................................  8\n   Message Header ................................................ 10\n   Examples ...................................................... 15\n   TELNET ........................................................ 16\n   The Information Operator ...................................... 16\n   Unique Port Numbers ........................................... 20\n   Flow Chart .................................................... 23\n   MSP Variations ................................................ 25\n   Appendix ...................................................... 26\n\nINTRODUCTION\n\n   A message switching protocol (MSP) is a system whose function is to\n   switch messages among its ports.\n\n   For example, there is an implementation of an MSP in each Interface\n   Message Processor.  We believe that the effective utilization of\n   communications networks by computer operating systems will require a\n   better understanding of MSPs.  In particular, we feel that Network\n   Control Programs (NCPs), as they have been implemented on the ARPA\n   Computer Network (ARPANET), do not adequately emphasize the\n   communications aspects of networking -- i.e., they reflect a certain\n   reluctance on the part of systems people to move away from what we\n   term \"the stream orientation\".  We propose, as an aside the network\n   development using the current NCPs, to rethink the design of NCP-\n   level software beginning with a consideration of MSPs.\n\n   The thrust of this note is to sketch how one would organize the\n   lowest level host-host protocol in the ARPANET around MSPs and how\n   this organization would affect the implementation of host software.\n\n\n\nBressler, et al.            Experimentation                     [Page 1]\n\f\nRFC 333          MESSAGE SWITCHING PROTOCOL EXPERIMENT          May 1972\n\n\nSOME BACKGROUND\n\n   Over the past several weeks there has been considerable informal\n   discussion about the possibility of implementing, on an experimental\n   basis, in several of the ARPA Network Host Computers, NCPs which\n   follow a protocol based on the concept of message switching rather\n   than the concept of line switching (see the parenthetical sentence in\n   the first paragraph of page 6 of NIC document 8246, Host/Host\n   Protocol for the ARPA Network).  Party to this discussion have been\n   Bob Bressler (MIT/Dynamic Modeling) Steve Crocker (ARPA), Will\n   Crowther (BBN/IMP), Tom Knight (MIT/AI), Alex McKenzie (BBN/IMP), Bob\n   Metcalfe (MIT/Dynamic Modeling), Dan Murphy (BBN/TENEX), Jon Postel\n   (UCLA/NMC), and Dave Walden (BBN/IMP).\n\n   Several interesting points and conclusions have been made during this\n   discussion:\n\n      1. Bressler has implemented a message switched interprocess\n         communication system for the Dynamic Modeling PDP-10 and has\n         extended it so it could be used for interprocess communication\n         between processes in the Dynamic Modeling PDP-10 and the AI\n         PDP-10.  He reports that it is something like an order of\n         magnitude smaller than his NCP.\n\n      2. Murphy has noted that a Host/Host protocol based on message\n         switching could be implemented experimentally and run in\n         parallel with the real Host/Host protocol using some of the\n         links set aside for experimentation.  Further, Murphy has noted\n         that if this experimental message switching protocol were\n         implemented in TENEX, a number of (TENEX) sites could easily\n         participate in the experiment.\n\n      3. It is the consensus of the discussants that Bressler should\n         take a crack at specifying a message switching protocol* and\n         that if this specification looked relatively easy to implement,\n         a serious attempt should be made by Murphy and Bressler to find\n         the resources to implement the experimental protocol on the two\n         BBN TENEX and the MIT Dynamic Modeling and AI machines.\n\n      4. MSP was chosen as the acronym for Message Switching Protocol,\n         and links 192-195 were reserved for use in an MSP experiment.\n\n\n\n   -------------\n   *This note fulfills any obligation Bressler may have incurred to\n   produce an MSP specification.\n\n\n\n\nBressler, et al.            Experimentation                     [Page 2]\n\f\nRFC 333          MESSAGE SWITCHING PROTOCOL EXPERIMENT          May 1972\n\n\n   We solicit comments and suggestions from the Network Working Group\n   with regard to this experiment.  However, although we will very much\n   appreciate comments and suggestions, because this is a limited\n   experiment and not an attempt to specify a protocol to supersede the\n   present Host/Host protocol for the ARPA Network, we may arbitrarily\n   reject suggestions.\n\nREFERENCES\n\n   Familiarly with the following references will be helpful to the\n   reading of the rest of this note.\n\n      1) NIC document 8246, HOST/HOST PROTOCOL FOR THE ARPA NETWORK\n\n      2) NIC document 9348 on the Telnet Protocol\n\n      3) NIC document 7101, OFFICIAL INITIAL CONNECTION PROTOCOL,\n         DOCUMENT # 2\n\n      4) a system of interprocess communication in a resource sharing\n         computer network, CACM, April, 1972.\n\n   Reference 4 is a revision of RFC 62.  We strongly suggest the reader\n   be familiar with reference 4 before he attempts to read the present\n   RFC; a reprint of reference 4 is attached as an appendix.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBressler, et al.            Experimentation                     [Page 3]\n\f\nRFC 333          MESSAGE SWITCHING PROTOCOL EXPERIMENT          May 1972\n\n\nMSP SPECIFICATION\n\n   Our MSP is essentially a generalization of the interprocess\n   communication system outlined in Section 3 of the fourth reference.\n   (Henceforth, if we are required to mention the interprocess\n   communication system presented in Section 3 of reference 4, we shall\n   call it \"the IPC\".)  For two processes to communicate using the MSP,\n   the process desiring to send must in some sense execute a SEND and\n   the process desiring to receive must in some sense execute a RECEIVE.\n   The SEND and RECEIVE, in effect, rendezvous somewhere and\n   transmission is allowed to take place.  With the RECEIVE are\n   specified (among other things) a FROM-TO-PORT-ID, a TO-PORT-ID, and a\n   RENDEZVOUS HOST.  With SEND are specified a from-port-id, a to-port-\n   id, a rendezvous Host, and (possibly) some data to be transmitted.\n   Using SEND and RECEIVE, sending a message from a SENDER PROCESS to a\n   RECEIVER PROCESS takes place as follows.  The sender process executes\n   a SEND which causes an OUT-MESSAGE plus the specified data to be\n   transmitted to the Host specified as the rendezvous Host in the SEND.\n   Concurrently (although not necessarily simultaneously)the receiver\n   process executes a RECEIVE which causes an IN-MESSAGE to be sent to\n   the Host specified as the rendezvous Host in the RECEIVE.  At the\n   rendezvous Host, OUT-messages and IN-messages are entered in a table\n   called the RENDEZVOUS TABLE.  When an OUT-message and an IN-message\n   are detected with matching to-port-id, from-port-id, and rendezvous\n   Host, three things are done:  1)  the OUT-message plus the data is\n   forwarded to the Host which was the source of the IN-message, 2)  the\n   IN-message is forwarded to the Host which was the source of the OUT-\n   message, and 3)  the IN-message and OUT-message plus the data are\n   deleted from the rendezvous table in the rendezvous Host.\n\n   The process is greatly simplified if the rendezvous Host is also\n   either the send Host or receive Host.  Specific algorithms\n   enumerating these sequences appear later in this note.\n\n   To clarify the basic concepts, let us look at a case involving three\n   Hosts, to which we shall give the names SND, RCV, and RNDZ.  At Host\n   SND, process S is doing a send, and at Host RCV, process R is doing a\n   receive.  Both specify rendezvous at Host RNDZ.\n\n\n\n\n\n\n\n\n\n\n\n\n\nBressler, et al.            Experimentation                     [Page 4]\n\f\nRFC 333          MESSAGE SWITCHING PROTOCOL EXPERIMENT          May 1972\n\n\n+--------------------+     +----------+     +--------------------+\n|HOST SND            |     |          |     |HOST RCV            |\n|                    |     |          |     |                    |\n|                    |     |          |     |                    |\n|       (PROCESS)    |     +----------+     |                    |\n|       (   S   )    |         HOST         |                    |\n|              \\     |         RNDZ         |          (PROCESS) |\n|              [DATA]|                      |          (  R    ) |\n+--------------------+                      +--------------------+\n\n\nProcess S now executes a SEND with\n\n     from-port-id = S, to-port-id = R, and rendezvous-Host = RNDZ.\n\nHost SND then creates a table entry in its rendezvous table.\n\n+-----------------------------------+\n|HOST SND            MSP   _ _ _    |\n|           -------------\u003e|_ _ _|   |\n|         /        ^      |_ _ _| \u003c-|-------RENDEZVOUS\n|        /         |      |_ _ _|   |         TABLE\n|(PROCESS)         |                |\n|(   S   )         +-- SEND (from=S to=R; rend=RNDZ)\n|        \\                          |\n|         [DATA]                    |\n+-----------------------------------+\n\nHost SND now sends an \"OUT\" message with S's data to Host RNDZ.\n\n  HOST SND                               HOST RNDZ\n+------------+                    +---------------------------+\n|         MSP|  \"OUT\" + DATA      |MSP  _____  RENDEZVOUS     |\n|            |--------------------|--\u003e |_ _ _| TABLE          |\n|            |  from=S; to=R      | \\  |_ _ _|                |\n|            |                    |  \\ |_ _ _|                |\n+------------+                    |   \\             __        |\n                                  |    \\----------\u003e|  | DATA  |\n                                  |                |__|BUFFER |\n                                  |                           |\n                                  +---------------------------+\n\n   Concurrently process R at Host RCV executes a RECEIVE with from-\n   port-id = S, to-port-id = R, and rendezvous-Host = RNDZ.  As above,\n   Host RCV creates a table entry in its rendezvous table and sends an\n   \"IN\" message to Host RNDZ (see following figure).\n\n\n\n\n\nBressler, et al.            Experimentation                     [Page 5]\n\f\nRFC 333          MESSAGE SWITCHING PROTOCOL EXPERIMENT          May 1972\n\n\n   (Don't panic now about buffering in an intermediate Host.  The time\n   to panic is afer you've read and understood the rest of our\n   arguments.)\n\n     HOST RNDZ                          HOST RCV\n+------------------------+       +-----------------------+\n|                 MSP    |       |  MSP                  |\n|       TABLE    _____   |       |   _____  TABLE        |\n|             +-|_ _ _|  |  \"IN\" |  |_ _ _|              |\n|             | |_ _ _|\u003c-|----------|_ _ _|\u003c-\\           |RECEIVE\n|             | |_ _ _|  |       |  |_ _ _|   \\       \u003c--|(from=S\n|             |          |       |             \\         |  to=R\n|            _V_         |       |              \\        | rend=RNDZ)\n|    BUFFER |   |        |       |             (PROCESS) |\n|           |___|        |       |             (   R   ) |\n+------------------------+       +-----------------------+\n\n   Host RNDZ now notices that the \"OUT\" from Host SND and the \"IN\" from\n   R at RCV match one another and thus Host RNDZ takes three actions:\n\n      1. Sends an \"IN to Host SND (from-port-id = S, to-port-id = R,\n         rendezvous-Host = RNDZ).\n\n      2. Sends an \"OUT\" and the buffered data to Host RCV (from-port-id\n         = S, to-port-id = R, rendezvous-Host =RNDZ)\n\n      3. Clears the entry from its table.\n\n   HOST SND                                           HOST RCV\n   +------------------+        +------------+         +-------------+\n   |                  |        |   TABLE    |         |             |\n   |   TABLE  ___     |  \"IN\"  |    ___     |  \"OUT\"  |   ___  TABLE|\n   |         |___|    |        |   |___|    |  + DATA |  |_ _|      |\n   |         |___|\u003c---|--------|---|___|----|---------|-\u003e|_ _|      |\n   |         |___|    |        |   |___|    |         |  |_ _|      |\n   | ( S )            |        +------------+         |        ( R )|\n   |                  |          HOST RNDZ            |             |\n   +------------------+                               +-------------+\n\n   Host RCV gets the \"OUT\" and DATA and finds the matching entry in its\n   table.  It gives the DATA to process R and clears the entry from its\n   table.\n\n   Host SND gets an \"IN\" which matches an entry in his table and clears\n   that entry.  This message serves as a combined acknowledgement and go\n   ahead which can be passed along to process S.\n\n   The transmission is now complete.\n\n\n\nBressler, et al.            Experimentation                     [Page 6]\n\f\nRFC 333          MESSAGE SWITCHING PROTOCOL EXPERIMENT          May 1972\n\n\n   By both, one, or neither of the sender and receiver processes\n   specifying a remote rendezvous Host, four important different kinds\n   of transmissions can be made to take place.  These are illustrated in\n   the following four figures.  In the figures crossed or parallel\n   dotted lines are used to indicate rendezvous.  The site of the\n   \"crossed rendezvous\" is the important difference between types of\n   transmission illustrated in figures.  Circles indicate processes.\n   Rectangles are rendezvous tables.\n\n   The figures also show \"(IN)\" and \"(OUT)\" messages being passed into\n   the processes.  The parentheses are used to indicate that the \"IN\"\n   and \"OUT\" are only CONCEPTUALLY passed into the processes.  What\n   actually happens is implementation dependent.  The process might be\n   awakened and be given no further information if it blocked when\n   issuing the SEND or RECEIVE.  The process might be interrupted and\n   passed some information such as the to-port-id from the IN or the\n   from-port-id of the OUT.  The process might actually be passed the\n   complete IN or OUT message.\n\n      ------         _________           ------\n     (      )       |         |         (      )\n     (      ) SEND  |         | RECEIVE (      )\n     (      )------\u003e|--+  +---|\u003c--------(      )\n     (      )       |   \\/    |         (      )\n     (      ) (IN)  |   /\\    |  (OUT)  (      )\n     (      )\u003c------|--+   +--|--------\u003e(      )\n     (______)       |_________| +DATA   (______)\n\n     |\u003c------------- Host K ------------------\u003e|\n\n               A Rendezvous at the Sender's Host\n\n\n      ----         _______               ______          ----\n     (    )       |       |             |      |        (    )\n     (    ) SEND  |       |      IN     |      | RECEIVE(    )\n     (    )------\u003e|-+  +--|\u003c------------|------|\u003c-------(    )\n     (    )       |  \\/   |             |      |        (    )\n     (    ) (IN)  |  /\\   |  OUT+DATA   |      | (OUT)  (    )\n     (    )\u003c------|-+  +--|------------\u003e|------|-------\u003e(    )\n     (____)       |_______|             |______| +DATA  (____)\n\n     |\u003c---- Host K ------\u003e|\u003c-- Network--\u003e|\u003c----- Host L -----\u003e|\n\n               A Rendezvous at the Sender's Host\n\n\n\n\n\n\nBressler, et al.            Experimentation                     [Page 7]\n\f\nRFC 333          MESSAGE SWITCHING PROTOCOL EXPERIMENT          May 1972\n\n\n      ----         ______                _______          ----\n     (    )       |      |              |       |        (    )\n     (    ) SEND  |      |   OUT+DATA   |       | RECEIVE(    )\n     (    )------\u003e|------|-------------\u003e|-+  +--|\u003c-------(    )\n     (    )       |      |              |  \\/   |        (    )\n     (    ) (IN)  |      |      IN      |  /\\   | (OUT)  (    )\n     (    )\u003c------|------|\u003c-------------|-+  +--|-------\u003e(    )\n     (    )       |      |              |       | +DATA  (    )\n     (____)       |______|              |______ |        (____)\n\n     |\u003c---- Host K -----\u003e|\u003c-- Network--\u003e|\u003c----- Host L -----\u003e|\n\n               A Rendezvous at the Receiver's Host\n\n\n  ----         ______            _______            ______         ----\n (    )       |      |          |       |          |      |       (    )\n (    ) SEND  |      | OUT+DATA |       |    IN    |      |RECEIVE(    )\n (    )------\u003e|------|---------\u003e|-+  +--|\u003c---------|------|\u003c------(    )\n (    )       |      |          |  \\/   |          |      |       (    )\n (    ) (IN)  |      |    IN    |  /\\   |OUT+DATA  |      | (OUT) (    )\n (    )\u003c------|------|\u003c---------|-+  +--|---------\u003e|------|------\u003e(    )\n (    )       |      |          |       |          |      | +DATA (    )\n (____)       |______|          |______ |          |______|       (____)\n\n |\u003c---- Host K -----\u003e|\u003c--Net--\u003e|\u003c-Host-\u003e|\u003c--Net--\u003e|\u003c----- Host L -----\u003e|\n                                   M\n\n               A Rendezvous at an Intermediate Host\n\nISSUES\n\nTimeouts.\n\n   The issue of timeouts is a very sticky one.  A coherent system of\n   timeouts simplifies everything and does away with races.  However,\n   many Hosts are unwilling or unable to use timeouts, especially\n   timeouts whose duration is specified.\n\n   Without these timeouts there is probably a need for a negative\n   acknowledgment which goes back to the source of an IN or OUT when one\n   is timed out.  However, this now leads to races.\n\n   A negative acknowledgment (which we will refer to as a FLUSH message)\n   could be employed by a Host to mean:\n\n\n\n\n\n\nBressler, et al.            Experimentation                     [Page 8]\n\f\nRFC 333          MESSAGE SWITCHING PROTOCOL EXPERIMENT          May 1972\n\n\n      1. I have no room in my table\n\n      2. I have no more available buffer space or\n\n      3. I no longer wish to retain the table entry/buffer.\n\n      In general, we believe that a Host should be allowed to throw away\n      an IN or OUT+data whenever it is no longer convenient for the Host\n      to hold the messages.  This can be immediately on the arrival of a\n      message; for instance, if the Host does not want to buffer traffic\n      for which it does not have a user buffer.  In lieu of timeouts,\n      any time a process issues a SEND or RECEIVE, it can take it back\n      by issuing the matching RECEIVE or SEND.\n\nBlocking the Process After a Send or Receive.\n\n      This is a question which is left implementation dependent.  In\n      general, we do not think it is a good idea to block the process\n      after a SEND since it may want to do another to another port or\n      even do a RECEIVE.  In fact, we see nothing  inherently wrong with\n      a process doing two or more SENDs to the same port as long as the\n      communicating processes know what they are doing.  Of course, some\n      communicating processes will prohibit several simultaneous\n      messages being in transit between the same ports, for instance the\n      TELNETs may well prohibit this.  However, for reasons of\n      increasing bandwidth, etc., two processes may well want several\n      simultaneous messages.  In this case we think it is up to the\n      processes to worry about the sequencing of messages; however, we\n      refer users desiring their processes to take a care of message\n      sequencing to the method used in the IMP/Very Distant Host\n      interface which is documented in Appendix F of BBN Report 1822.\n\nMessage Buffering\n\n      A few points are worth mentioning with regard to message\n      buffering.  First, most OUTs will probably be accompanied by data.\n      Therefore, in general, since the receiver process may be swapped\n      out, the receiver Host monitor must be prepared to buffer some\n      data somewhere.  To minimize the amount of buffering needed, the\n      monitor could refuse further traffic from the IMP until the\n      earlier traffic from the IMP has been written on a disk or drum.\n      Or the monitor could have a small number of buffers in the monitor\n      area of memory which it fills as traffic comes from the IMP, and\n      which are swapped with buffers claimed earlier by the receiver\n      processes as the receiver processes are swapped in.  Note that the\n      buffers may be less than the maximum subnet message size in length\n      if the RECEIVEs never specify a longer message length -- of\n      course, this can be enforced.  Finally note that the message size,\n\n\n\nBressler, et al.            Experimentation                     [Page 9]\n\f\nRFC 333          MESSAGE SWITCHING PROTOCOL EXPERIMENT          May 1972\n\n\n      receive-port-id, etc. are available in the first 144 bits which\n      come in from the IMP.  It might be useful to read this before\n      deciding into which buffer to read the rest of the message.\n\nPositive Acknowledgments\n\n      Built into the system is a certain form of acknowledgment.  The\n      information is always available as to when the receiving process\n      has done a RECEIVE.  The sending Host is assured of receiving an\n      \"IN\" when the receive call is issued.\n\n      Further forms of acknowledgment and validation can be implemented\n      at the first user level, and advanced protocols will probably\n      develop a library of such routines.\n\nMESSAGE HEADER\n\n      The following section deals with the specific format of Host to\n      Host messages and algorithms describing the proper response to a\n      given message.\n\n      Each message begins with a 144 bit header containing the following\n      fields:\n\n      1. HOST-TO-IMP leader (32 bits) as specified in BBN Reports 1822\n\n      2. to port ID (i.e., the id of the port receiving the message) (24\n         bits)\n\n      3. MSG TYPE (8 bits) IN, OUT, FLUSH, etc.\n\n      4. from port ID (i.e., id or the port sending the message) (24\n         bits)\n\n      5. initiating Host's table position (8 bits) see below.\n\n      6. HOST \"sourcing\" this message (8 bits) see below.\n\n      7. RENDEZVOUS HOST (8 bits)\n\n      8. bit count of data (16 bits)\n\n   The header format has been arranged so that no data item will cross a\n   word boundary on machines with 16, 32, and 36-bit words, except where\n   the size of the item is greater than the word size.  The actual\n   arrangement of bytes within words is shown in the following figures\n   for these three word sizes.  For the benefit of 36-bit Hosts, bytes 4\n   and 13 (numbering from 0) are unused.  The 2 and 3-byte items do not\n\n\n\nBressler, et al.            Experimentation                    [Page 10]\n\f\nRFC 333          MESSAGE SWITCHING PROTOCOL EXPERIMENT          May 1972\n\n\n   cross word boundaries except for the port ID's on the 16 bit\n   machines.  This attention to packing and unpacking ease was given\n   both for general convenience, and in particular because Hosts may\n   wish to examine the header at interrupt level to determine where the\n   rest of the message should go.\n\n   +-------------+-------------+\n0  |  HOST/IMP   | DESTINATION |\n   |   FLAGS     |             |\n   +-------------+-------------+\n1  |   LINK      | /////////// |\n   |             | /////////// |\n   +-------------+-------------+\n2  | /////////// |             |\n   | /////////// |             |\n   +-------------+             |\n3  |        TO PORT ID         |\n   |                           |\n   +-------------+-------------+\n4  |  MESSAGE    |             |\n   |   TYPE      |             |\n   +-------------+             |\n5  |        FROM PORT ID       |\n   |                           |\n   +-------------+-------------+\n6  |  TABLE      | /////////// |\n   |  POSITION   | /////////// |\n   +-------------+-------------+\n7  |  SOURCE     | RENDEZVOUS  |\n   |   HOST      |   HOST      |\n   +-------------+-------------+\n8  |        BIT COUNT          |\n   |                           |\n   +-------------+-------------+\n   |                           |\n9  |           DATA            |\n   //                         //\n   |                           |\n   +-------------+-------------+\n\n         16-bit Host Format\n\n   +-------------+\n   |             |            ////////// = unused\n   |             |            //////////\n   +-------------+\n       8 bits\n\n\n\n\nBressler, et al.            Experimentation                    [Page 11]\n\f\nRFC 333          MESSAGE SWITCHING PROTOCOL EXPERIMENT          May 1972\n\n\n   0             8            16            24            32     36\n   +-------------+-------------+-------------+-------------+------+\n0  | HOST/IMP    |   FOREIGN   |    LINK     | ////////////////// |\n   |  FLAGS      |   HOST      |             | ////////////////// |\n   +------+------+-------------+-------------+-------+-----+------+\n1  | //// |        TO PORT ID                        |  MESSAGE   |\n   | //// |                                          |   TYPE     |\n   +------+------+-------------+-------------+-------------+------+\n2  |               FROM PORT ID              |   TABLE     | //// |\n   |                                         |   POSITION  | //// |\n   +------+-------------+-------------+------+-------------+------+\n3  | //// |   SOURCE    | RENDEZVOUS  |          BIT COUNT        |\n   | //// |    HOST     |  HOST       |                           |\n   +------+-------------+-------------+---------------------------+\n   |                                                              |\n4  |                                                              |\n   //                          DATA                              //\n   |                                                              |\n   |                                                              |\n   +-------------+-------------+-------------+-------------+------+\n\n                         36-bit Host Format\n\n\n   +-------------+-------------+-------------+-------------+\n0  | HOST/IMP    |   FOREIGN   |    LINK     | /////////// |\n   |  FLAGS      |   HOST      |             | /////////// |\n   +-------------+-------------+-------------+-------------+\n1  | /////////// |             TO PORT ID                  |\n   |             |                                         |\n   +-------------+-------------+-------------+-------------+\n2  |  MESSAGE    |             FROM PORT ID                |\n   |   TYPE      |                                         |\n   +-------------+-------------+-------------+-------------+\n3  |  TABLE      | /////////// |  SOURCE     | RENDEZVOUS  |\n   |  POSITION   | /////////// |   HOST      |   HOST      |\n   +-------------+-------------+-------------+-------------+\n   |        BIT COUNT          |                           |\n   |                           |                           |\n   +-------------+-------------+                           |\n   |                                                       |\n   //                   DATA                              //\n   |                                                       |\n   +-------------+-------------+-------------+-------------+\n\n                         32-bit Host Format\n\n\n\n\n\nBressler, et al.            Experimentation                    [Page 12]\n\f\nRFC 333          MESSAGE SWITCHING PROTOCOL EXPERIMENT          May 1972\n\n\n   The fields within the Host/IMP leader are already familiar to NCP\n   programmers however, two points about these fields are worth\n   mentioning.  First, the destination field originally contains the\n   number of the rendezvous Host.  After rendezvous at a intermediate\n   site, the destination field contains the source of the message\n   rendezvous with.  Second, the link field for the MSP experiment can\n   only contain link number 192-195.  We have not taken the time to\n   figure out a sensible allocation of these four links among all the\n   messages which might be sent using the MSP.  One alternative is to\n   cycle over the links to increase the bandwidth of the \"pipe\" between\n   any two Hosts. For the time being, until further consideration is\n   given to this issue, we suggest each Host at a site using one\n   (unique) link for all its communication.\n\n   The message types we have to represent in the message type field are\n   few now: we suggest message type 2 for SEND or OUT messages and\n   message 3 for RECEIVE or IN messages.  Message type 4 is the FLUSH\n   message, if FLUSH is used.\n\n   The rendezvous Host field needs no comment.  Except that the field is\n   unnecessary after the rendezvous has taken place and could then be\n   used for something else.\n\n   The bit count is a count of data bits in an OUT message or the size\n   of the input buffer (not including the header) in an IN message.\n   Thus the sender process can tell from the IN message bit count when\n   it receives the IN message how much of the data in the OUT message\n   was accepted by the receiver process and can use this knowledge to\n   retransmit the remainder of the message if so desired.  After the\n   rendezvous, we recommend that all of the data in the message be sent\n   on the source of the IN message even if the OUT bit count was greater\n   than the IN bit count.  Thus, at the receiver Host the monitor has\n   the option (if it wants to take it) of discarding the message for\n   being too long, sending the number of bits the receiver process has\n   done an IN for into the receiver process and discarding the rest, or\n   queuing the rest of the bits and somehow notify the receiver process\n   that there are more bits which the receiver process can ask for.\n\n   The to- and from-port-id fields are 24-bit numbers.  This size was\n   chosen to help the TIPs.  The first eight bits of a port Id should be\n   the number of the Host at which this port id was created.  Note well,\n   that this is not necessarily the Host at which the port is being\n   used.  This is necessary since rendezvous take place at intermediate\n   sites and because ports may move from site to site.  We suggest that\n   all port ids with the first eight bits all zero be reserved for\n   network-wide use.  In particular, a port id with all 24 bits zero\n   will be used to mean \"ANY\".  This gives us the options of:\n\n\n\n\nBressler, et al.            Experimentation                    [Page 13]\n\f\nRFC 333          MESSAGE SWITCHING PROTOCOL EXPERIMENT          May 1972\n\n\n            RECEIVE from ANY to SPECIFIC\n\n            RECEIVE from SPECIFIC to SPECIFIC\n\n            SEND from SPECIFIC to ANY\n\n       and  SEND from SPECIFIC to SPECIFIC\n\n   Examples of the use of these options will be given below.\n\n   The other options (RECEIVE to ANY) and (SEND from ANY) we feel are\n   kind of useless but would not prohibit them.  We believe that in the\n   absence of explicit specification of rendezvous Host, the use of an\n   ANY port id in the user's system call should affect the default\n   rendezvous site as follows:\n\n      RECEIVE from ANY--rendezvous in receiver\n\n      RECEIVE from SPECIFIC--rendezvous in sender\n\n      SEND to ANY--rendezvous in sender\n\n      SEND to SPECIFIC--rendezvous in sender\n\n   The less significant 16 bits of the id can be used however a Host\n   wants to.  For instance, eight bits might be used as a process id and\n   eight bits might be used as a channel specification within the\n   specified process.  We suggest that each Host reserve the port ids\n   with the middle eight bits all zero for special uses as well known\n   ports.\n\n   The table position field is included to help prevent costly table\n   searches at interrupt level.  Hosts sending INs and OUTs, put in the\n   table position field the rendezvous table position of the SEND or\n   RECEIVE associated with the IN or OUT.  At an intermediate Host\n   rendezvous, the table position fields in the matching IN and OUT are\n   swapped so that when the messages arrive at the opposite end, the\n   matching SEND and RECEIVE can be found quickly.  The MSP must do the\n   swap at the rendezvous, but of course the MSPs need not fill in the\n   table position field when first transmitting an IN or OUT in which\n   case the information arriving in an IN or OUT will be meaningless.\n   The general algorithm, then, is to check the table position as\n   specified in this field and if that fails, search the whole table.\n\n   The source field is filled in INs and OUTs by the MSP which\n   originally sends these messages.  At the rendezvous the source of\n   each message is preserved in the message being forwarded to the final\n   Host.  When an IN or OUT arrives at a process, the process can use\n\n\n\nBressler, et al.            Experimentation                    [Page 14]\n\f\nRFC 333          MESSAGE SWITCHING PROTOCOL EXPERIMENT          May 1972\n\n\n   the source information to update its understanding of the rendezvous\n   Host (e.g., when the destination Host and rendezvous Host are\n   different).\n\n\nEXAMPLES\n\nThe typical example.\n\n   We envision communication normally taking place using specifications\n   to and from ports and rendezvous at the sender.  For instance, the\n   TIP would probably send to other Hosts using this method and would\n   certainly receive from other Host until the TIP asks for it.  In this\n   \"normal\" method a monitor could even look at the bit count in the\n   arriving IN-message, use that as an allocation and then simulate an\n   OUT-message of the exact correct length.\n\nThe logging example\n\n   Consider an example of SEND to SPECIFIC and RECEIVE from ANY with the\n   rendezvous at the receiver.  This method might be used by some\n   logging receiver process with a well-known to-port.  For instance, a\n   measurements program to which statistics are sent from many processes\n   throughout the net.\n\nThe program library example\n\n   Suppose within a given time-sharing system there is a particular\n   library routine which is available for use by any process in the\n   network.  The library process has a RECEIVE from ANY always pending\n   at a well-known port.  Eventually, some process sends a message to\n   the library process' well-known-port.  This message includes the data\n   to be processed, a port to use for sending the answer, and the money.\n   The library process takes some of the money and sends it to the\n   well-known port of the accounting process which itself has a RECEIVE\n   from ANY pending.  The library process then processes the data and\n   sends the answer back to the process which requested the service\n   using a SEND to SPECIFIC message which rendezvous at the destination\n   where there is already a RECEIVE from SPECIFIC pending.  Of course,\n   in this message besides the answer, any change the requesting process\n   has coming is returned.\n\nA comment\n\n   As can be seen from our examples, we think rendezvousing at an\n   intermediate Host will seldom be done as the chief benefit of this\n   comes when it is desirable to move a port (see reference 4 for a\n   discussion of this).  We would like to see all Hosts provide some\n\n\n\nBressler, et al.            Experimentation                    [Page 15]\n\f\nRFC 333          MESSAGE SWITCHING PROTOCOL EXPERIMENT          May 1972\n\n\n   (meager) amount of buffering for this purpose but would not require\n   it.  It shouldn't be too painful to provide a little of this kind of\n   buffering-especially since a Host can throw away any message it can't\n   handle.\n\n   (THIS PAGE WILL BE REPLACED WITH A BETTER DESCRIPTION OF TELNET UNDER\n   MSP IN A FEW DAYS--DCW)\n\nTELNET\n\n   Let us postulate a pair of Telnet programs that maintain two\n   bidirectional communication paths, one for data and one for control.\n   Let us also assume, for convenience that the port IDs are as follows:\n\n      If the WRITE-CONTROL-ID is N, then --\n\n         READ-CONTROL-ID=N+1,\n\n         WRITE-DATA=N+2,\n\n         READ-DATA=N+3.\n\n   The initial state is the server Telnet sitting with a READ-FROM-ANY\n   pending.\n\n   The user Telnet now issues a SEND-TO-SPECIFIC with the data field\n   containing the PORT-ID of the SERVER's WRITE-CONTROL-ID. This message\n   is sent from the user-Telnet's WRITE-CONTROL-ID.\n\n   Thus all port IDs are specified by the user Telnet, so, if desired,\n   he need only remember one number and derive the rest.  Uniqueness is\n   preserved since the port IDs supplied by the user Telnet contain his\n   Host ID and other information making the ID unique to him.\n\n   Now that these communication paths are established, the two processes\n   can exchange data and control information according to established\n   Telnet protocols.\n\nTHE INFORMATION OPERATOR\n\n   The Message Switching Protocol itself impose no fixed requirements on\n   the use of the port ID's, and the problem of process identification\n   is somewhat separated from the means used to effect communication.\n   It is, however, very much a part of the overall issue of interprocess\n   communication, and so we here specify a facility for handling process\n   identification, the information operator.\n\n\n\n\n\nBressler, et al.            Experimentation                    [Page 16]\n\f\nRFC 333          MESSAGE SWITCHING PROTOCOL EXPERIMENT          May 1972\n\n\n   One goal in a process identification scheme is to provide a means by\n   which processes can select their own identifiers which can be\n   guaranteed unique and can contain information meaningful to the user.\n   Problems of efficiency prevent making the port ID's themselves large\n   enough to accomplish this aim.  Efficiency questions aside, it would\n   appear to be ideal to allow processes to use character strings of\n   arbitrary length to identify themselves.  Uniqueness can then be\n   easily ensured if, for example, users follow the convention of\n   including their names in the process identification string.  Further,\n   the remainder of the name can be chosen to have some meaning related\n   to its use with obvious advantages and convenience for users.\n\n   One solution is to establish a convention whereby the symbolic\n   identifiers are used only during some initial phase of communication\n   and not in every message.  That is, processes identify each other\n   initially using symbolic identifiers, but exchange local port\n   identifiers at the same time which are used for all ensuing messages.\n\n   The means of providing this facility is to establish a process at\n   each of a number of Hosts (e.g., all server Hosts) called the\n   \"information operator\".  The function of this process is to associate\n   symbolic identification strings and port ID's.  A process can\n   identify itself and/or a foreign process to the information operator,\n   and may request the port ID of the foreign process.  The symbolic\n   identification strings are chosen by the processes and are long\n   enough to contain meaningful information, e.g., LOGGER, MURPHY-\n   TESTPROG.\n\n   Communication with the information operator, whether by local or\n   remote processes, is via the regular MSP functions.  The information\n   operator will always have a RECEIVE ANY outstanding on a well-known\n   port.  This could in general be the only well-known port in\n   existence.  A message received on this port contains the following\n   parameters:\n\n      1. String identifying the foreign process with which communication\n         is desired.\n\n      2. String identifying the calling process.\n\n      3. Calling process' port number.\n\n      4. A delay specification.\n\n\n\n\n\n\n\n\nBressler, et al.            Experimentation                    [Page 17]\n\f\nRFC 333          MESSAGE SWITCHING PROTOCOL EXPERIMENT          May 1972\n\n\n   The format of these parameters is shown in Fig. 4.  In some cases,\n   one or more of the arguments would be null.  Following receipt of a\n   message, the information operator will, in some cases, do a SEND\n   SPECIFIC to the calling process' port number providing the desired\n   information or notice of failure.\n\n   The following two cases would appear to cover all functions of the\n   information operator.  They correspond to the SEND/RECEIVE SPECIFIC\n   ANY cases of the MSP.\n\n   1. Two processes each knowing the specific identify of the other wish\n      to communicate.  Each does a SEND SPECIFIC to the information\n      operator, giving parameters 1-2, the default delay spec in this\n      case being WAIT.  When the information operator receives the\n      second of these and notes that a match exists, it sends to each\n      process the port ID of the other process and deletes both strings\n      and both port ID's from its tables.  The two processes, which have\n      each done a RECEIVE SPECIFIC in anticipation of the foreign port\n      number, can then communicate using just the port numbers and basic\n      MSP functions.\n\n   2. A process is set up to provide some sort of general service or\n      information, and its name and protocol advertised.  This process\n      intends to maintain an outstanding SEND or RECEIVE ANY for the\n      first (and perhaps only) message transaction, e.g., the library\n      process discussed earlier.  Most such processes would be receivers\n      initially, but there might be a few cases where a SEND could be\n      left outstanding, and a forcing process could come along and pick\n      up the information.  In either case, the service process will do\n      SEND SPECIFIC to the information operator giving the local\n      symbolic ID and local port ID.  The foreign symbolic ID would be\n      null, and the default delay spec is NO-WAIT.  That is,\n\n         INFO ( -, local ID, local port)\n\n      The information operator will enter this information in its tables\n      but return nothing to the caller.  The caller would proceed to do\n      its SEND/RECEIVE ANY to wait for business.  When another process\n      wishes to use the advertised service, it asks the logger for the\n      port ID of the service process, i.e.,\n\n         INFO (service ID, -, local port)\n\n      The local symbolic ID need not be specified, and the default delay\n      spec is NO-WAIT.  The information operator would SEND the port ID\n      of the service process to the local port of the caller, and retain\n      the table entry for future callers.  Only the service process\n\n\n\n\nBressler, et al.            Experimentation                    [Page 18]\n\f\nRFC 333          MESSAGE SWITCHING PROTOCOL EXPERIMENT          May 1972\n\n\n      could request the entry be deleted.  If the service ID was unknown\n      to the information operator at the time of this call, it would\n      immediately return a failure indication, i.e., zero.\n\n   Communicating processes would normally use the information operator\n   local to one or the other, and like the rendezvous Host in the MSP,\n   this would be agreed upon in advance.  Service processes would\n   normally use the information operator at their local site, and\n   correspondingly, user processes would call the information operator\n   at the site where the service process was expected to be available.\n   There is no restriction on using an information operator at some\n   other site of course, and some small and/or lazy servers could use a\n   different Host for their service process ID's.  It presents no\n   problem for two or more information operators to have entries for the\n   same service process, and in fact, this may be very desirable for\n   special types of service processes which exist only one place on the\n   net and may move around from time to time.\n\n   Processes would specify their own local port numbers, and each system\n   would have to provide some way to help user processes do this.  In\n   TENEX for example, one would probably use the job number concatenated\n   with another number assigned within the job.  The information\n   operator cannot supply port numbers because it will be running on a\n   different Host than one or both of the communicants and cannot know\n   what is a unique number for that Host.  In some cases, processes\n   would ask the \"unique number process\" (described below) for their\n   local port ID, and would make it known via the information operator.\n\n   In actual practice, a few exceptions would be made to the rule that\n   the only \"well-known\" port in the world is the information operator.\n   Such exceptions would be processes common to many Hosts, e.g.,\n   LOGGER, or those in particularly frequent use.  In such cases the\n   unique port numbers would be assigned by administrative fiat and\n   recorded and published to all users.\n\n   The symbolic identification strings are specified to be from 1 to 39\n   (an arbitrary maximum) ASCII characters terminated by a null (byte of\n   all zeroes).  The characters will be 7-bit ASCII in 8-bit bytes with\n   the high order bit set to zero.  A null string (first byte is null)\n   is used where no argument is required.\n\n\n\n\n\n\n\n\n\n\n\nBressler, et al.            Experimentation                    [Page 19]\n\f\nRFC 333          MESSAGE SWITCHING PROTOCOL EXPERIMENT          May 1972\n\n\nFormat of Information Operator Messages\n\nTo Information Operator: A stream of 8-bit bytes.\n\n+------+--//---+------+------+--//---+------+------+-------+-------+\n|char 0| 1// n | null |char 0| 1// n | null | port | number| delay |\n|      |  //   |      |      |  //   |      |      |       |spec   |\n+------+--//---+------+------+--//---+------+------+-------+-------+\n \\                   /\\                     /\\             /\\      /\n  \\_________________/  \\___________________/  \\___________/  \\____/\n      PARAMETER 1         PARAMETER 2           PARAMETER 3  PARAMETER\n                                                             4\n   Parameters given:\n\n      1. String identifying the foreign process with which communication\n         is desired. (1 to 39 characters, or null)\n\n      2. String identifying the calling process. (1 to 39 characters, or\n         null)\n\n      3. Calling process' port number.\n\n      4. Delay specification:\n\n            0=default\n            1=wait for match\n            2=don't wait for match\n\nFrom Information Operator: 3 8-bit bytes.\n\n   +--------|-------|-------+\n   | byte 0 |   1   |   2   |\n   +--------|-------|-------+\n\n   Port number (24 bits) of requested foreign port if successful, 0 if\n   unsuccessful.\n\nUNIQUE PORT NUMBERS\n\n   The existence of unique port numbers is essential to the operation of\n   the MSP.  For instance, when two communicating processes specify\n   message rendezvous at an intermediate site, the processes must be\n   able to specify to- and from-ports which are not being used by other\n   processes which have specified message rendezvous at the same site or\n   else messages may be delivered to incorrect destinations.  We have\n   alluded to a method of providing unique port numbers earlier in this\n   note.  This method is to partition the 24-bit port number space into\n   disjointed segments and give one segment to each Host in the network\n\n\n\nBressler, et al.            Experimentation                    [Page 20]\n\f\nRFC 333          MESSAGE SWITCHING PROTOCOL EXPERIMENT          May 1972\n\n\n   to distribute when it is called upon to \"create\" a unique port id.\n   Thus each 24-bit Host number will consist of two major parts.  The\n   first 8 bits will be the number of the Host \"creating\" the port id\n   and the next 16 bits can be used in any manner the creating Host\n   desires.  This gives each Host 2^16 port numbers to distribute, and\n   each Host will have the burden of distributing its segment of the\n   port number space in a unique manner.  We recommend the convention\n   that the port numbers with the middle 8 bits equal to zero be\n   reserved for well-known ports in the creating Host's system.  We\n   already recommend in an earlier section that port numbers with the\n   first 8 bits equal to zero be reserved for network-wide use and in\n   particular the port number with all 24 bits equal to zero be used to\n   mean ANY.\n\n   Since each Host only has 2-16- port numbers to distribute, in general\n   port numbers will not be able to be held and used by processes for\n   long periods of time (e.g., weeks and months).  More typically, Hosts\n   will probably  implicitly \"take back' all port numbers the Host has\n   distributed each time the Host's system goes down and will\n   redistribute the port numbers as required when the system comes back\n   up.  In other words, port numbers will not in general remain unique\n   over the going down of the creating Hosts.  Of course, a given Host\n   may see to give the same port numbers to a number of standard\n   processes (such as the FORTRAN compiler) each time it comes up port\n   numbers registered with an information operator will frequently\n   remain constant over system ups and downs.\n\n   In spite of the fact that each Host will probably not in general be\n   able to distribute port numbers to arbitrary user processes which ca\n   be guaranteed to remain unique over a long period of time, there will\n   still be demand for provision of long-term unique port numbers.  To\n   some, the procedure of going through the information operator smacks\n   much too much of making a connection.  These people will insist that\n   for a variety of reasons their processes be allowed to communicate\n   via ports whose identifiers remain constant for long periods of time.\n   Therefore, it would be nice if at one or two places in the network, a\n   long-term unique number service was provided.  We'll call a process\n   providing this service the Unique Number Process.  The Unique Number\n   Process would have assigned to it one segment of the unique port\n   number space-all those port numbers, for instance, with the first 8-\n   bits equal to 377-8.  This process would have a SEND-to-ANY pending\n   from a well-known port with local rendezvous specified.  When any\n   process wanted a unique number which it could depend on not to be\n   used for all time or until the number is given back, it would send a\n   RECEIVE-from-SPECIFIC specifying the well-known port of the Unique\n   Number Process and rendezvous at the Unique Number Process' Host.\n   The Unique Number Process' pending SEND-to-ANY would contain a unique\n   number.  Also, the Unique Number Process would have a RECEIVE-from-\n\n\n\nBressler, et al.            Experimentation                    [Page 21]\n\f\nRFC 333          MESSAGE SWITCHING PROTOCOL EXPERIMENT          May 1972\n\n\n   ANY always pending at another well-known port with local rendezvous\n   specified.  At this port the Unique Number Process would receive\n   unique numbers which processes are giving back.  The Unique Number\n   Process would maintain a bit table 2-16- bits long indicating the\n   state of each of its unique numbers (free or in use) in some long-\n   term storage medium such as in the file system.  The Unique Number\n   Process might also maintain some information about each process to\n   which it gives a unique number so that when the supply of unique\n   number gets depleted, processes can be asked to return them.\n\n   It has already been mentioned that some of the process ID's\n   registered along with their symbolic names at the information\n   operator might be long-term unique numbers gotten from the Unique\n   Number Process.  It should also be mentioned that there would seem to\n   be no reason, other than scarcity of storage space, that in addition\n   to the port number through which primary access is gained to a\n   process and which was called the process ID in the previous section,\n   arbitrary port numbers along with their symbolic identified could not\n   be registered with an information operator.  For instance, rather\n   than registering the name BBN-FORTRAN and a single port number, one\n   could perhaps register the port numbers whose symbolic identifiers\n   were BBN-FORTRAN-CONTROL-TELETYPE, BBN-FORTRAN-INPUT-FILE, BBN-\n   FORTRAN-LISTING-FILE, and BBN-FORTRAN-BINARY-OUTPUT-FILE.  This is\n   perhaps at odds with standard practice within operating systems, but\n   is consistent with the philosophy of reference 4 that communication\n   is done with ports and not processes.\n\n   Let us now address an issue which has been ignored up to now and\n   which was only alluded to in reference 4, the issue of port\n   protection.  We have not given this matter a great deal of thought;\n   however, one mechanism for port protection seems quite\n   straightforward.  The heart of this mechanism is a process at each\n   Host which we shall call (alliteratively) the Port Protection Process\n   (PPP).  The PPP maintains a list of all processes which exist at the\n   Host and for each process the numbers of all ports which the process\n   has \"legally\" obtained.  Every time a process does a SEND or RECEIVE,\n   the monitor checks with the PPP to see if the process has specified\n   port numbers it has the right to use; i.e., those legally obtained.\n   The PPP has some RECEIVEs always pending at well-known ports.  When\n   one process wants to pass a port to some other process, the first\n   process sends a message to the PPP specifying the number of the port\n   to be sent, the Host number at which the second process resides, a\n   port at which the second process is expecting to receive the port,\n   etc.  The PPP looks up in its tables whether the first process has\n   the port it wants to send.  If it does, it sends a message to the PPP\n   at the destination site.  The message contains the number of the port\n   to be transferred and the RECEIVE port for the destination process.\n   The destination PPP checks in its table whether the process has the\n\n\n\nBressler, et al.            Experimentation                    [Page 22]\n\f\nRFC 333          MESSAGE SWITCHING PROTOCOL EXPERIMENT          May 1972\n\n\n   RECEIVE port, and if so, passes the new port to the process and\n   updates its tables to indicate the process now possesses the new\n   port.  The messages to a PPP will optionally be able to specify that\n   a copy of a port be sent, a port be deleted, etc.  The PPPs would\n   probably have some built-in legal ports for each process,\n   particularly the port's processes used to communicate with the PPP.\n   The exact specification requires development but that should not be\n   hard (see (3),(6), and (7) in reference 4).  The main difficulty we\n   see is efficient checking of the PPP's tables by the monitor for\n   every RECEIVE or SEND without entirely supplanting the monitor's\n   current protection system.\n\nFLOW CHART\n\n   The following section describes a flow chart for most of the MSP.  A\n   distinction is made between calls made by local processes called SEND\n   and RECEIVE, and messages coming in over the NET called IN and OUT.\n   An additional distinction is made between calls (or messages) with a\n   local rendezvous and those with a foreign rendezvous Host.\n\n   Since the code is quite similar, the distinction need not be made,\n   but will be included for the sake of clarity.\n\n   It is assumed that the MSP has table provisions for the following\n   items:\n\n      source of message\n      rendezvous Host\n      FROM-PORT-ID\n      TO-PORT-ID\n      table position\n      type of message\n      data size and location\n      data about the user process\n\n   User does a SEND or RECEIVE\n\n   A. Rendezvous is at a foreign host\n\n      1. Store the appropriate table data\n\n      2. Send a message to the rendezvous host\n\n         a. SEND: OUT + DATA\n\n         b. RECEIVE: IN\n\n   B. Rendezvous is local - look for entry in table\n\n\n\nBressler, et al.            Experimentation                    [Page 23]\n\f\nRFC 333          MESSAGE SWITCHING PROTOCOL EXPERIMENT          May 1972\n\n\n      1. Entry NOT found: create entry with appropriate data\n\n      2. A matching entry exists in table:\n\n         a. RECEIVE: give user the data\n\n         b. Send a message to the other host (as specified by the source\n            field of the original msg)\n\n            1)SEND: OUT+DATA\n            2)RECEIVE: IN\n\n         c. Alert user to the fact that transaction is complete\n\n         d. Clear table entry\n\n   An IN is received over the NET-search table for matching entry.\n\n   A. No matching entry create an entry with appropriate data.\n\n   B. A match exists\n\n      1. Entry was cause by a local SEND\n\n         a. Send \"OUT _ DATA\" to source of IN\n\n         b. Inform user of transaction\n\n         c. Clear table entry\n\n      2. Entry was caused by an OUT received over net-acting as third\n         host.\n\n         a. Send IN to site that created table entry\n\n         b. Send OUT + DATA (previously buffered) to site sending the IN\n\n         c. Clear table entry\n\n   An OUT + DATA is received over the NET -search table for matching\n   entry\n\n   A. No match is found\n\n      1. buffer data\n\n      2. create appropriate table information\n\n\n\n\nBressler, et al.            Experimentation                    [Page 24]\n\f\nRFC 333          MESSAGE SWITCHING PROTOCOL EXPERIMENT          May 1972\n\n\n   B. A match is found\n\n      1. Table entry was caused by locally executed RECEIVE\n\n         a. give data to the user and alert him to its existence.\n\n         b. send a matching \"IN\" to the source of the \"OUT\"\n\n         c. remove entry from table\n\n      2. Table entry was caused by the receipt of an \"IN\" over the NET,\n         thus we are acting as a third party host\n\n         a. send the \"OUT + DATA\" to the host stored in the table\n\n         b. send an \"IN\" to the host from which the \"OUT\" had just\n         arrived.\n\nMSP VARIATIONS\n\n   It may of interest to the reader to know of some of the other MSPs we\n   have considered while arriving at the present one.\n\n   The simplest we considered is an MSP based on all rendezvous being\n   done at the destination Host.  The sender process sends an OUT-\n   message plus the data to the destination Host.  The receiver process\n   does an IN which stays at the receivers Host.  The OUT and RECEIVE\n   rendezvous and the data is passed to the receiver process.  The\n   transmission is now complete, except in some variations of this MSP\n   an acknowledgement is sent to the sender process.  This MSP has\n   couple of disadvantages: In the simplest formulation, the RECEIVE had\n   to be waiting when the OUT+data arrived, otherwise the out data were\n   thrown away.  This puts too tight a constraint on the timing of the\n   SEND and RECEIVE, especially since the sender and receiver processes\n   can be a continent apart.  However, if the IN is allowed to arrive\n   first and must be held until matched by a RECEIVE, the monitor must\n   buffer an indeterminate amount of data in all cases including the\n   normal one.  Further, basing everything on rendezvous at the\n   destination makes the process of moving a port difficult.\n\n   The next simplest MSP we considered was the IPC of reference 4.  This\n   works just the opposite of the above described MSP in that it is\n   based on almost all rendezvous being done at the source Host with two\n   special messages to handle the relatively uncommon cases when a\n   rendezvous must be done at the destination or an intermediate Host.\n   This system, its advantages, and disadvantages is discussed at very\n   great length in the reference.\n\n\n\n\nBressler, et al.            Experimentation                    [Page 25]\n\f\nRFC 333          MESSAGE SWITCHING PROTOCOL EXPERIMENT          May 1972\n\n\n   A third variation on the MSP, suggested by Crowther, is the same as\n   the present MSP in that the OUT and IN rendezvous at a process\n   specified rendezvous Host and the OUT is sent to the source of the IN\n   and the IN to the source of the OUT, but the data is not sent along\n   with the OUT.  Instead, when the OUT finally reaches the source of\n   the IN, another message is sent from the receiver Host to the source\n   Host requesting the data to be sent.  The data finally is transmitted\n   to the destination in response to this data request message.  Our\n   main objection to this system is its lack of symmetry, but we do\n   recognize that it does not require any Host to buffer data for which\n   a process has not set up an input buffer and perhaps for that reason\n   it is a better system than the MSP we are presenting.\n\n   In the last MSP variation we considered, the difference between SEND\n   or RECEIVE and OUT or IN was discarded.  In this case only one\n   message is used which we will call TRANSFER.  When a process executes\n   a TRANSFER it can specify an input buffer, an output buffer, both, or\n   neither.  Two processes wishing to communicate both execute TRANSFERs\n   specifying the same to and from port ids and the same rendezvous\n   Host.  The TRANSFERs result in TRANSFER-messages plus data in the\n   case that an output buffer was specified which rendezvous at the\n   rendezvous Host.  When the rendezvous occurs, the TRANSFER-messages\n   plus their data cross and each is sent to the source of the other.\n   The system allows processes not to know whether they must do a SEND,\n   or RECEIVE and is (perhaps) a nice generalization of the MSP\n   presented in this note.  For instance, two processes can exchange\n   data using this system, or two processes can kind of interrupt each\n   other by sending dataless TRANSFERs.  This variation of the MSP is a\n   development of a suggestion of Steve Crocker.  Its disadvantages are:\n   (1) unintentional matches are more likely to occur, (2) rendezvous\n   selection site is more complex, and (3) it's hard to think about.\n\nAPPENDIX\n\n   A system for Interprocess Communication in a Resource Sharing\n   Computer Network.  Communications of the ACM, April, 1972.\n   Permission to reprint this paper was granted by permission of the\n   Association for Computing Machinery. [Omitted in republished version\n   of RFC 333.]\n\n   N.B. The ideas of section 4 of the following paper are in no way\n   critical to the ideas developed in section 3--DCW.\n\n\n         [ This RFC was put into machine readable form for entry ]\n            [ into the online RFC archives by Via Genie 3/00  ]\n\n\n\n\n\nBressler, et al.            Experimentation                    [Page 26]\n\f\n"
}