{
  "series": "Request for Comments",
  "number": "191",
  "howpublished": "RFC 191",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0191",
  "url": "https://www.rfc-editor.org/info/rfc191",
  "title": "Graphics implementation and conceptualization at Augmentation Research Center",
  "pagetotal": "4",
  "year": "1971",
  "month": "jul",
  "body": "\n\n\n\n\n\nRFC 191                                             Charles Irby\nNIC 7136                            Augmentation Research Center\nCategory D.6, I.1                    Stanford Research Institute\n                                                       13-JUL-71\n\n          GRAPHICS IMPLEMENTATION AND CONCEPTUALIZATION AT ARC\n\nOverview:\n\nThis document is a brief description of the way in which graphics\nterminals are conceptualized and used at the Augmentation\nResearch Center. All things described are implemented and have\nbeen operational for several months. Although our attention has\ninitially been centered about the display of textual material, we\nare now about to turn our attention toward pictorial displays\n(hopefully much enhanced over our previous 940 line drawing\ncapabilities).\n\n   This document will discuss only those facits of display use\n   which have been implemented and are currently operational,\n   namely only those dealing with textual display.\n\nincluded is a discussion of the use of multiple file viewing\ndisplay areas in NLS to provide cross file editing capabilities.\nA description of our display and terminal input equipment will\nbe issued as a separate document.\n\nNOTE: RFC 190 includes a functional description of the\nimplementation of the interface to our displays and is a\ndescription of the way this interface was extended to include\n\"Processor-displays\" (an IMLAC PDS-1, in this case) to our\nsystem, thus enabling one to use Display NLS over any of our\nteletype lines (including the network).\n\n   A \"processor dsplay\" is a display with Processing power which\n   can be controlled by character strings.\n\nDescription of the \"conceptual display\" implemented at ARC\n\nThe allocatable output unit for our display terminals (which\ninclude our local terminals and all remote processor-displays) is\n\n\n\n\n\n\n\n\n\n\n                                                                [Page 1]\n\f\na rectangular \"display area\". A program treats this display area\nmuch like it would a file which it has opened with write access.\n\nWhen requesting the allocation of a display area, a program\nspecifies its attributes, including where it is to be on the\nscreen. The program is returned an identifier which it\nsubsequently uses to manipulate images within the display area\nand the display area itself. Each string which the program\nwrites into the display area is also given an identifier, which\ncan subsequently be used to move, delete, replace, or change the\ncharacteristics of that string.\n\n   The currently implemented characteristics are character size,\n   horizontal spacing between characters, and font of the\n   characters (e.g. blinking, italics, intensity, etc.).\n\n   The position of items in the display area are given relative\n   to the 0,0, which is the lower left corner of the display\n   area.  The horizontal coordinate increases to the right and the\n   vertical coordinate increases toward the top.\n\nIn addition to above described manipulation of strings within\ndisplay areas a program can suppress the display of individual\nstrings within display areas or suppress whole display areas.\n\nAlso, a program can switch the terminal's state from teletype\nsimulation to display mode and vis versa.\n\n   When in display mode, the teletype simulation display area is\n   suppressed and the coordinates of the cursor are input with\n   each character. When in teletype simulation mode, all user\n   owned display areas are suppressed and the coordinates of the\n   cursor are not input with each character.\n\nAt TENEX startup time, display areas are allocated for a teletype\nsimulation and a cursor for each local display terminal. Programs\ncan change the string being displayed as the cursor to give the\nhuman feedback as to the programs state.\n\nWithin NLS:\n\n   The NLS subsystem deals only with the cursor and the display\n   areas it has requested from the system for output to the user.\n   The display area formatters assumes that the display has 64K\n   by 64K addressable points (with 0,0 at upper left), several\n   different character sizes and fonts, and 7-bit ASCII.\n\n\n\n\n\n                                                                [Page 2]\n\f\n   The display area formatters use format parameters during the\n   format process and post-processors to convert the vertual\n   format to one that is acceptable to the device for which the\n   formatting was being done (a display area on the screen, a\n   page for a printer, a microfilm device, or a teletype).\n\n   NLS allows the user to specify arguments to commands by\n   selecting items from the current display image. This is\n   accomplished through the use of a data structure, which\n   describes the current display image, to map the cursor\n   coordinates, which are input with each character, into the\n   proper selection.\n\nMultiple text display areas in NLS\n\nWhen the user's device is a display, NLS allows him to subdivide\nthe file-viewing display area (the one in which he views his\nfile) and view (and edit across) several different files at once.\nFollowing is a discussion of the commands and capabilities\nassociated with this new feature.\n\n  new commands\n\n    Horizontal split\n\n      splits a file-viewing display area horizontally (into an\n      upper and lower segment) at the selected location moving\n      the image of the original display area to the upper or\n      lower segment depending on whether the cursor is above or\n      below the bugged position when the final Command Accept is\n      input.\n\n         No display area will be created which is smaller then 2\n         lines by 20 columns (using the character size of the\n         original display area).\n\n    Vertical split\n\n      splits a file-viewing display area vertically (into a left\n      and right segment) at the selected location moving the\n      image of the original display area to the left or right\n      segment depending on whether the cursor is to the left or\n      right of the selected position when the final CA is input.\n\n         No display area will he created which is smaller then 2\n         lines by 20 columns (using the character size of the\n         original display area).\n\n\n\n                                                                [Page 3]\n\f\n    Move boundary\n\n      The selected boundary is moved to the new position. A\n      boundary will not be moved passed a boundary of a neighbor.\n      A boundary is moved for all display areas for which it is a\n      boundary. Any resulting display area which is smaller than\n      two lines by twenty columns will be deleted.\n\n    Character size\n\n      The current character size of the display area which\n      currently contains the cursor is displayed, and the user\n      may type a number (0, 1, 2, 3) for a new character size.\n      The final Command Accept causes the character size to be\n      changed. The horizontal and vertical increment are\n      automatically adjusted. Different display areas may\n      simultaneously have different character sizes.\n\n    Clear display area\n\n      The selected display area is cleared, i.e. the image is\n      erased, the return and file return rings are released, and\n      the association of a file with that display area is\n      removed. The display area itself is not deleted.\n\nOne may freely edit and jump using several display areas. The\nposition of the cursor is used to resolve ambiguities.\n\n   For example, If one executes a Jump command, the position of\n   the cursor when the final Command Accept is entered determines\n   in which display area the new image is to appear.\n\n   Also, If one changes viewspecs using the leftmost two buttons\n   of the mouse, the viewspecs of the display area containing the\n   cursor when the buttons go down are used as the initial values\n   and are displayed in the viewspec area. When the buttons are\n   released, the display area containing the cursor receives the\n   new viewspecs.\n\n\n       [ This RFC was put into machine readable form for entry ]\n       [ into the online RFC archives by BBN Corp. under the   ]\n       [ direction of Alex McKenzie.                   12/96   ]\n\n\n\n\n\n\n\n                                                                [Page 4]\n\f\n"
}