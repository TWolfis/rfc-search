{
  "series": "Request for Comments",
  "number": "46",
  "howpublished": "RFC 46",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0046",
  "url": "https://www.rfc-editor.org/info/rfc46",
  "title": "ARPA Network protocol notes",
  "pagetotal": "17",
  "year": "1970",
  "month": "apr",
  "day": "1",
  "body": "\n\n\n\n\n\nNetwork Working Group                                Edwin E. Meyer, Jr.\nRequest for Comments: 46           Massachusetts Institute of Technology\n                                                           17 April 1970\n\n\n                      ARPA Network Protocol Notes\n\n   The attached document contains comments and suggestions of the\n   Network Working Group at Project MAC.  It is based upon the protocol\n   outlined in NWG/RFC 33, 36, and later documents.\n\n   This proposal is intended as a contribution to the dialog leading to\n   a protocol specification to be accepted by the entire Network Working\n   Group.\n\n   We solicit your comments.\n\nI - INTRODUCTION\n\n   In this document the Network Working Group at MIT Project MAC suggest\n   modifications and extensions to the protocol specified by Carr,\n   Crocker, and Cerf in a preprint of their 1970 SJCC paper and extended\n   by Crocker in NWG/RFC 36.  This document broadly outlines our\n   proposal but does not attempt to be a complete specification.  It is\n   intended to be an indication of the type and extent of the protocol\n   we think should be initially implemented.\n\n   We agree with the basic concept of simplex communication between\n   sockets having unique identifiers.  We propose the implementation of\n   a slightly modified subset of the network commands specified in\n   NWG/RFC36 plus the ERR command as specified by Harslem and Heafner in\n   NWG/RFC 40.\n\n   Given the basic objective of getting all ARPA contractors onto the\n   network and talking to each other at the earliest possible date, we\n   think that it is important to implement an initial protocol that is\n   reasonably simple yet extendable while providing for the major\n   initial uses of the network.  It should be a simple protocol so as to\n   elicit the broadest possible support and to be easily implementable\n   at all installations with a minimum of added software.\n\n   While the protocol will evolve, the fundamentals of a protocol\n   accepted and implemented by all installations are likely to prove\n   very resistant to change.  Thus it is very important to make the\n   initial protocol open-ended and flexible.  A simple basic protocol is\n   more likely to succeed in this respect than a complicated one.  This\n\n\n\n\n\n                                                                [Page 1]\n\f\nRFC 46                ARPA Network Protocol Notes             April 1970\n\n\n   does not preclude the existence of additional layers of protocol\n   between several installations so long as the basic protocol remains\n   supported.\n\n   We feel that three facilities must be provided for in the initial\n   protocol:\n\n   1. Multi-path communication between two existing processes which know\n      how to connect to each other.\n\n   2. A standard way for a process to connect to the logger (logging\n      process at a HOST) at a foreign HOST and request the creation of a\n      user process.  (The login ritual may or may not be standardized.)\n\n   3. A standard way for a newly created process to initiate pseudo-\n      typewriter communication with the foreign process which requested\n      its creation.\n\n   The major differences between the protocol as proposed by Carr,\n   Crocker, and Cerf and this proposal are the following:\n\n   1. The dynamic reconnection strategy specified in Crocker's\n      NWG/RFC 36 is reserved for future implementation.  We feel that\n      its inclusion would unduly complicate the initial implementation\n      of the protocol.  We outline a strategy for foreign process\n      creation that does not require dynamic reconnection.  Nothing in\n      this proposal precludes the implementation of dynamic reconnection\n      at a later date.\n\n   2. We propose that an \"instance tag\" be added to the socket\n      identifier so as to separate sockets belonging to different\n      processes of the same user coexisting at one HOST.\n\n   3. The following NCP commands have been added:\n\n      a. The ERR command specified in NWG/RFC 40 is included.\n\n      b. BLK and RSM commands are presented as possible alternatives to\n         the \"cease on link\" IMP command and SPD and RSM commands set\n         forth in NWG/RFC 36.  Because these commands operate on socket\n         connections rather than link numbers, they do not impede the\n         implementation of socket connection multiplexing over a single\n         link number, should that later prove desirable.\n\n      c. An INT command that interrupts a process is specified.  We feel\n         that it is highly important to be able to interrupt a process\n         that may be engaged in unwanted computation or output.  To\n         implement the interrupt as a special format within a normal\n\n\n\n                                                                [Page 2]\n\f\nRFC 46                ARPA Network Protocol Notes             April 1970\n\n\n         message raises severe difficulties: the connection may be\n         blocked when the interrupt is needed, and the NCP must scan\n         each incoming message for an interrupt signal.\n\n      d. An ECO echoing command to test communications between NCPs is\n         included.\n\n   4. Sockets are conceptualized as having several states, and these are\n      related to conditions under which network requests may be queued.\n      This differs from the unlimited queuing feature, which presents\n      certain implementation difficulties.\n\n   5. The protocol regarding creation of a foreign process and\n      communication with it is removed to a separate User Control and\n      Communication (UCC) protocol level and is more fully specified.\n\nII - A HIERARCHY OF PROTOCOLS\n\n   It seems convenient and useful to view the network as consisting of a\n   hierarchy of protocol and implementation levels.  In addition to\n   aiding independent software and hardware development, provisions for\n   a layered protocol allow additions and substitution of certain levels\n   in experimental or special purpose systems.\n\n   We view the initial network communications system as a hierarchy of\n   three systems of increasing generality and decreasing privilege\n   level.  These are:\n\n   1. IMP Network - The network of IMPs and physical communication lines\n      is the basic resource which higher level systems convert into more\n      generalized communication facilities.  The IMP network acts as a\n      \"wholesaler\" of message transmission facilities to a highly\n      privileged module within each HOST.\n\n   2. Network Control Program - Each HOST contains a module called the\n      Network Control Program (NCP) which has sole control over\n      communications between its HOST and the IMP network.  It acts as a\n      \"retailer\" of the wholesale communications facilities provided by\n      the IMP network.  The network of NCPs can be viewed as a higher\n      level communications system surrounding the IMP network which\n      factors raw message transmission capabilities between HOSTs into\n      communication facilities between ordinary unprivileged processes.\n\n\n\n\n\n\n\n\n\n                                                                [Page 3]\n\f\nRFC 46                ARPA Network Protocol Notes             April 1970\n\n\n              H O S T  A                      H O S T  C\n    ______________________________       ______________________\n   |                              |     |                      |\n   |  ____   ____   ____   ____   |     |  ____   ____   ____  |\n   | |Proc| |Proc| |Proc| |    |  |     | |Proc| |Proc| |    | |\n   | | A  | | B  | | C  | |UCC |  |     | | D  | | E  | |UCC | |\n   | |____| |____| |____| |____|  |     | |____| |____| |____| |\n   |    |     |      |      |     |     |    |     |      |    |\n  - - - - - - |- - - |- - - |- - -|- - -|- - |- - -|- - - |- - - - - -\n   |    |     |      |      |   NCP NETWORK  |     |      |    |\n   |    |     |      |      |     |     |    |     |      |    |\n   |   _|_____|______|______|_    |     |   _|_____|______|_   |\n   |  |                       |   |     |  |                |  |\n   |  |      N C P   A        |   |     |  |   N C P   C    |  |\n   |  |_______________________|   |     |  |________________|  |\n   |                     ||       |     |       ||             |\n   |_____________________||_______|     |_______||_____________|\n                         ||                     ||\n  - - - - - - - - - - - -|| - - - - - - - - - - ||- - - - - - - - - -\n                         ||     IMP NETWORK     ||\n                      ___||___              ____||__\n                     |        |            |        |\n                     |  IMP   |------------|  IMP   |\n                     |   A    |            |   C    |\n                     |________|            |________|\n                         |                     |\n                         |       ________      |\n                         |      |        |     |\n                         +------|  IMP   |-----+\n                                |   B    |\n                                |________|\n\n                     FIG 1. Modular View Of Network\n\n\n   3. User Control and Communication Module - The preceding two\n      communication systems are sufficient to permit communication\n      between unprivileged processes that already exist.  However, one\n      of the primary initial uses of the network is thought to involve\n      the creation of a foreign user process through interaction with\n      the foreign HOST's logger.  The User Control and Communication\n      Module (UCC) implements protocol sufficient for a process to\n      communicate with a foreign HOST's logger and to make initial\n      control communication with a created process.  Such a process is\n      to have the same privileges (subject to administrative control) as\n      a local (to the foreign HOST) user process.  The UCC module\n      communicates through the NCP in a manner similar to an ordinary\n      process.  Except for the ability to close connections to a dead\n\n\n\n                                                                [Page 4]\n\f\nRFC 46                ARPA Network Protocol Notes             April 1970\n\n\n      process, the UCC module has no special network privileges.  The\n      UCC protocol is only one of several third-level protocols that\n      could be implemented.  For example, a set of batch processing\n      systems connected through the NCP system might implement a load-\n      sharing protocol, but not a UCC.\n\nIII - NETWORK CONTROL PROGRAM\n\n   Each HOST implements a module called the Network Control Program\n   (NCP) which controls all network communications involving that HOST.\n   The network of NCPs forms a distributed communication system that\n   implements communication paths between individual processes.  The NCP\n   protocol issues involve:  (i) the definition of these communication\n   paths, and (ii) a system for coordinating the distributed NCP system\n   in maintaining these communication paths.  These are discussed below.\n\n   Sockets\n\n   Communication between two processes is made through a simplex\n   connection between two sockets:  a send socket attached to one\n   process and a receive socket attached to another process.  Sockets\n   have the following characteristics:\n\n   Socket Identifier - A socket identifier is used throughout the\n   network to uniquely identify a socket.  It consists of 48 bits,\n   having the following components:\n\n      a. User Number (24 bits) - A socket attached to a process is\n         identified as belonging to that process by a user number\n         consisting of 8 bits of \"home\" HOST code plus 16 bits of user\n         code assigned by the home HOST.  This user number is the same\n         for all sockets attached to any of his processes in any HOST.\n\n      b. Instance Tag (8 bits) - More than one process belonging to a\n         user may simultaneously exist within a single HOST.  The\n         instance tag identifies the particular process to which a\n         socket belongs.  A user's first process at a HOST to use the\n         network receives instance tag = 0 by convention.\n\n      c. HOST Number (8 bits) - This is the code of the HOST on which\n         the attached process exists.\n\n      d. Socket Code (8 bits) - This code provides for 128 send and 128\n         receive sockets in each process.  The low order bit determines\n         whether this is a \"send\" (= 1) or \"receive\" (= 0) socket.\n\n\n\n\n\n\n                                                                [Page 5]\n\f\nRFC 46                ARPA Network Protocol Notes             April 1970\n\n\n   States of Sockets - Each socket has an associated state.  The NCP may\n   implement more transitory states of a socket, but the three following\n   are of conceptual importance.\n\n      a. Inactive - there is no currently existing process which has\n         told the NCP that it wishes to listen to this socket.  No other\n         process can successfully communicate with an inactive socket.\n\n      b. Open - Some process has agreed to listen to events concerning\n         this socket but it is not yet connected.\n\n      c. Connected - This socket is currently connected to another\n         socket.\n\n   Socket Event Queue - A queue of events to be disclosed to the owning\n   process is maintained for each open or connected socket.  It consists\n   of a chronologically ordered list of certain events generated by the\n   action of one or more foreign processes trying to connect or\n   disconnect this socket.  An entry in the event queue consists of the\n   event type plus the identifier of the foreign socket concerned.  The\n   following event types are defined:\n\n      a. \"request\" - a foreign socket requests connection.  (not queued\n         if local socket is already connected)\n\n      b. \"accept\" - a foreign socket accepts requested connection.\n\n      c. \"reject\" - a foreign socket rejects requested connection.\n\n      d. \"close\" - a foreign socket disconnects an existing connection.\n\n   A \"request\" event is removed from the queue when it is accepted or\n   rejected.  The other events are removed from the queue as they are\n   disclosed to the owning process.\n\n   Some events are intended to be transparent to the process owning the\n   socket, and they do not generate entries in the event queue.\n\n   Although an event queue is conceptually unlimited, it seems necessary\n   to place some practical limit on its length.  When an event queue for\n   a socket is full, any incoming event that would add to the queue\n   should be discarded and the sending NCP notified (via ERR command\n   described below).\n\n\n\n\n\n\n\n\n                                                                [Page 6]\n\f\nRFC 46                ARPA Network Protocol Notes             April 1970\n\n\nNCP Control Communications\n\n   The NCP network coordinates its activities through control commands\n   passed between its individual components.  These commands generally\n   concern the creation and manipulation of socket connections\n   controlled by the NCP receiving the command.  A control command is\n   directed to a particular NCP by being sent to its HOST as a message\n   over link number 1 (designated as the control link), which is\n   reserved for that purpose.  The IMP network does not distinguish\n   between these messages and regular data messages implementing\n   communication through a socket connection.\n\n      The following NCP control commands are defined:\n\n      a. Request for Connection\n\n         RFC \u003clocal socket\u003e \u003cforeign socket\u003e [\u003clink no.\u003e]\n\n      An NCP directs this command to a foreign NCP to attempt to\n      initiate a connection between a local socket and a foreign socket.\n      If the foreign socket is open, the foreign NCP places a \"request\"\n      event into the socket's event queue for disclosure to the process\n      that owns it.  If the foreign process accepts, the foreign NCP\n      returns a positive acknowledgement in the form of another RFC.  It\n      rejects connection by issuing the CLS command (see below).  An RFC\n      is automatically rejected without consulting the owning process if\n      the foreign socket is not open (inactive or connected).  Multiple\n      RFCs to the same socket are placed into its event queue in order\n      of receipt.  Any queued RFCs are automatically rejected by the NCP\n      once the owning process decides to accept a connection.  The NCP\n      which has control of the \"receive\" socket of the potentially\n      connected pair designates a link number over which messages are to\n      flow.\n\n      b. Close a Connection\n\n         CLS \u003clocal socket\u003e \u003cforeign socket\u003e\n\n      An NCP issues this network command to disconnect an existing\n      connection or to negatively acknowledge an RFC.  There is a\n      potential race problem if an NCP closes a local send socket in\n      that the CLS command may reach the foreign NCP prior to the last\n      message over that socket connection.  This race is prevented by\n      adhering to two standards: (i) A CLS command for a local send\n      socket is not transmitted until the RFNM for the last message to\n      the foreign socket comes back, and (ii) the foreign NCP processes\n      all incoming messages in the order received.\n\n\n\n\n                                                                [Page 7]\n\f\nRFC 46                ARPA Network Protocol Notes             April 1970\n\n\n      c. Block Output over a Connection\n\n         BLK \u003cforeign send socket\u003e\n\n      A process may read data through a receive socket slower than\n      messages are coming in and thus the NCP's buffers may tend to clog\n      up.  The NCP issues this command to a foreign NCP to block further\n      transmission over the socket pair until the receiving process\n      catches up.\n\n      d. Resume Output over a Blocked Connection\n\n         RSM \u003cforeign send socket\u003e\n\n      An NCP issues this command to unblock a previously blocked\n      connection.\n\n      e. Interrupt the Process Attached to a Connection\n\n         INT \u003cforeign socket\u003e\n\n      Receipt of this message causes the foreign NCP to immediately\n      interrupt the foreign process attached to \u003cforeign socket\u003e if it\n      is connected to a local socket.  Data already in transit within\n      the NCP network over the interrupted connection will be\n      transmitted to the destination socket.  The meaning of \"interrupt\"\n      is that the process will immediately break off its current\n      execution and execute some standard procedure.  That procedure is\n      not defined at this protocol level.\n\n      f. Report an Erroneous Command to a Foreign NCP\n\n         ERR \u003ccode\u003e \u003ccommand length\u003e \u003ccommand in error\u003e\n\n      This command is used to report spurious network commands or\n      messages, or overload conditions that prevent processing of the\n      command.  \u003ccode\u003e specifies the error type.  If \u003ccode\u003e specifies an\n      erroneous network command, \u003ccommand in error\u003e is that command (not\n      including IMP header) and \u003ccommand length\u003e is an integer\n      specifying its length in bits.  If \u003ccode\u003e specifies an erroneous\n      message, \u003ccommand in error\u003e contains only the link number over\n      which the erroneous message was transmitted.  (This is slightly\n      modified from the specification in NWG/RFC 40.)\n\n\n\n\n\n\n\n\n                                                                [Page 8]\n\f\nRFC 46                ARPA Network Protocol Notes             April 1970\n\n\n      g. Network Test Command\n\n         ECO \u003c48 bit code\u003e \u003cecho switch\u003e\n\n      An NCP may test the quality of communications between it and a\n      foreign NCP by directing to it an ECO command with an arbitrary\n      \u003c48 bit code\u003e (of the same length as a socket identifier) and\n      \u003cecho switch\u003e 'on'.  An NCP receiving such a ECO command should\n      immediately send an acknowledging ECO with the same \u003c48 bit code\u003e\n      and \u003cecho switch\u003e 'off' to the originating NCP.  An NCP does not\n      acknowledge an ECO with \u003cecho switch\u003e 'off'.  We feel that this\n      command will be of considerable aid in the initial shakedown of\n      the entire network.\n\n      h. No Operation Command\n\n         NOP\n\n      An NCP discards this command upon receipt.\n\nUser Interface to the NCP\n\n   The NCP at each HOST has an interface through which a local process\n   can exercise the network, subject to the control of the NCP.  The\n   exact specification of this interface is not a network protocol\n   issue, since each installation will have its own interface keyed to\n   its particular requirements.  The protocol requirements for the user\n   interface to an NCP are that it provide all intended network\n   functions and no illegal privileges.  Examples of such illegal\n   privileges include the ability to masquerade as another process,\n   eavesdrop on communications not intended for it, or to induce the NCP\n   to send out spurious network commands or messages.\n\n   We outline here an interface based on the Carr, Crocker, and Cerf\n   proposal that is sufficient to fully utilize the network.  While this\n   particular set of calls is intended mainly for illustrative purposes,\n   it indicates the types of functions necessary.\n\n      The following calls to the NCP are available:\n\n      a. LISTEN \u003cmy 8 bit socket code\u003e\n\n      A user opens this socket, creating an empty event queue for it.\n      This LISTEN call may block waiting for the first \"request\" event,\n      or it may return immediately.\n\n\n\n\n\n\n                                                                [Page 9]\n\f\nRFC 46                ARPA Network Protocol Notes             April 1970\n\n\n      b. INIT \u003cmy socket code\u003e \u003cforeign socket\u003e\n\n      A user attempts to connect \u003cmy socket\u003e to \u003cforeign socket\u003e.  The\n      local NCP sends an RFC to the foreign NCP requesting that the\n      connection be created.  The returned acknowledgemnet is either an\n      RFC (request accepted) or CLS (request rejected).  At the caller's\n      option, the INIT call blocks on the expected \"accept\" or \"reject\"\n      event, or it can return immediately without waiting.  In this case\n      the user must call STATUS (see below) at a later time to determine\n      the action by the foreign NCP.  When a blocked INIT call returns,\n      the \"accept\" or \"reject\" event is removed from the event queue.\n\n      c. STATUS \u003cmy socket code\u003e\n\n      This call reports out the earliest previously unreported event in\n      the queue of \u003cmy socket\u003e.  The STATUS call deletes the event from\n      the queue if that type of event is deleteable by disclosure.\n\n      d. ACCEPT \u003cmy socket code\u003e\n\n      The user accepts connection with the foreign socket whose\n      \"request\" event is earliest in the event queue for \u003cmy socket\u003e.\n      An acknowledging RFC is sent to the accepted foreign socket, and\n      the \"request\" event is deleted from the event queue.  Should any\n      other \"request\" event exist in the queue, the NCP automatically\n      denies connection by sending out a CLS command and deleting the\n      event.\n\n      e. REJECT \u003cmy socket code\u003e\n\n      The user rejects connection with the foreign socket whose\n      \"request\" event is earliest in the event queue for \u003cmy socket\u003e.\n      The NCP sends out a CLS command and deletes the \"request\" event\n      from the queue.\n\n      f. CLOSE \u003cmy socket code\u003e\n\n      The user directs the NCP to disconnect any active connection to\n      this socket and to deactivate the socket.  The NCP sends out a CLS\n      command to the foreign socket if a connection has existed.  The\n      status of the foreign socket also becomes closed once the \"close\"\n      event is disclosed to the foreign process.\n\n      g. INTERRUPT \u003cmy socket code\u003e\n\n      The user directs the NCP to send out an INT command to the foreign\n      socket connected to \u003cmy socket\u003e.\n\n\n\n\n                                                               [Page 10]\n\f\nRFC 46                ARPA Network Protocol Notes             April 1970\n\n\n      h. TRANSMIT \u003cmy socket code\u003e \u003cpointer\u003e \u003cnbits\u003e\n\n      The user wishes to read (\u003cmy socket\u003e is receive) or write (\u003cmy\n      socket\u003e is send) \u003cnbits\u003e of data into or out of an area pointed to\n      by \u003cpointer\u003e.  A call to write returns immediately after the NCP\n      has queued the data to send a message over the connection.  The\n      call to write blocks only if the connection is blocked or if the\n      local NCP is too loaded to process the request immediately.  Data\n      to be transmitted over a connection is formatted into one or more\n      IMP messages of maximum length 8095 bits and transmitted to the\n      foreign HOST over the link number specified in the RFC sent by the\n      NCP controlling the receiving connection.  A \"close\" event in the\n      event queue for \u003cmy socket\u003e is disclosed through the action of\n      TRANSMIT.  A call to write discloses the \"close\" event\n      immediately.  A read call discloses it when all data has been\n      read.\n\nThe History of a Connection From a User View\n\nAn Illustrative Example\n\n   Assume that process 'a' on HOST A wishes to establish connection with\n   process 'b' on HOST B.  Before communication can take place, two\n   conditions must be fulfilled:\n\n      a. process 'a' must be able to specify to its NCP a socket in 'b's\n      socket space to which it wants to connect.\n\n      b. process 'b' must already be LISTENing to this socket.\n\n   1. Establishing the Connection\n\n      a. process 'b' LISTENs to socket 'Bb9'.\n\n      b. process 'a' INITs 'Bb9' to its 'Aa12'.  The NCP at A generates\n      an RFC specifying link number = 47, which it chooses from its\n      available set of links.  This is the link over which it will\n      receive messages if the connection is ACCEPTed by process 'b'.\n\n      c. process 'b' is informed of A's INIT request.  He may REJECT\n      connection (NCP B sends back a CLS) or ACCEPT (NCP B sends back an\n      RFC).\n\n      d. If process 'b' ACCEPTs, the confirming RFC establishes the\n      connection, and messages can now flow.\n\n\n\n\n\n\n                                                               [Page 11]\n\f\nRFC 46                ARPA Network Protocol Notes             April 1970\n\n\n          HOST  A               |          HOST B\n          INITIATOR             |          ACCEPTOR\n          PROCESS 'a'           |          PROCESS 'b'\n                                |\n                                |\n                                |  a. LISTEN 'socket code 9'\n                                |\n                                |\n b. INIT 'socket code 12' 'Bb9' |\n      RFC 'AA12' 'Bb9' 'link 47' ==========\u003e\n                                |\n                                | c. ACCEPT 'socket code 9'\n                                |        RFC 'Bb9' 'Aa12'\n                                |\n                                | d. TRANSMIT 'send buffer' 'len'\n                                |                        'socket 9'\n                     \u003c============== IMP message 'link 47' 'send buffer'\n                                |\n e. TRANSMIT 'rec buffer' 'length'\n                    'socket 12' ============\u003e\n                                |\n                                | f. CLOSE 'socket code 9'\n                                |\n                             last RFNM ===\u003e\n                      \u003c============== CLS 'Bb9' 'Aa12'\n     closes socket 'Aa12'       |\n                                |\n\n     FIG 2.  Establishing and Communicating over a Socket Connection\n\n   2. Sending Messages over a Connection.\n\n      a. Process 'b' issues a TRANSMIT call to send data through the\n      connection.  NCP B formats this into an IMP message and sends it\n      to NCP A with link number = 47 as specified by A's RFC.\n\n      b. NCP A receives the raw message from NCP B with link number =\n      47.  NCP A uses this link number in deciding who the intended\n      recipient is, and stores the message in a buffer for the recipient\n      process.\n\n      c. Process 'a' may issue a read (TRANSMIT) call for socket code 12\n      at any arbitrary time.  The read call blocks if there is no data\n      pending for the socket.  The read call picks up the specified\n      number of bits transmitted over socket code 12, perhaps across an\n      IMP message boundary.  The boundaries of the IMP messages are\n      invisible to the read call.\n\n\n\n\n                                                               [Page 12]\n\f\nRFC 46                ARPA Network Protocol Notes             April 1970\n\n\n      d. Should process 'b' send data over the connection at a faster\n      rate than process 'a' picks it up, NCP A can issue a BLK command\n      to NCP B if A's buffers start filling.  Later, when process 'a'\n      catches up NCP A can tell B to resume transmission via an RSM\n      command.\n\n   3. Process 'b' Closes the Connection\n\n      a. Process 'b' decides to close the connection, and it issues the\n      CLOSE call to NCP B.  To avoid race problems B waits for the RFNM\n      from the previous message over this connection, then sends the CLS\n      command to NCP A.  When the RFNM from the CLS command message\n      returns, NCP B flushes socket 'Bb9' from its tables, effecting the\n      close at its end and deactivating 'Bb9'.\n\n      b. Because of sequential processing within NCP A, the last message\n      to socket 'Aa12' is guaranteed to have been directed to a process\n      before the CLS from NCP B comes through.  Upon receipt of the CLS\n      from B, NCP A marks socket 'Aa12' as \"close pending\" and places a\n      \"close\" event into the event queue of 'Aa12'.\n\n      c. Process 'a' can still issue read calls for socket 'Aa12' while\n      there is buffered data pending.  When 'a' issues a read call after\n      the buffer has been emptied, the \"close\" event is disclosed to\n      inform 'a' of the closure, and socket 'Aa12' is flushed from the\n      tables of NCP A.\n\n   4. Process 'a' Closes the Connection\n\n      a. Let us return to step 2. and assume that process 'a' wants to\n      close the connection from its end.  There is no race problem\n      because we assume that once 'a' issues a CLOSE call, it no longer\n      wants to read messages over that socket.\n\n      b. Assume that process 'a' issues a CLOSE call on socket 'Aa12'.\n      NCP A immediately sends out a CLS command to NCP B and marks\n      socket 'Aa12' as \"close pending\".  Any data buffered for read on\n      'Aa12' is discarded.  To allow remaining messages already in\n      transit from process 'b' to percolate through the IMP network to\n      NCP A and be discarded without error comments, NCP A retains\n      'Aa12' in its tables for a suitable period of time after receiving\n      the RFNM from the CLS command.  During this period NCP A discards\n      all messages received over the closing connection.  After allowing\n      a reasonable amount of time for these dead messages to come in,\n      NCP A flushes 'Aa12' from its tables, effectively closing the\n      connection and deactivating 'Aa12'.  Further messages to socket\n      'Aa12' result in NCP A sending an ERR \"erroneous command\" to the\n      originating NCP.\n\n\n\n                                                               [Page 13]\n\f\nRFC 46                ARPA Network Protocol Notes             April 1970\n\n\n      c. When NCP B receives the CLS command, socket 'Bb9' is marked as\n      \"close pending\", and the CLS event is placed into the event queue\n      of 'Bb9'.  The next time process 'b' wishes to write over that\n      socket, the CLS event is disclosed to inform him of the closure,\n      and socket 'Bb9' is removed from NCP B's tables.\n\nIV - USER CONTROL AND COMMUNICATION PROTOCOL\n\n   Some process must exist which agrees to listen to anybody in the\n   network and create a process for him upon proper identification.\n   This process is called the logger and interacts through the NCP via\n   the network-related User Control and Communication (UCC) module,\n   which implements the necessary protocol.  Except for one instance\n   (CLOSEing connections of dead processes), the process operating the\n   UCC module does not have special network privileges.\n\n   Under the UCC protocol a \"requestor\" process which has directed the\n   creation of a \"foreign\" process maintains two full-duplex pseudo-\n   typewriter connections:  one to the foreign logger, and one to the\n   created process.  The duplex connection to the foreign logger is used\n   to identify the requestor process to the logger, and after login to\n   return to the requestor process basic information concerning the\n   health of the created process.  The duplex connection to the created\n   process is used for control communication to it.\n\n   Maintaining two full-duplex connections avoids reconnection problems\n   both when the logger transfers communication to the created process\n   and when it needs to regain control.  This is at the modest expense\n   of requiring the requestor process to switch typewriter\n   communications between two sets of connections.\n\n   The way that communication is established is essentially as follows:\n   the requestor process first reserves four of its sockets having\n   contiguous socket codes.  Then it \"signals\" the UCC, specifying one\n   of these sockets.  From the \"signal\" the UCC knows which process is\n   calling, and by protocol, on which requestor socket pair the UCC is\n   to communicate with the requestor process, and which requestor socket\n   pair the created process is to use for its communications.  This is\n   specified below in more detail.\n\nEstablishing and Operating a Remote Process\n\n   The UCC at each HOST always keeps a send socket with user number = 0,\n   instance tag = 0 open (active and unconnected) as a \"signal\" socket,\n   and periodically checks for INITs to this socket.  Processes wishing\n   to create a process at this HOST must first signal the UCC by issuing\n   an INIT to this socket.\n\n\n\n\n                                                               [Page 14]\n\f\nRFC 46                ARPA Network Protocol Notes             April 1970\n\n\n   The requesting process must have four free sockets with contiguous\n   socket codes:  \u003cbase_socket\u003e (receive) through \u003cbase_socket+3\u003e\n   (send).  The high numbered send/receive set of sockets is used for\n   typewriter communication with the foreign UCC, the low numbered set\n   for typewriter communication with the created process.\n\n   1. The \"requestor\" process calls LISTEN twice to open the\n   \u003cbase_socket+2\u003e and \u003cbase_socket+3\u003e receive/send pair over which it\n   will talk to the foreign UCC.  Then it sends out a \"signalling\" INIT\n   call on \u003cbase_socket\u003e to the UCC \"signal\" socket.  The only thing\n   that the UCC does with this \"signalling\" INIT call is to note down\n   the socket number \u003cbase_socket\u003e from which it originated.  The UCC\n   immediately rejects this request so as to keep its \"signal\" socket\n   open for other signals.\n\n   2. After receiving the expected REJECT on its initial INIT call to\n   the UCC's signal socket, the requestor process issues LISTENs for\n   \u003cbase_socket\u003e and \u003cbase_socket+1\u003e.  (The created process will INIT\n   these sockets to establish control communication with the requestor\n   process.)  The requestor process then blocks by calling STATUS\n   \u003cbase_socket+2\u003e .\n\n   3.  The UCC INITs a free send/receive socket pair to the requestor's\n   \u003cbase_socket+2\u003e and \u003cbase_socket+3\u003e on which the requestor process is\n   presumably LISTENing.  The requestor process has called STATUS\n   \u003cbase_socket+2\u003e with block option after LISTENing for the two\n   sockets, so that when the INIT from the foreign UCC reaches the\n   requestor process, STATUS returns with the INIT indication.  The\n   requestor process verifies that the UCC is the process that is\n   calling, then it ACCEPTs the call.  The requestor process then calls\n   STATUS \u003cbase_socket+3\u003e and returns when the INIT for that socket\n   reaches it.  It does a similar verify and ACCEPT.  (There is an\n   arbitrary choice as for which socket the requestor process first\n   calls STATUS.)  Two way communication is established when the\n   requestor process has ACCEPTed both INITs from the UCC.  This\n   connection is maintained during the login ritual and throughout the\n   life of the created process.  Should the requestor process fail to\n   respond properly within a limited amount of time to the INITs of the\n   UCC, the UCC abandons the connection attempt.\n\n   4. The requestor process must then perform the login ritual with the\n   UCC.  (The initial protocol might standardize the login ritual.)  If\n   the logger is not satisfied and wishes to cut off the requestor, the\n   UCC module CLOSEs both \u003cbase_socket+2\u003e and \u003cbase_socket+3\u003e, perhaps\n   after the logger has sent a suitable message.\n\n\n\n\n\n\n                                                               [Page 15]\n\f\nRFC 46                ARPA Network Protocol Notes             April 1970\n\n\n   5.  If satisfied, the logger creates a process for the user.  The UCC\n   maintains direct communication with the requestor, but this\n   connection is now used only to report basic information concerning\n   the created process.\n\n   6. The first task of a created process is to establish a dual\n   pseudo-typewriter control connection with its requestor process.  The\n   created process INITs one of its send/receive socket pairs to the\n   requestor's \u003cbase_socket\u003e and \u003cbase_socket+1\u003e.  If both requests are\n   ACCEPTed, the created process sends an initial message over this\n   connection.  Then it goes to command level, in which it awaits a\n   typewriter command message over the connection.  If the created\n   process is unable to establish duplex communication with the\n   requestor process, it should destroy itself.  The UCC will either\n   CLOSE its own connections with the requestor or make arrangements for\n   another process to be created.\n\n   7. When a created process is logged-out, the UCC uses a privileged\n   entry to the NCP to CLOSE all connections between the dead process\n   and other processes, and to deactivate all open sockets of the dead\n   process.  The UCC transmits a message back to the requestor process,\n   then CLOSEs the dual connections between it and the requestor\n   process.\n\n   8. The INTERRUPT call has a standard \"quit\" meaning when sent from a\n   requestor process to a created process over the requestor's receive\n   socket \u003cbase_socket\u003e.  All pending output from the created process is\n   aborted, and the it enters \"command level\" where it awaits a command\n   over the typewriter connection to the requestor process.  The\n   interrupted processing is resumable by issuing a \"start\" command to\n   the created process.  (Note that the rule about pending output is\n   more restrictive than that implemented by the INT NCP command.)\n\n      This document was prepared through the use of the MULTICS \"runoff\"\n      command.  A source file consisting of intermixed text and \"runoff\"\n      requests was created using the \"qed\" text editor.  This file was\n      then compiled by the \"runoff\" command to produce a finished copy.\n      The latest version of this document exists online in MULTICS in\n      the segment\n\n            \u003eudd\u003eMultics\u003eMeyer\u003enetwork_protocol.runoff\n\n                                    (END)\n\n\n\n\n\n\n\n\n                                                               [Page 16]\n\f\nRFC 46                ARPA Network Protocol Notes             April 1970\n\n\n      REQUESTOR                                  FOREIGN\n      PROCESS                                    LOGGER\n      --------------                             -------------\n      a. LISTEN to sockets\n      \u003cbase_socket+2\u003e and\n      \u003cbase_socket+3\u003e to be\n      connected to foreign logger.\n\n      b. INIT \u003cbase_socket\u003e\n      to \"signal\" socket of\n      foreign logger.\n                =======================================\u003e\n\n                                                c. remember \u003cbase_socket\u003e\n                                                   and REJECT connection\n                                                   to signal socket.\n\n      d. LISTEN to sockets                      e. INIT a logger socket\n      \u003cbase_socket\u003e and                            pair to the requestor's\n      \u003cbase_socket_1\u003e to be                       \u003cbase_socket+2\u003e and\n      connected to the created  process.          \u003cbase_socket+3\u003e.\n                                                   /\n                       \u003c==========================/\n\n      f. ACCEPT connection\n      with sockets from\n      foreign logger.\n\n                             PERFORM LOGIN RITUAL\n                                                CREATED\n                                                PROCESS\n                                                -------------\n                                                g. INIT any socket pair\n                                                   to requestor's\n                                                   \u003cbase_socket\u003e and\n                                                   \u003cbase_socket+1\u003e\n                                                    /\n                       \u003c===========================/\n      h. ACCEPT connection\n      with sockets from created\n      process.\n\n               FIG. 4 Establishing a Process at a Foreign HOST\n\n\n          [ This RFC was put into machine readable form for entry ]\n          [ into the online RFC archives by Miles McCredie 11/99  ]\n\n\n\n\n                                                               [Page 17]\n\f\n"
}