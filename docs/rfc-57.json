{
  "series": "Request for Comments",
  "number": "57",
  "howpublished": "RFC 57",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0057",
  "url": "https://www.rfc-editor.org/info/rfc57",
  "title": "Thoughts and Reflections on NWG/RFC 54",
  "pagetotal": "5",
  "year": "1970",
  "month": "jun",
  "body": "\n\n\n\n\n\nNetwork Working Group                              Mike Kraley (Harvard)\nRequest for Comments #57                          John Newkirk (Harvard)\n\n                                                   June 19, 1970\n\n\n                Thoughts and Reflections on NWG/RFC #54\n\n\n       In the course of writing NWG/RFC #54 several new ideas became\napparent.  Since these ideas had not previously been discussed by the\nNWG, or were sufficiently imprecise, it was decided not to include them\nin the official protocol proffering.  We thought, however, that they\nmight be proper subjects for discussion and later inclusion in the\nsecond level protocol.\n\nI.  Errors and Overflow\n\n       In line with the discussion in NWG/RFC #48, we felt that two\ntypes of errors should be distinguished.  One is a real error, such as\nan RFC composed of two send sockets.  This type of error can only be\ngenerated by a broken NCP.  In the absence of hardware and software\nbugs, these events should never occur; the correct response upon\ndetection of such an event was outlined in the description of the ERR\ncommand in NWG/RFC #54.\n       The other \"error\" is an overflow condition arising because\nfinite system resources are exhausted.  An overflow condition could\noccur if an RFC was received, but there was no room to create the\nrequisite tables and queues.  This is not a real error, in the sense\nthat no one has done anything incorrect (expect perhaps the system\nplanners in not providing sufficient table space, etc.)  Further, a\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                                [Page 1]\n\f\nRFC 57          Thoughts and Reflections on NWG/RFC #54        June 1970\n\n\nrecovery procedure can be well defined, and simply entails repeating the\nrequest at a future time.  Thus, we believe an overflow condition should\nbe distinguished from a real error.\n       In NWG/RFC #54 an overflow condition was reported by returning\na CLS, as if the connection had been refused.  This sequence performs\nthe necessary functions, and leaves the connection in the correct state,\nbut the initiating user is misinformed.  He is deluded into thinking\nthat he was refused by the foreign process, when, in fact, this was not\nthe case.  In certain algorithms this difference is crucial.\n       In further defining error conditions, we felt that it would\nbe helpful to specify why the error was detected, in addition to\nspecifying what caused the error.  While writing the pseudo-Algol\nprogram mentioned in NWG/RFC #55 we differentiated 9 types of errors\n(listed below).  We would, therefore, like to propose the extension of\nthe ERR message to include an 8-bit field following the op code to\ndesignate the type of error.  This would be followed by the length and\ntext fields, as before.  We propose these error types;\n\n       0.  UNSPECIFIED ERROR\n       1.  HOMOSEX  (invalid send/rcv pair in an RFC)\n       2.  ILLEGAL OP CODE\n       3.  ILLEGAL LEADER (bad message type, etc.)\n       4.  ILLEGAL COMMAND SEQUENCE\n       5.  ILLEGAL SOCKET SPECIFICATION - COMMAND\n       6.  ILLEGAL COMMAND LENGTH (last command in message was too short)\n       7.  CONNECTION NOT OPEN - DATA\n       8.  DATA OVERFLOW (message longer than advertised available\n           buffer space)\n       9.  ILLEGAL SOCKET SPECIFICATION - DATA (socket does not exist)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                                [Page 2]\n\f\nRFC 57          Thoughts and Reflections on NWG/RFC #54        June 1970\n\n\n       In light of the other considerations mentioned earlier, we\nwould also like to propose an additional control command to singify\noverflow:\n\n        +-------------+-------------------+---------------------+\n        |     OVF     |     my socket     |     your socket     |\n        +-------------+-------------------+---------------------+\n\nThe format of the message is similar to that of the CLS message, which\nit replaces in this context.  The socket numbers are 32 bits long and\ncorrespond to the socket numbers in the RFC which is being rejected.\nThe semantics of an incoming OVF should be indentical to an incoming\nCLS; in addition, the user should be informed that he has not been\nrefused but rather has overtaxed the foreign host's resources.\n       An alternative to creating a separate control command can be\nrealized by considering the similarity between a CLS and an OVF.\nConceivably, an eight-bit field could be added to the CLS command to\ndefine its derivation.  We believe, however, that this alternative is\nconceptually inferior and practically more difficult to implement.\n       Overflow does not require serious consideration if it is a\nsignificantly rare occurrence.  We do not believe this will be the case,\nand we further believe that its absence will be an unnecessary\nrestriction upon the user.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                                [Page 3]\n\f\nRFC 57          Thoughts and Reflections on NWG/RFC #54        June 1970\n\n\nII.  Host Up and Host Down\n\n       Significant problems can arise when a host goes down and then\nattempts to restart.  Two cases can easily be distinguished.  The first\nis a \"soft\" crash, where the system has prior notice that the machine is\ngoing down; sufficient time is available to execute pre-recovery\nprocedures.  The other case can be termed a \"hard\" crash, often the\nresult of a system failure.  Insignificant warning is usually given; but\nmore important, the state of the machine after recovery is rarely\npredictable.\n       When a host returns from a hard crash, the network will be\nin an undefined state.  Very probably the NCP's data structures are\ndestroyed or are meaningless.  The network has declared the host dead --\nbut only to processes which attempted data transmission and were\nrefused.  The only alternative for the crashed host is re-initialization\nof its tables.  What are the alternatives for the foreign hosts?\n       We would like to propose the addition of two control commands:\nRESET (RST) and RESET REPLY (RSR).  Each would consist solely of an op\ncode with no parameters.  Upon receipt of an RST, a host would\nimmediately terminate all connections with the sending host, but would\nnot issue any CLS's.  The receiver of the RST would also note that the\noriginator of the RST was alive, and would then echo an RSR to the\nsender.  When a host receives an RSR, he sould then note that the\nechoing host is alive.  (The function of RST can be partially simulated\nif a host will immediately close all relevant table entries upon\ndiscovering that another host is down.)\n       Thus, after a hard crash, all connections and request for\nconnections are terminated.  The RST also informs all foreign hosts that\nwe are again alive, and an RSR is received from every functioning NCP.\nA host live table (see NWG/RFC #55) can easily be\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                                [Page 4]\n\f\nRFC 57          Thoughts and Reflections on NWG/RFC #54        June 1970\n\n\nassembled, and establishment of connections can resume.\n       Related problems also crop up when we consider attempting\nto synchronize the network, which may still be carrying messages\ngenerated prior to the crash, with an NCP which has an initialized\nenvironment.  We lack the facilities for unblocking links, discarding\nmessages, etc. -- facilities which this proposal will necessitate.\nFurther interaction with BBN should resolve these difficulties.\n       The problems associated with \"soft\" crashes are not nearly\nas pressing, and they demand more sophisticated (i.e., complex)\nsolutions.  Our preliminary experimentation with the network\ndemonstrates that a good initialization and recovery protocol are far\nmore necessary.\n\n\n\n\n       Many of the ideas presented herin wre germinated and/or\njelled through conversations with Steve Crocker and Jon Postel.  We\nwould also like to acknowledge the assistance of Jim Balter and Charles\nKline of UCLA, who devoted a great deal of effort toward helping develop\nthe pseudo-Algol program which was the predecessor of much of our recent\ndocumentation.\n\n       [ This RFC was put into machine readable form for entry ]\n       [ into the online RFC archives by  Katsunori Tanaka 2/98 ]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                                [Page 5]\n\f\n"
}