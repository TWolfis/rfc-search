{
  "series": "Request for Comments",
  "number": "76",
  "howpublished": "RFC 76",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0076",
  "url": "https://www.rfc-editor.org/info/rfc76",
  "title": "Connection by name: User oriented protocol",
  "pagetotal": "15",
  "year": "1970",
  "month": "oct",
  "body": "\n\n\n\n\n\nNetwork Working Group                                      J. Bouknight\nRequest for Comments: 76                                      J. Madden\nNIC 5180                                                    G. Grossman\n                                                 University of Illinois\n                                                        28 October 1970\n\n\n               Connection-By-Name: User-Oriented Protocol\n\n\nI. Introduction\n\n   Shortly after the first of the year, 1971, the Center for Advanced\n   Computation (CAC) at the University of Illinois will begin to use the\n   facilities of the ARPA network.  We are the first of a small class of\n   network nodes whose chief characteristic is that the node is a port\n   to the network only.  All computational power for these nodes will be\n   taken from other nodes on the network, ILLIAC IV for example.\n\n   An important characteristic of most of the users at our Center is a\n   lack of sophistication about data communication techniques and\n   practices.  The user will eventually be in the majority of those\n   using the network from all nodes but the problem is ours, almost from\n   the start.\n\n   In our discussions with our prospective users of the network as we\n   designed our port facility, we found that the greatest confusion and\n   consternation arose over having to deal with network protocol at the\n   \"nitty-gritty\" level of sockets, links, etc.  While most of them have\n   been acclimated to computer systems at the file and device-by-name\n   level where the software system handles details, here on the current\n   version of the network, the user handles all details.\n\n   Thus, we were compelled to seek a user level interface to network\n   protocol where all user protocol is handled symbolically with system\n   procedures making the translation into host-to-host protocol.\n\n   Currently, connections are established by exchange of known socket\n   numbers for the four loose ends of the connection.  This requires\n   either that the user or process always know all socket numbers he\n   will use at his or other installations OR that his NCP (and/or\n   related software) remember them for him, allowing him to reference\n   them symbolically.\n\n   We propose a more general solution to the \"telephone book\" approach\n   of obtaining socket numbers for user or processes.  Only the host, at\n   each site, knows its socket number space at any given instant in time\n   as well as the status of the user or process to which a socket number\n\n\n\nBouknight, et al.                                               [Page 1]\n\f\nRFC 76         Connection-By-Name: User-Oriented Protocol   October 1970\n\n\n   assigned.  Additionally, most permanently assigned devices and/or\n   processes are known by standard mnemonic labels such as DSK (disk),\n   LP (line printer), CR (card reader), TECO (PDP-10 text editor), etc.\n   In most systems, all other communications are done through files or\n   pseudo files, known only to the user by their names and not by their\n   internal mechanism.  In other words, most intrasystem communication\n   at the user level is by symbolic reference to both devices and\n   process.\n\n   We propose facilities, by extension of the current protocol, that\n   will allow users to use the network on a connection-by-name basis as\n   they already do in their host system.  In the remainder of this paper\n   we will present the suggested extensions to the current protocol and\n   give an example of its usage in a dialogue between a user at CAC,\n   controlling two processes; one at UTAH, and one at PAOLI (ILLIAC IV\n   construction site).\n\nII. Proposed Extensions to Protocol\n\n   Let us define a class of syntax elements for use in our proposed\n   extensions to the protocol. (This syntax is expressed in the\n   metalanguage of the ALGOL-60 report.)\n\n   \u003clabel\u003e ::= \u003cusercode\u003e/\u003cfilename\u003e|\u003cdevice name\u003e\n\n   \u003cdevicename\u003e ::= \u003cstring\u003e\n\n   \u003cusercode\u003e ::= \u003cstring\u003e\n\n   \u003cfilename\u003e ::= \u003cstring\u003e|\u003cfilename\u003e/\u003cstring\u003e\n\n   \u003cstring\u003e ::= \u003cchar\u003e|\u003cchar\u003e \u003cstring\u003e\n\n   \u003cchar\u003e ::= A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z|0|1|2|\n              3|4|5|6|7|8|9|.|,\n\n   A standard set of \u003cdevicenames\u003e should be established to reference\n   line printers, card readers, etc. - those hard peripherals with fixed\n   processing tasks.  A beginning set of \u003clabels\u003e might be:\n\n      LP            line printer\n      CR            card reader\n      CP            card punch\n      PTR           paper tape recorder\n      PTP           paper tape punch\n      MT            magnetic tape\n      DSK           disk\n      TTY           teletype compatible terminal\n\n\n\nBouknight, et al.                                               [Page 2]\n\f\nRFC 76         Connection-By-Name: User-Oriented Protocol   October 1970\n\n\n   The format of \u003cusercode\u003e is that of the responding host for the\n   current discussion.  Future discussions about foreign-user usage of\n   host facilities may result in a standard format for the entire\n   network.\n\n   Most systems can identify files by one \u003cstring\u003e plus the \u003cusercode\u003e.\n   Others, such as the Burroughs B6500 use multifile identifiers where\n   many \u003cstrings\u003e may be used in the \u003clabel\u003e.  The set of \u003cchar\u003e is that\n   proposed in RFC 66, i.e., ASCII.\n\n   The proposed extensions involve a \"request\" for information and\n   several variants of a \"response\" to the request.\n\n   A. Request for Socket Number for this Label\n\n      \u003cRFSNL\u003e \u003cmy socker #\u003e \u003c0\u003e \u003clabel\u003e\n\n   The RFSNL is sent on the control link to the destination host\n   requesting the socket number of the attached \u003clabel\u003e.\n\n   B. Acknowledgement of Request\n\n   Upon receipt of an \u003cRFSNL\u003e, the destination host returns one of three\n   responses:\n\n      \u003cAORP\u003e \u003cdesired socket#\u003e \u003cyour socket #\u003e\n\n      \u003cAORN\u003e \u003cdesired socket#\u003e \u003cyour socket #\u003e\n\n      \u003cAORN\u003e \u003c0\u003e \u003cyour socket #\u003e\n\n   The first response returns the requested socket number and signifies\n   that the user, device, or process exists.  The second response\n   returns the requested socket number but signifies that the user,\n   device, or process is not currently available for connection.  The\n   last response signifies that no such user, device, or process exists.\n\n   C. Discussion\n\n   The above extensions to the protocol are intended to enhance user\n   acclimation to network usage.  The element of strangeness is subdued\n   and, in fact, for user of the B6500 erased.  Attached to this RFC is\n   an appendix containing a preliminary description of the user language\n   of the network port facility being brought up at the CAC.  We now\n   present a sample user session on the CAC facility and detail how the\n   protocol is used to establish the proper communication paths.\n\n\n\n\n\nBouknight, et al.                                               [Page 3]\n\f\nRFC 76         Connection-By-Name: User-Oriented Protocol   October 1970\n\n\nIII. Example of User Dialogue\n\n   Assume a user residing at CAC, whose site code is URBANA.  His\n   terminal is an alphanumeric CRT terminal and we assume solution of\n   code conversion problems for network communications.\n\n   The sample user session will involve the setting up of two processes\n   at two host sites with control from the third host site.  All\n   operations can be accomplished with the current protocol plus the\n   proposed extensions.\n\n   In addition, we also assume that some form of standard user code is\n   in use for all host sites uniquely identifying every network user\n   when he is present.\n\n   Output keyed by systems will be underlined.  Comments are offset to\n   the right for legibility.  All statements about the UTAH system are\n   purely hypothetical.\n\n    User Dialogue                           Comments\n\n                                 The user moves to the terminal, applies\n                                 power and types:\n\n   HELLO\n                                 The CAC system responds for login\n                                 purposes with:\n\n   USER= GROSSMAN\n   ------\n                                 for the user's code.\n\n\n   1437 TR7/GROSSMAN LOGGED IN\n   ___________________________\n   LINE PRINTER DOWN TILL 1600\n   ___________________________\n                                 This acknowledges proper usercode and\n                                 sends any appropriate notes on system\n                                 status.\n   ! LINK TO ILLIAC\n                                 The exclamation point (!) is the escape\n                                 character which flags direct input to\n                                 the PDP-11 OS:\n\n                                 User requests connection to the ILLIAC\n                                 IV node.  NCP operations establish link\n                                 from user terminal to B6500 MCP.\n\n\n\nBouknight, et al.                                               [Page 4]\n\f\nRFC 76         Connection-By-Name: User-Oriented Protocol   October 1970\n\n\n\n   1437 TR7/GROSSMAN LINKED ILLIAC\n   -------------------------------\n                                 Completes response.\n\n   ? EXECUTE DISK/PRINT; FILE DISK = ALPHA@UTAH REMOTE QUEUE; END\n\n                                 1. DISK/PRINT lists text files from\n                                 disk to B6500 line printer.\n                                 2. REMOTE files on the B6500 will refer\n                                 to files going to/coming from the\n                                 network.\n                                 3. ALPHA@UTAH specifies that a\n                                 connection is to be made via the\n                                 network to a file GROSSMAN/ALPHA from\n                                 the UTAH node.\n                                 4. QUEUE specifies periodic attempt to\n                                 complete the connection.\n\n                                 The B6500 will ask for the socket\n                                 number associated with GROSSMAN/ALPHA\n                                 until an AORP is received.\n\n                                 The language is that of the monitor for\n                                 the B6500\n   ! FLAG ILLIAC =#\n                                 All data received or sent on the link\n                                 to ILLIAC must now be prefaced by the #\n                                 character.\n\n   ! LINK TO UTAH\n\n   1441 TR7/ GROSSMAN LINKED UTAH\n   ------------------------------\n                                 User now links into UTAH PDP-10 system.\n\n   #1410: DISK/PRINT BOJ 1441\n   --------------------------\n                                 System message stating beginning-of-job\n                                 for DISK/PRINT on B6500.\n\n   ^C\n\n    . R PIP\n    -\n                                 User will run PIP on a listing file.\n\n\n\n\n\nBouknight, et al.                                               [Page 5]\n\f\nRFC 76         Connection-By-Name: User-Oriented Protocol   October 1970\n\n\n\n   * NETWKR:ALPHA@ILLIAC \u003c- DSK:FIL.TMP\n   -\n                                 NETWRK is network file type for UTAH\n                                 system.  Mechanism for file control\n                                 basically same as for B6500 system.\n                                 Since PIP will be sending to the\n                                 network, it does not request a socket #\n                                 from the B6500 NCP but instead\n                                 instructs its NCP to acknowledge any\n                                 request for GROSSMAN/ALPHA from ILLIAC\n                                 with the socket number PIP will send\n                                 from.  As soon as the B6500 NCP tries\n                                 again to find GROSSMAN/ALPHA from UTAH,\n                                 success occurs and the socket numbers\n                                 are exchanged with subsequent\n                                 connection establishment.\n\n   *\n   -\n                                 PIP completes the task and terminates\n                                 the connection to the B6500.\n\n   #14: DISK/PRINT EOJ 1448\n                                 B6500 acknowledges completion of task.\n\n   #? TO SPO: SAVE LIST GROSSMANHA FOR MAIL(U OF I/GROSSMAN)\n                                 User sends message to B6500 operator.\n\n                                 User logs out of UTAH.\n   JOB 10, USER GROSSMAN@URBANA TY68 AT 1448 ON 22-NOV-70\n   ------------------------------------------------------\n\n   FILES DELETED: 0, FILES SAVEDL RUNTIME 0 MIN 12 SEC\n   ---------------------------------------------------\n                                 System logout listing.\n\n   ! END UTAH\n\n   1449 TR7/GROSSMAN DELINKED UTAH\n   -------------------------------\n                                 Link to UTAH system now dropped.\n\n   # FROM SPO: LISTING MAILED\n   --------------------------\n                                 B6500 operator response.\n\n\n\n\n\nBouknight, et al.                                               [Page 6]\n\f\nRFC 76         Connection-By-Name: User-Oriented Protocol   October 1970\n\n\n   ! LEAVE\n                                 User desired to log out of CAC system.\n\n   1450 TR7/GROSSMAN DELINKED ILLIAC\n   ---------------------------------\n                                 Link to ILLIAC system new dropped.\n\n   1450 TR7/GROSSMAN LOGGED OUT\n   ----------------------------\n                                 Session over.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBouknight, et al.                                               [Page 7]\n\f\nRFC 76         Connection-By-Name: User-Oriented Protocol   October 1970\n\n\n        Syntax and Semantics for the Terminal User Control Language\n           for the Proposed PDP-11 ARPA Network Terminal System\n\n                                    by\n\n                              G. R. Grossman\n\n\nPrefatory Notes\n\n   The following document represents a first attempt at providing a\n   control language for the terminal user of the PDP-11 network terminal\n   system.  This language is deemed sufficiently powerful to provide the\n   user with a minimal facility for attaching to remote host computers\n   over the ARPA network, initiating processes, and routing data flow to\n   local peripheral devices.\n\n   The hardware system as envisioned will comprise a PDP-11/20 with a\n   least 8k of core, a small disk (512 kilobytes of storage), a console\n   teletype, and optional card readers, line printers, DECtapes, User\n   terminals, card punches, storage scopes, etc.\n\n   The executive system will consist of a basic driver system which will\n   control autonomous processes and interrupt-driven device service\n   routines.  The system will keep tables in core and on the small disk\n   for logging peripheral usage, keeping track of connections on the\n   network, queuing up of tasks that cannot be immediately performed,\n   storing attributes of remote hosts, etc.\n\n   Since network hosts handle communications in character-at-a-time or\n   message modes, and may or may not echo characters over the network,\n   the system takes this into account when handling connections to\n   specific hosts.  If the connection is in message mode, minimal line-\n   by-line editing facility (character and line deletion) is provided.\n\n   A means for the user to change flag and message transmit characters\n   is provided to prevent incompatibilities which may arise between the\n   PDP-11 and other hosts.\n\n   This document does not describe control card syntax for card reader\n   usage, nor does it describe the operator's control language.  These\n   will be described in later documents.\n\nCharacter Set\n\n   \u003ccharacter\u003e ::= \u003cletter\u003e | \u003cdigit\u003e | \u003cspecial\u003e | \u003cspace\u003e\n\n   \u003cletter\u003e    ::= A | B | ... | Y | Z\n\n\n\nBouknight, et al.                                               [Page 8]\n\f\nRFC 76         Connection-By-Name: User-Oriented Protocol   October 1970\n\n\n   \u003cdigit\u003e     ::= 0 | 1 | ... | 8 | 9\n\n   \u003cspecial\u003e   ::= ! | \" | # | $ | % | \u0026 | ' | ( | ) | * | + | , | - |\n                   . | / | : | : | \u003c | = | \u003e | ? | @ | [ |  | ] | ^ |\n                     |` | { | \u003cbar\u003e | }\n\nIdentifiers\n\n   \u003cidentifiers\u003e ::= \u003cletter\u003e | \u003cidentifier\u003e \u003cletter\u003e |\n                     \u003cidentifier\u003e \u003cdigit\u003e\n\n        Semantics:  Identifiers are used to designate peripheral units,\n        host computers, etc.  No identifier may exceed 8 characters in\n        length.\n\nNumbers\n\n   \u003cinteger\u003e ::= \u003cdigit\u003e | \u003cinteger\u003e \u003cdigit\u003e\n\n        Semantics:  \u003cinteger\u003e are the only form of number allowed in the\n        control language.  They must not exceed 2^15-1.\n\nPeripheral Designator\n\n   \u003cperipheral designator\u003e ::= \u003cdevice class\u003e \u003cdevice number\u003e | OPR\n\n   \u003cdevice number\u003e         ::= \u003cdigit\u003e | \u003cdigit\u003e \u003cdigit\u003e |\n\n   \u003cdevice class\u003e          ::= CR | CP | LP | DT | TR | SS\n\n        Semantics:  Peripheral designators name specific peripheral\n        devices.  Device lasses designate classes of peripherals.\n\n        OPR designates the operator's console teletype.  The classes of\n        peripherals corresponding to the device classes are given on the\n        following table:\n\n            \u003cdevice class\u003e                      type of peripheral\n\n                CR                                  card reader\n                CP                                  card punch\n                LP                                  line printer\n                DT                                  DECtape\n                TR                                  terminal\n                SS                                  storage scope\n\n\n\n\n\n\nBouknight, et al.                                               [Page 9]\n\f\nRFC 76         Connection-By-Name: User-Oriented Protocol   October 1970\n\n\nFile Label\n\n   \u003cfile label\u003e     ::=  \u003ctape label\u003e |  \u003ctape label\u003e / \u003ctape file name\u003e\n\n   \u003ctape label\u003e     ::=  \u003cidentifier\u003e\n\n   \u003ctape file name\u003e ::=  \u003cidentifier\u003e\n\n        Semantics: File labels provide the means for designating tape\n        files symbolically.  If the \u003ctape label\u003e form is used, the\n        designated file is assumed to occupy the entire tape.\n\nFlagged Control Statement\n\n   \u003cflagged control statement\u003e  ::= \u003cflag\u003e \u003ccontrol statement\u003e\n\n   \u003cflag\u003e                       ::= \u003cspecial\u003e\n\n        Semantics: \u003cFlagged control statement\u003es arc the user's names of\n        communicating with the PDP-11 system.  The \u003cflag\u003e must be the\n        system default flag (!) or a substitute which the user provides\n        by means of the \u003cflag statement\u003e.  Input to the system which\n        does not begin with a \u003cflag\u003e will be passed on to the process to\n        which the user is connected, if any.\n\nControl Statements\n\n   \u003ccontrol statement\u003e  ::= \u003clink statement\u003e |\n\n                            \u003ccopy statement\u003e |\n\n                            \u003cend statement\u003e |\n\n                            \u003cuser statement\u003e |\n\n                            \u003cstatus statement\u003e |\n\n                            \u003cout statement\u003e |\n\n                            \u003cto statement\u003e |\n\n                            \u003cescape statement\u003e |\n\n                            \u003cback statement\u003e |\n\n                            \u003cdelete statement\u003e |\n\n                            \u003ctransmit statement\u003e |\n\n\n\nBouknight, et al.                                              [Page 10]\n\f\nRFC 76         Connection-By-Name: User-Oriented Protocol   October 1970\n\n\n                            \u003clock statement\u003e |\n\n                            \u003cunlock statement\u003e |\n\n                            \u003cassign statement\u003e |\n\n                            \u003clabel statement\u003e |\n\n                            \u003ccreate statement\u003e |\n\nLink Statement\n\n   \u003clink statement\u003e ::= LINK TO \u003chost\u003e \u003cq\u003e\n\n   \u003cq\u003e              ::= \u003cempty\u003e |\n\n                        QUEUE   |\n\n                        QUEUE    \u003cinteger\u003e\n\n        Semantics: The Link statement directs the system to set up a\n        connection between the user's unit and a remote host.  The \u003cq\u003e\n        construct allows the user to specify that, if the connection\n        cannot be set up immediately, the system is to keep trying.  If\n        the QUEUE form is used, the system will keep trying\n        indefinitely.  If the QUEUE integer form is used, the system\n        will try for integer minutes.\n\nCopy Statement\n\n   \u003ccopy statement\u003e   ::= COPY \u003csource\u003e TO \u003cdest\u003e \u003cq\u003e\n\n   \u003csource\u003e           ::= NETWORK |\n\n                          \u003cfile label\u003e |\n\n                          \u003csource class\u003e |\n\n                          \u003csource device\u003e\n\n   \u003csource class\u003e     ::= CR | TR | SS |\n\n   \u003csource device\u003e    ::= \u003csource class\u003e \u003cdevice number\u003e\n\n   \u003cdest\u003e             ::= NETWORK\n\n                          \u003cfile label\u003e |\n\n\n\n\nBouknight, et al.                                              [Page 11]\n\f\nRFC 76         Connection-By-Name: User-Oriented Protocol   October 1970\n\n\n                          \u003cdest class\u003e |\n\n                          \u003cdest device\u003e\n\n   \u003cdest class\u003e       ::= CP | LP | TR | SS\n\n   \u003cdest device\u003e      ::= \u003cdest class\u003e \u003cdevice number\u003e\n\n        Semantics: The \u003ccopy statement\u003e directs the system to set up a\n        connection between the \u003csource\u003e and \u003cdest\u003e and copy records of\n        information between them.  If the \u003cdevice class\u003e or \u003cdevice\u003e\n        form is used for either \u003csource\u003e or \u003cdest\u003e, the copy process\n        cannot begin until a unit is assigned to the user.  If the \u003cfile\n        label\u003e form is used, the copy process can likewise not proceed\n        until the system has access to a properly labeled tape. if the\n        NETWORK form is used, a connection to a remote process must be\n        pending.\n\n        The \u003cq\u003e construct has the same meaning as for the \u003clink\n        statement\u003e, with the additional provision that the condition\n        that caused the process to be incomplete may be the lack of a\n        device assignment.\n\nEnd Statement\n\n   \u003cend statement\u003e   ::= END\n\n        Semantics: The \u003cend statement\u003e causes the current connection to\n        be terminated.\n\nUser Statement\n\n   \u003cuser statement\u003e  ::= USER = \u003cidentifier\u003e\n\n        Semantics: The \u003cuser statement\u003e is used during the log in\n        process to allow the user to identify himself.\n\nStatus Statement\n\n   \u003cstatus statement\u003e ::= STATUS \u003cdevice class\u003e |\n\n                          STATUS \u003cperipheral designator\u003e\n\n        Semantics: The \u003cstatus statement\u003e allows the user to interrogate\n        the system as to the status of a device or class of devices.\n\n\n\n\n\n\nBouknight, et al.                                              [Page 12]\n\f\nRFC 76         Connection-By-Name: User-Oriented Protocol   October 1970\n\n\nOut Statement\n\n   \u003cout statement\u003e ::= OUT|LEAVE\n\n        Semantics: The \u003cout statement\u003e allows a user to log out of the\n        system.  If the OUT form is used, all queued process initiated\n        by the user are terminated.  The LEAVE from does not terminate\n        such pending queued processes so long as these processes do not\n        directly involve the user's terminal.\n\nTo Statement\n\n   \u003cto statement\u003e ::= TO CON :\u003ctext\u003e |  TO \u003cuser\u003e : \u003ctext\u003e\n\n        Semantics: The \u003cto statement\u003e allows the user to send a message\n        to the operator or another logged-in user.\n\nFlag Statement\n\n   \u003cflag statement\u003e ::= FLAG = \u003cspecial\u003e\n\n        Semantics: The \u003cflag statement\u003e allows the user to define the\n        character which the system recognizes as preceding a control\n        statement as distinguished from a message to a remote process to\n        which he may be attached.  The default flag character is \"|\".\n\nBack Statement\n\n   \u003cback statement\u003e ::= BACK ? {ascii special or control character}\n\n        Semantics: The \u003cback statement\u003e allows the user to define the\n        character which, in control or message mode, causes the system\n        to \"forget\" the previous input character.  The default backspace\n        character is RUBOUT (ASCII 1778).\n\nDelete Statement\n\n   \u003cdelete statement\u003e ::= DELETE = {ASCII special or control character}\n\n        Semantics: The \u003cdelete statement\u003e allows the user to define the\n        character which, in control or message mode, causes the system\n        to \"forget\" the previous line of input.  The default delete\n        character is ASCII VT (control K).\n\n\n\n\n\n\n\n\nBouknight, et al.                                              [Page 13]\n\f\nRFC 76         Connection-By-Name: User-Oriented Protocol   October 1970\n\n\nTransmit Statement\n\n   \u003ctransmit statement\u003e ::= TRANSMIT = {ASCII special or\n                                        control character}\n\n        Semantics: The \u003ctransmit statement\u003e allows the user to define\n        the character which, in control or message mode, causes the\n        system to begin interpreting the control statement or to\n        transmit the message.  The default transmit character is\n        carriage return.\n\nLock Statement\n\n   \u003clock statement\u003e ::= LOCK\n\n        Semantics: The \u003clock statement\u003e causes the system to prevent any\n        user or process but the process to which the user is currently\n        attached from sending messages to the user's terminal.\n\nUnlock Statement\n\n   \u003cunlock statement\u003e ::= UNLOCK\n\n        Semantics: The \u003cunlock statement\u003e reverses the action of a\n        previous \u003clock statement\u003e.\n\nAssign Statement\n\n   \u003cassign statement\u003e ::= ASSIGN \u003cassign device\u003e \u003cq\u003e\n\n   \u003cassign device\u003e    ::= LP | DT | CP\n\n        Semantics: The \u003cassign statement\u003e causes the system to attempt\n        to assign a device not currently in use to the user.  The \u003cq\u003e\n        construct has the same meaning as for the \u003clink statement\u003e.\n\nLabel Statement\n\n   \u003clabel statement\u003e ::? LABEL DT \u003cdevice number\u003e \u003ctape label\u003e\n\n        Semantics: The \u003clabel statement\u003e causes the system to write a\n        new label on the DEC tape specified.\n\n\n\n\n\n\n\n\n\nBouknight, et al.                                              [Page 14]\n\f\nRFC 76         Connection-By-Name: User-Oriented Protocol   October 1970\n\n\nCreate Statement\n\n   \u003ccreate statement\u003e ::= CREATE \u003ctape file name\u003e ON \u003ctape label\u003e\n\n        Semantics: The \u003ccreate statement\u003e causes the system to create a\n        new file named \u003ctape file name\u003e on the DEC tape labeled \u003ctape\n        label\u003e.\n\nPurge Statement\n\n   \u003cpurge statement\u003e ::= PURGE \u003ctape label\u003e |\n\n                         PURGE \u003ctape file name\u003e ON \u003ctape label\u003e\n\n        Semantics: The \u003cpurge statement\u003e causes the system to delete all\n        tape directory information on the DEC tape or tape file\n        specified.\n\n\n           [ This RFC was put into machine readable form for entry ]\n            [ into the online RFC archives by Gottfried Janik 2/98 ]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBouknight, et al.                                              [Page 15]\n\f\n"
}