{
  "series": "Request for Comments",
  "number": "203",
  "howpublished": "RFC 203",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0203",
  "url": "https://www.rfc-editor.org/info/rfc203",
  "title": "Achieving reliable communication",
  "pagetotal": "4",
  "year": "1971",
  "month": "aug",
  "body": "\n\n\n\n\n\nNetwork Working Group                                           R. Kalin\nRequest for Comments: 203                                MIT Lincoln Lab\nNIC: 7168                                                 10 August 1971\n\n\n                    Achieving Reliable Communication\n\n   'This material has not been reviewed for public release and is\n   intended only for use with the ARPA network.  It should not be quoted\n   or cited in any publication not related to the ARPA network.'\n\nABSTRACT\n\n   A non-standard protocol, suitable for either second or third level\n   use, is proposed with the intent of providing error resistant and\n   highly reliable communication channels.  Errors introduced by message\n   garbling, message loss, and message pickup are considered.  Measures\n   for increasing throughput are also discussed.\n\nAIMS AND LIMITATIONS\n\n   It is not our intent to propose the design of a perfect communication\n   channel, rather it is our contention that in the real world there can\n   be no perfect channels and that no amount of protocol can insure the\n   error free transfer of information.  Our goal is to explicate the\n   various types of errors that are possible and to provide for each\n   techniques of detection and recovery that, at a cost, can be made\n   arbitrarily good.  In this way the mean time between undetected\n   errors can be made as large as necessary.\n\nERROR TYPES AND DETECTION\n\n   Over a message switching facility, such as the ARPA network, all\n   transmission errors can be divided into two classes -- those that\n   result in the loss of an expected message, and those that result in\n   the picking up of an unexpected message.  A single bit inversion can\n   cause errors of both types.  Error detection can therefore be divided\n   into two components -- one which attempts to determine if the message\n   just received is appropriate at that time, and another which attempts\n   to determine if a message has been lost.\n\n   The detection of garbled input messages has been adequately covered\n   by classical coding ( elsewhere, mistakenly termed 'communication' )\n   theory.   Internal message consistency can be determined through the\n   use parity bits, checksum fields, or any of the various coding\n   techniques available for adding some measure of redundancy.  With\n   relative simplicity, the likelyhood of an undetected error of this\n   type can be made small enough so as to become inconsequential.\n\n\n\nKalin                                                           [Page 1]\n\f\nRFC 203             ACHIEVING RELIABLE COMMUNICATION      10 August 1971\n\n\n   Because it is adequately covered elsewhere, no further discussion\n   shall be given here.\n\n   The detection of a message's external consistency, whether or not it\n   can possibly follow the message that arrived just before it, can also\n   be straight forward.  Sequence numbers, if used, can be easily\n   checked.  A modulo N sequence field will allow detection of up to N-1\n   successive message losses.  If several concurrent links are in use\n   then sequencing can be maintained for each link.  Multi-link single\n   sequence schemes are more complicated and, although used between IMPs\n   for transmission of message packets, they shall be ignored here.\n\n   The detection by a receiving host of a lost message can not be\n   determined directly, but rather must be inferred from other\n   observations.  Any automatic correction scheme must be prepared to\n   handle the possibility of faulty inference.  Message loss would\n   normally be inferred upon the arrival of a message that should follow\n   the one expected.  It might also be inferred by the fact that the\n   message expected is long overdue.\n\nERROR CORRECTION\n\n   If a BCH or other error correcting code is used for transmission,\n   errors detected in a message's internal consistency can sometimes be\n   corrected by the receiving host.  In the event that this is not\n   possible, the content of the message is of little use because it can\n   not be relied upon.  The only reasonable solution is that of\n   discarding the message and relying upon the recovery procedures\n   implemented for lost messages.\n\n   Errors of external consistency can also be treated in the same way.\n   The message can be thrown away and the techniques for recovering lost\n   messages relied upon.  Over a critical channel, a slightly fancier\n   technique can at times save some retransmissions.  If message N is\n   expected, but message N+1 arrives, there is no need to throw away\n   message N+1 and then recover two messages, it could be saved, and\n   only message N retransmitted.\n\n   On noisy channels the technique of saving out of sequence messages\n   can be used to some advantage, especially if recovering from a lost\n   message requires several messages of overhead.  On the ARPA network,\n   the measured error rate is so low that its advantages are outweighed\n   by the increase in resident coding.\n\nRECOVERING LOST MESSAGES\n\n   The simplest technique I know of for recovering lost can be defined\n   by the following rules:\n\n\n\nKalin                                                           [Page 2]\n\f\nRFC 203             ACHIEVING RELIABLE COMMUNICATION      10 August 1971\n\n\n   1) All undiscarded messages have reply messages.\n   2) Messages with coding errors that can not be corrected are\n      discarded.\n   3) The receiver can determine if a message is in sequence.\n   4) Messages received that are out of sequence are discarded.\n   5) If no reply message is received in N time units since the last\n      transmission, the last message sent is retransmitted ( space need\n      not be isochronic ).\n   6) A new message is not sent until the reply for the last one has\n      been received.\n\n   The above protocol, if run, is highly effective for continuous\n   communication.  Since by rule 6) only one message can be in transit\n   at a time, the necessary sequencing information can be contained in a\n   single bit.  Unmodified, it is not suitable for finite communication,\n   since rules 1) and 5) guarantee that there will be no 'last message'.\n   The protocol also does not make very effective use of a pipelined\n   channel, since there is only one message being sent at a time.\n\n   Channel throughput can be increased by several techniques, the first\n   of which would be to disassemble the data stream into several ( eg.\n   four or eight ) streams, transmit each using the above protocol, and\n   then reassemble the streams at the far end.  Another technique is to\n   modify rules 5) and 6).\n\n   5a)   If no reply has been received to message M in N time units\n         since the last transmission, then messages M, M+1,... are\n         retransmitted.\n\n   6a)   There must be no more than L outstanding unreplied messages.\n\n   With L equal to one, this protocol degenerates into the first\n   protocol.  Increasing L increases throughput until the gain is\n   outweighed by the time spent in error recovery.  The larger L, the\n   costlier error recovery.  The value of N should be adjusted so that\n   the reply time for a message is usually less than N plus the time to\n   send L-1 messages.  Increasing N too much will have the effect of\n   lowering the response time to errors.  Decreasing N increases the\n   probability initiating unnecessary retransmissions.\n\nA CRITICAL RACE\n\n   The above protocols leave unresolved the the particulars of starting\n   and stopping a finite transmission.  In opening a communication\n   channel, what is the sequence number of the first message sent?  What\n   will be the first sequence number of the first message sent?  What\n\n\n\n\n\nKalin                                                           [Page 3]\n\f\nRFC 203             ACHIEVING RELIABLE COMMUNICATION      10 August 1971\n\n\n   will be the first sequence number of the first reply received?  At\n   the end of transmission, how does one signal the 'last message'?  The\n   following two rules are introduced:\n\n   7) If the same message has been received K times ( eg. 50 ), then it\n      should be accepted as being 'in sequence'.  The expected\n      sequencing should be adjusted accordingly.  K identical reply\n      messages are then sent.\n\n   8) If no reply has been received in J seconds, then the\n      retransmission of the last unreplied message should cease.\n\n   With these additional rules a finite transmission is started by\n   repeatedly transmitting the first message until K identical reply\n   messages are received.  Sequencing is adjusted accordingly and then\n   subsequent messages can be sent.  A conversation is broken by\n   quitting transmission after the reply to the last message you care\n   about has been received.  Eventually the other end will stop\n   resending the reply.  To avoid ambiguity, the variable J should be\n   less than N times K.  Problems will arise if the network crashes for\n   J seconds, for there is a race condition over whether or not the lack\n   of a reply is the result of a channel failure or the end of a\n   conversation.\n\n\n         [ This RFC was put into machine readable form for entry ]\n             [ into the online RFC archives by Ryan Kato 6/01]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nKalin                                                           [Page 4]\n\f\n"
}