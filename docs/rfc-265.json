{
  "series": "Request for Comments",
  "number": "265",
  "howpublished": "RFC 265",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0265",
  "url": "https://www.rfc-editor.org/info/rfc265",
  "title": "The File Transfer Protocol",
  "pagetotal": "12",
  "year": "1971",
  "month": "nov",
  "body": "\n\n\n\n\n\nNetwork Working Group                             17 November 1971\nRequest for Comments #265                         Abbay Bhushan, MIT\nNIC 781                                           Bob Braden, UCLA\nCategories D.4, D.5, and D.7                      Will Crowther, BBN\n                                                  Eric Narslem, Rand\nObsoletes: 172                                    John Heafner, Rand\n                                                  Alex McKenzie, BBH\n                                                  John Melvin, SRI\n                                                  Bob Sundberg, Harvard\n                                                  Dick Watson, SRI\n                                                  Jim White, UOSB\n\n\n                       THE FILE TRANSFER PROTOCOL\n\n    This Paper is a revision of RF 172, Mic 6794. The changes\nto RFC 172 are given below. The protocol is then restated for\nyour ocnvenience.\n\n                           CHANGES TO RFC 172\n\n1) Two new file transfer requests have been added. These are\n\n2) The op code assignements in control transactions have been\nchanged to include the above requests.\n\n3) Two new error codes indicating 'incorrect or missing\nindentifier' and 'file already exists' have been added. New error\ncode assignements reflect this change.\n\n4) Editorial changes to clarify specifications.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                                [Page 1]\n\f\nFile Transfer Protocol          RFC 265                 17 November 1971\n\n\nI. INTRODUCTION\n\n    The file transfer protocol (FTP) is a userlevel procotocol for\nfile transfer between host computers (including terminal IMPs), on the\nARPA computer network (ARPANET). The primary function of FTP is to\nfacilitate transfer of files between hosts and to allow convenient use\nof storage and file handling capabilities of remote hosts. FTP uses\nthe Data Transfer Protocol described in RFC 264 to achieve transfer of\ndata. This paper assumes knowledge of RFC 264.\n\n    The objectives of FTP are to promote sharing of files (computer\nprograms and/or data) encourage implicit (without explicit login) use\nof computers, and shield the user from variations in file and storage\nsystems of different hosts. These objetives are achieved by specifying\na standard file transfer socket and initial connection protocol for\nimplicit use, and using standard conventions for file transfer and\nrelated operations.\n\nII. DISCUSSION\n\n    A file is considered here to be an ordered set of arbitrary\nlength, consisting of computer data (including programs). Files are\nuniquely identified in a system by their pathnames. A pathname is\n(loosely) defined to be the data string which must be input to the\nfile system by a network user in order to identify a file. Pathname\nusually contains device and/or directory names, and file name. FTP\nspecifications provide standard file system commands, but do not\nprovide standard naming convention at this time. Each user must follow\nthe naming convention of the file system be wishing to use. FTP may be\nextended later to include standard conventions of pathname structures.\n\n    A file may or may not have access control associated with it The\naccess controls designate users access privileges. In absence of\naccess controls, files cannot be protected from accidental or\nunauthorized usage. It is the prerogative of a serving file system to\nprovide protection, and selective access.  FTP provides identifier and\npassword mechanisms for exchange of access control information. it\nshould however ve noted, that for file sharing, it is necessary that a\nuser be allowed (subject to access controls) to access files not\ncreated by him.\n\n    FTP does not restrict the nature of information in files.  For\nexample, a file could contain ASCII text, binary data, computer\nprogram, or any other information. A provision for indicating data\nstructure (type and byte size) exists in FTP to aid in parsing,\ninterpretation, and storage of data.\n\n\n\n\n\n                                                                [Page 2]\n\f\nFile Transfer Protocol          RFC 265                 17 November 1971\n\n\n    To facilitate impliict usage, a serving file transfer process my\nbe a disowned \"demon\" process which \"listens\" to an agreed-upon\nsocket, and follows the standard initial connection protocol for\nestablishing a fill-duplex connection. It should be noted that FTP my\nalso be used directly by logging into a remote host, and arranging for\nfile transfer over specific sockets.\n\n    FTP is readily extendable, in that additional commands and data\ntypes may be defined by those agreeing to implement them.\nImplementation of a subset of commands is specifically permitted, and\nan initial subset for implementation is recommended. (*)The protocol\nmay also be extended to enable remote execution of programs, but no\nstandard procedure is suggested.\n\n    For transferring data, FTP uses the data transfer protocol\nspecified in RFC 264. As the data transfer protool does not specify\nthe manner in which it is to be used by FTP, implementation may vary\nat different host sites. Hosts not wishing to separate data transfer\nand file transfer functions, should take particular care in conforming\nto the data transfer protocol specifications of RFC 264.\n\n    It should be noted that FTP specifications do not require\nknowledge of transfer modes used by data transfer protocol.  However,\nas file transfer protocol requires the transfer of more than a single\ncontrol transaction over the same connection, it is essential that\nhosts be able to send control transactions in either 'transparent\nblock' (type B9) or 'descriptor and counts' (type BA) modes. (Type BS,\nthe indefinite bit stream mode is not suitable as it limits transfer\nto single transactions.).\n\n    The use of data transfer aborts (type B6) is neither required, nor\ndefined in FTP. FTP has its own error terminate wich may be used to\nabort a file transfer request. FTP also does not define to structure\nof files, and there are no conventions on the use of group, record and\nunit separators. (*)A file separator however, indicates the end of a\nfile.\n\n    It is strongly recommended that default options be provided in\nimplementation to facilitate use of file transfer service.  For\nexample, the main file directora on disk, a pool directory, user\ndirectory of diretory last accessed could serve as standard pathname\ndefaults. Default mechanisms are convenient, as the user doesn't have\nto specify the complete pathname each time ve wishes to use the file\ntransfer service. No standard default procedures are specified by FTP.\n\n--------------------------------\n(*)\n    This initial subset represents control functions necessary for\n\n\n\n                                                                [Page 3]\n\f\nFile Transfer Protocol          RFC 265                 17 November 1971\n\n\nbasic file transfer and \"mail\" operations, and some elementary file\nmanipulation operations. There is no attempt to provide a data\nmanagement or complete file management cpability.\n(*)\n    It is possible that wi may, at a later date, assign meaning to\nthese information separators within FTP.\n\nIII. SPECIFICATIONS\n\n1.  Data Transfer\n\n    FTP uses the Data Transfer Protocol (described in RFC 264)\n    for transferring data and/or control transaction. Both data\n    and control transactions are communicated over the same\n    connection.\n\n2.  Data Transactions\n\n    Data transactions represent the data contained in a file.\n    There is no data type or byte size information contained in\n    data transactions. The structure of data communicated via\n    control transactions. A file may be transferred as one or\n    more data transactions. The protocol neither specifies nor\n    impose any limitations on the structure (record, group, etc)\n    or length of file. Such limitations may however be imposed\n    by a serving host. the end of a file may be indicated by a\n    file separator (as defined in data transfer protocol). In\n    the special case of indefinite bit-stream transfer mode (Type\n    B0), the end of file is indicated by closing connection. In\n    particular, a serving or usin host should not send the ETX,\n    or other end of file character, unless such a character is\n    part of the data in file (i.e. not provided by system).\n\n3.  Control Transactions\n\n    The control transactions may be typified as requests,\n    identifiers, and terminates. A request fulfillment sequence\n    begins with a request and ends with receipt of data (followed\n    by end-of-File) or a terminate. The user side initiates the\n    connections as well as the request. The server side \"listens\"\n    and complies with the request.\n\n3A. Op Codes\n\n    The first information (i.e., not descriptor) byte or control\n    transactions indicates the control function. This byte is\n    referred to as \"opcode\". A standard set of opcodes are\n    defined below. The operations are discussed in Section 2B.2.\n\n\n\n                                                                [Page 4]\n\f\nFile Transfer Protocol          RFC 265                 17 November 1971\n\n\n    Implementation of a workable subset (*) of opcodes is\n    specifically permitted. Additional standard opcodes may be\n    assigned later. Opcodes hex 5A (octal 100) through hex FF\n    (octal 377) are for experimental use.\n\n     Op Code                          Operation\n    Hex   Octal\n\n    00    000                  Set data type identifier\n\n    01    001                  Retrieve Request\n\n    02    002                  Create request (write file; error ir\n                               file already exits)\n\n    03    003                  Store request (write file; replace\n                               if file already exists)\n\n    04    004                  Append request (add to existing file;\n                               error if file does not exist)\n\n    05    005                  Append_with_create request (add to\n                               file; create if file does not exist)\n\n    06    006                  Delete request (delete file)\n\n    07    007                  Rename_from request (change file name)\n\n    08    010                  Rename_to request (the new file name)\n\n    09    011                  List request (list information)\n\n    0A    012                  Username identifier (for access control)\n\n    0B    013                  Password identifier (for access control)\n\n    0C    014                  Error of unsuccessful terminate\n\n    0D    015                  Acknowledge or successful terminate\n\n    0E    016\nthrough  through               Reserved for standard assignment\n    4F    077\n\n    5A    100\nthrough  through               Assigned for experimental use\n    FF    377\n\n\n\n\n                                                                [Page 5]\n\f\nFile Transfer Protocol          RFC 265                 17 November 1971\n\n\n------------------------------------\n(*)\n    A workable subset is any request, plus terminates.  Indentifiers\nmay be required in addition for usin \"protected\" file systems.\n\n3B. Syntax and Semantics\n\n3B.1 Data Types\n\n    The 'set data type' control transactions indentifies the structure\n    of data (data type and byte size) is succeeding data transactions.\n    The 'set data type' transaction shall contain two more bytes in\n    addition to the opcode byte. The first of these bytes shall convey a\n    data type or code information and the second byte may convey the\n    data byte size, where applicable. this information may be used to\n    define the manner in which data is to be parsed, interpreted,\n    reconfigured or stored. Set data type need be sent only when\n    structure of data is changed from the preceding.\n\n    Although, a number of data types are defined, specific\n    implementations may handle only limited data types or completely\n    ignore the data type and byte size descriptors.  Even if a host\n    process does not \"recognize\" a data type, it must accept data (i.e.,\n    there is no such thing as data type error.) These descriptors are\n    provided only for convenience, and it es not essential that they be\n    used. The standard default is to assume nothing about the\n    information and treat it as a bit stream (binary data, byte size\n    1)(*)whose interpretation is left to a higher level process, or the\n    user.\n\n    The following data type codes are currently assigned. Where a byte\n    size is not implicit in data type, it may be provided by the second\n    byte.\n\n-----------------------------------\n    (*)\n   It is, however, possible that this bit stream is treated like ASCII\ncharacters in specific instances such as transmitting a file to a line\nprinter.\n\n\n\n\n\n\n\n\n\n\n\n\n                                                                [Page 6]\n\f\nFile Transfer Protocol          RFC 265                 17 November 1971\n\n\n      Code          Implicit          Data Type\n  Hex    Octal      Byte Size\n\n  00     000           1             Bit stream (standard default)\n\n  01     001         none            Binary data bytes\n\n  02     002           8             Network ASCII characters\n\n  03     003           8             EBCDIC characters\n\n  04     004          36             DEC-packed ASCII (five 7-bit\n                                     characters, 36th bit 1 or 0)\n\n  05     005           8             Decimal numbers, net. ASCII\n\n  06     006           8             Octal numbers, net. ASCII\n\n  07     007           8             Hexadecimal numbers, net. ASCII\n\n  08     010\nthrough  through                     Reserved for standard assignemt\n  4f     077\n\n  5A     100\nthrough  through                     Assigned for experimental use\n  FF     377\n\n3B.2 Requests and Identifiers\n\n    Retrieve, create, append, append_with_create, delete, rename_from,\n    and rename_to requests must contain a pathname specifying a file,\n    following the opcode in the information field. In the list request a\n    pathname may or may not follow the opcode. If present, the pathname\n    may specify either a file or a directory.\n\n    A file pathname must uniquely identify a file in the serving host.\n    The syntax of pathnames and identifying information shall conform to\n    serving host conventions, except that standard network ASCII (7-bit\n    ASCII right justified in 8-bit) field with most signifcant bit as\n    zero) shall be used.\n\n    The store request has a 4-byte (32 bits) 'allocate size' field\n    followed by a pathname specifying a file. 'Allocate size' indicates\n    the number of bits of storage to be allocated to the file. An\n    allocate size of zero indicates that server should use his default.\n\n\n\n\n\n                                                                [Page 7]\n\f\nFile Transfer Protocol          RFC 265                 17 November 1971\n\n\n    Retrieve request achieves the transfer of a copy of file specified\n    in pathname, from serving to using host. the status and contents of\n    file in serving host should be unaffected.\n\n    Create request causes a file to be created at the serving host as\n    specified in pathname,  A copy of the file is transferred from the\n    using to the serving host. If the file specified in pathname already\n    exists at the serving host, an error terminate should be sent by the\n    server.\n\n    Store request achieves the transfer of copy of file from using to\n    serving host. If file specified in pathname exists on serving hosts,\n    then its contents shall be replaced by the contents of the file\n    being transferred. A new file is created at the serving host if the\n    file specified in pathname does not exist.\n\n    Append request achieves the transfer of data from using to serving\n    host. The transferred data is appended to file specified in\n    pathname, at serving host. If the specified file does not exist at\n    serving host, an error terminate should be sent by the server.\n\n    Append with create request achieves the transfer of data from using\n    to serving host. If file specified is pathname exists at serving\n    host, then the transferred data is appended to that file, otherwise\n    the file specified in pathname is created at the serving host.\n\n    Rename from and rename to requests cause the name of the file\n    specified in pathname of rename_from to be changed to the name\n    specified in pathname of rename_to. A rename_from request must\n    always be followed by a rename_to request.\n\n    Delete request causes file specified in pathname to be deleted from\n    the serving host. If an extra level of protection is desired such as\n    the query \"Do you really wish to delete this file?\", it is to be a\n    local implementation option in the using system. Such queries should\n    not be transmitted over network connections.\n\n    List request causes a list to be sent from the serving to using\n    host. If there is no pathname of if pathname is a directory, the\n    server should send a file directory list. If the pathname specifies\n    a file then server should send current information on the file.\n\n    Username and password identifiers contain the respective identifying\n    information. Normally, the information will be supplied by the user\n    of the file transfer service. These identifiers will normally be\n    sent at the start of connetion for access control.\n\n\n\n\n\n                                                                [Page 8]\n\f\nFile Transfer Protocol          RFC 265                 17 November 1971\n\n\n3B.3  Error and Acknowledge Terminates\n\n    The error transactions may have an error code indicated by the\n    second information byte. Transmission of an ASCII error message in\n    subsequent bytes is permitted with all error codes, except that with\n    Hex '0A' error code, ASCII text is required. The errors here relate\n    to file transfer functions only. Data synchronization and related\n    errors in data transfer are to be handled at the DTP level. The\n    following error codes are currently defined:\n\n    Error Code (2nd descriptor byte)      Meaning\n   Hex     Octal\n   00      000                Error condition indicated by\n                              computer system (external to protocol)\n   01      001                Name syntay error\n   02      002                Access control violation\n   03      003                Abort (by user)\n   04      004                Allocate size too big\n   05      005                Allocate size overflow\n   06      006                Improper order for transactions\n   07      007                Opcode not implemented\n   08      010                File search failed\n   09      011                Incorrect or missing identifier\n   0A      012                Error described in text message\n                              (ASCII characters follow code)\n   0B      013                File already exists (in create request)\n\n    At present, no completion codes are defined for acknowledge,\n    It is assumed that acknowledge refers to the current request\n    being fulfilled.\n\n4.  Order of transactions\n\n4A. A certain order of transactions must be maintained in\n    fulfilling file transfer requests. The exact sequence in\n    wich transactions occur depends on the type of request, as\n    described in action 4B. The fullfillment of a request may be\n    aborted anytime by either host, as explained in section 4C.\n\n4B. Identifier transactions (set data type, username, and\n    password) may be sent by user at any time. The usual order\n    would be a username transaction followed by a password\n    transaction at the start of the connection. No acknowledge\n    is required, or permitted. The identifiers are to be used\n    for default handling, and access control.\n\n\n\n\n\n\n                                                                [Page 9]\n\f\nFile Transfer Protocol          RFC 265                 17 November 1971\n\n\n    Retrieve and list requests cause cause the transfer of file from\n    server to user. After a complete file has been transferred, the\n    server should indicate end-of-file (by sending CLS or file\n    separator) to complete the request fulfillment sequence, as shown\n    below.\n\n                    Retrieve / List requests\n                  -----------------------------\u003e\n\n    User                 \u003c File -- Data\u003e            Server\n                  \u003c-----------------------------\n                    End of file indication\n                  \u003c-----------------------------\n\n    Store, create, append, and append_with_create requests cause\n    the transfer of file from user to server. After a complete\n    file has been transferred, the user should send an\n    end-of-file indication. The receipt of the file must be\n    acknowledged by the server, as shown below.\n\n           Create / Store / Append / Append_with_create requests\n                  -----------------------------\u003e\n    User                 \u003cFile --- Data\u003e            Server\n                  -----------------------------\u003e\n                   End of file indication\n                  -----------------------------\u003e\n                    Acknowledge\n                  \u003c-----------------------------\n\n    Rename_from request must be followed by a rename_to request.\n    The request must be acknowledged as shown below.\n\n    User              Rename_from request           Server\n                  -----------------------------\u003e\n                      Rename_ro request\n                  -----------------------------\u003e\n                      Acknowledge\n                  \u003c-----------------------------\n\n    The delete request requires the server to acknowledge it, as\n    shown below.\n\n\n\n\n\n\n\n\n\n\n                                                               [Page 10]\n\f\nFile Transfer Protocol          RFC 265                 17 November 1971\n\n\n    User                   Delete                   Server\n                  -----------------------------\u003e\n                      Acknowledge\n                  \u003c-----------------------------\n\n    Error transactions my be sent by either host at any time,\n    and these terminate the current request fulfillment sequence.\n\n4C. Aborts. Eithe host may abort a request fulfillment sequence\n    at any time by sending an error terminate, or by closing the\n    connection (NCP to transmit a CCLS for the connection). CLS\n    is a more drastic type of abort and shall be used when there\n    is a catastrophic failure, or when abort is desired in the\n    middle of a long transaction. The abort indicates to the\n    receiving host that sender of abort wishes to terminate\n    request fulfillment and is now ready to initiate ar fulfill\n    new requests. When CLS is used to abort, the using host will\n    he responsible for reopening connection. The file transfer\n    abort described here is different form data transfer\n    abort which is sent only by the sender of data. The use of\n    the data transfer is not defined in this protocol.\n\n5.  Initial Connection, CLS, and Access Control\n\n5A. Socket 3 is the standard preassigned socket number on which\n    the cooperating file transfer process at the serving host\n    should \"listen\". (*)The connection establishment will be in\n    accordance with the standard initial connection\n    protocol, (*)establishing a full-duplex connection.\n\n5B. The connection will be broken by trading a CLS between the\n    NCP's for each of the two connections. Normally, the user\n    will initiate CLS.\n\n    CLS may also be used by either user or server, to abort a\n    transation in the middle. If CLS is received in the middle\n    of transaction, the current request fulfillment sequence will\n    be aborted. The using host will then reopen connection.\n\n5C. It is recommended that identifier (user name and password)\n    transactions be sent by user to server, at the start, as this\n    would facilitate default handline and access control for the\n    entire duration of connection. Some service sites may\n    require the indentifier transactions. The identifier\n    transactions do not require or permit an acknowledge, and the\n    user can proceed directly with requests. If the identifier\n    information is incorrect or not received, the server may send\n    an error transaction indicating access control, violation,\n\n\n\n                                                               [Page 11]\n\f\nFile Transfer Protocol          RFC 265                 17 November 1971\n\n\n    upon subsequent requests.\n\n    ---------------------------------\n    (*)\n       Socket 1 has been assigned to logger, socket 3 seems a\n    reasonable choice for File Transfer.\n\n    (*)\n       RFC 165, or any subsequent standard applicable in initial\n    connection to loggers.\n\n         [ This RFC was put into machine readable form for entry ]\n          [ into the online RFC archives by Gottfried Janik 7/97 ]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                               [Page 12]\n\f\n"
}