{
  "series": "Request for Comments",
  "number": "107",
  "howpublished": "RFC 107",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0107",
  "url": "https://www.rfc-editor.org/info/rfc107",
  "title": "Output of the Host-Host Protocol Glitch Cleaning Committee",
  "pagetotal": "12",
  "year": "1971",
  "month": "mar",
  "body": "\n\n\n\n\n\nNetwork Working Group\nRequest for Comments # 107\n\nNIC # 5806\n\n\n\n\n\n\n\n\n                    Output of the Host-Host Protocol\n                       Glitch Cleaning Committee\n\n\n\n\n\n                                  UCLA\n                             23 March 1971\n\n\n\n\n\n                            Robert Bressler\n                             Steve Crocker\n                            William Crowter\n                             Gary Grossman\n                             Ray Tomlinson\n                              James Withe\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                                [Page 1]\n\f\nIntroduction\n\nThe Host-Host Protocol Glitch Cleaning Committee met for the second\ntime at UCLA on 8, 9 March 1971, after canvassing the network com-\nmunity.  [The result of the (slightly larger) committee's first\nmeeting are documented in RFC #102.]  The committee agreed on\nseveral modifications to the protocol in Document #1; these modi-\nfications are listed below.\n\nAt each of the meeting, the committee quickly treated all but one\nof the extant topics.  At the first meeting, the bulk of time was\nspent considering the interrupt mechanism, and that discussion is\nsummarized in RFC #102.  At the second meeting, the committee spent\nalmost all of its time discussing the notion of bytes; this dis-\ncussion is summarized after the list of modifications.\n\nThis RFC entirely supercedes RFC #102, and is an official modi-\nfication of Document #1.  A revision of Document #1 will be written\nshortly which incorporates the changes listed here.\n\n\nNCP implementers are to incorporate these changes as soon as\npossible.  NCP implementers also are to estimate on what date\ntheis NCP's will be ready and to communicate this estimate to\nSteve Crocker or his secretary, Byrna Kristel.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                                [Page 2]\n\f\nModifications\n\n\nI Bytes\n\nHeretofore, a connection has been a bit stream.  Henceforth, it is to\nbe a byte stream, with the byte size, S, indicated in the STR command\nand in each message.  The byte size meets the constraints: 1 \u003c= S \u003c=\n255.\n\nThe choice of the byte size for a connection is a 3rd level protocol\nissue, but the size is constant for the life of a connection.  Each\nmessage must contain an integral number of text bytes (see below).\n\n\nII Message Format\n\nThe message format is changed to the format shown in figure 1.\n\nThe fields S and C are the byte size and byte count, respectively.\nThe S field is 8 bits wide and must match the byte size specified in\nthe STR which created the connection.  The C field is 16 bit long and\nspecifies the number of bytes in the text portion of the message.  A\nzero value in the C field serves no purpose, but is explicitly\npermitted.\n\nThe M1 and M2 field are each 8 bits long and must contain zero.  The\nM3 field is zero or more bits long and must be all zero.  The M3 may\nbe used to fill out a message to a word boundary.  It is followed by\npadding.\n\nThe text field consists of C bytes, where each byte is S bit long.\nThe text field starts 72 bits after the start of the message.\n\n   The partition of a byte stream into messages is an artifact\n   required by the subnet.  No semantic contents be attacched\n   to message boundaries. In particular,\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                                [Page 3]\n\f\n                              32 bits\n                |\u003c---------------------------------\u003e|\n\n\n                +-----------------------------------+\n                |                                   |\n                |              leader               |\n                |                                   |\n                +--------+--------+-----------------+\n                |        |        |                 |\n                |   M1   |    S   |        C        |\n                |        |        |                 |\n                +--------+--------+-----------------+\n                |        |        ^                 |\n                |   M2   |        |                 |\n                |        |        |                 |\n                +--------+        |                 |\n                |                 |                 |\n                |                 |                 |\n                |                                   |\n                |                Text               |\n                //                                 //\n                |                 |                 |\n                |                 |                 |\n                |                 |                 |\n                |                 |                 |\n                |                 |        +--------+\n                |                 |        |        |\n                |                 |        |   M3   |\n                |                 v        |        |\n                +-----------------+--------+--------+\n                |                 |\n                |  10 --------- 0 | \u003c-- Padding\n                |                 |\n                +-----------------+\n\n                            Typical Message\n\n                                Figure 1\n\n\n\n\n\n\n\n\n\n\n\n\n                                                                [Page 4]\n\f\n1.  A message with a zero value for C has no meaning, although\n    it is legal and it does use up resource allocation.  (See\n    Flow Control below.)\n\n2.  A receiver may not expect to see 3rd level control infor-\n    mation synchronized with message boundaries.  Particuralrly,\n    if the notion of record is defined for a connection, the\n    receiver must expect multiple records and/or record frag-\n    ments within one message.  (However, control message obey\n    special rules.  See below.)\n\n\nIII Message Data Types\n\nNo notion of data type is defined as part of the 2nd level pro- tocol.\n3rd level protocols may include the notion. Data types cannot be\nsynchronized on message boundaries.\n\n\nIV Reset and Reset Reply\n\nA new pair of one bit control commands RST (reset) and RRP (reset\nreply) are added.  The RST is interpreted as a signal to purge the NCP\ntables of all existing entries which arose from the Host which sent to\nRST.  The Host receiving the RST acknowledges by returning a RRP.  The\nHost sending the RST may proceed to request connection after receiving\neither a RST or RRP in return.  An RST is returned if the second Host\ncomes up after the first Host.\n\n\nV Flow Control\n\nThe flow control techniques are changed in two ways.  First, the Cease\nmechanism is discontinued.  The 10HI and 11HI message will no longer\nbe recognized by the Imps, and the Imps will no loger generate the\n10HI, 11HI or 12HI messages.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                                [Page 5]\n\f\nSecond, the allocation mechanism now deals with two quantities, bits\nand messages.  The receiver allocates each of these quantities\nseparately.  The sender and receiver each must mantain a 16 bit\nunsigned counter for message and a 32 bit unsigned counter for bits.\nWhen sending a message, the sender subtract one from the message\ncounter, and the text length from the bit counter. The receiver\ndecrements his counter similarly when receiving the message.  The\nsender is prohibited from sending if either counter would be decre-\nmented below zero.  Similarly, the receiver is prohibited from raising\nthe current message allocation above 2**16 - 1, or the current bit\nallocation above 2**32 - 1.\n\nThe TEXT LENGTH of a message is the product of S, the byte size, and\nC, the number of bytes.  These values always appear in the first part\nof the message, as described under Message Format.\n\n\nThe ALL, GVB, and RET command are modified to treat two quantities.\nTheir formats are given under Control Command, below. The GVB command\nis further modified to make it possible to ask for none of the\nallocation to be returned.  The new GVB command has four eight bit\nfields.  The first two fields are the op code and the link, as before.\nThe next two fields contain number fM and fB which control how much of\nmessage and a bit allocation are to be returned.  Each of these\nnumbers is interpreted as \"the number of 128ths of the current\nallocation\" to be returned if it is in the range of 0 to 128, and is\nto be interpreted as \"all of the current allocation\", if it is in the\nrange 128 to 255.\n\n\nVI Control Message\n\nThe control link is chsnged to link 0; link 1 is not to be used.  The\nold and new protocols may thereforre coexist.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                                [Page 6]\n\f\nMessage sent over the control link have the same format as other\nregular messages, as described above under Message Format.  The byte\nsize field must contain the value 8.\n\nControl messages may not contain more tha 120 byte of text; the\nvalue in the byte count field is thus limited to 120.  This limi-\ntation is intended to help smaller hosts.\n\nControl messages must contain an integral number of control commands.\nControl commands, therefore, may not be split across control messages.\n\n\nVII Link Assignment\n\nThe link are now assigned as follows:\n\n   0          control link\n   1          old protocol's control link - to be phased out\n   2 - 31     links for connections\n   32 - 190   reserved -- not for current use\n   191        to be used only for measurement work under direction\n               of the network measurement center (UCLA)\n   192 - 255  available for any private experimental use.\n\n\nVIII Fixed Length Control Commands\n\nThe ECO, ERP and ERR commands are now fixed length.  The ECO and ERP are\nnow 16 bit long -- 8 bits of op code and 8 bits of data. The ERR command\nis now 96 bits long -- 8 bits of op code, 8 bits of error code, and 80\nbits of text. 80 bits is long enough to hold the longest non-ERR control\ncommand.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                                [Page 7]\n\f\nIX Control Command Formats\n\nAs mentioned above, the formats of the STR, ALL, GVB, RET, ECO, ERP and\nERR commands have changed; and the commands RST and RRP have been added.\nThe formats of these commands are given here.\n\n      |  8  |          32           |          32           |  8  |\n      +-----+-----------------------+-----------------------+-----+\n      |     |                       |                       |     |\n1.    | STR | send socket           | receive socket        |     |\n      |     |                       |                       |  ^  |\n      +-----+-----------------------+-----------------------+--|--+\n                                                               |\n      |  8  |  8  |   16      |           32          |        +-- byte size\n      +-----+-----+-----------+-----------------------+\n      |     |     |           |                       |\n2.    | ALL | link| msg space | bit space             |\n      |     |     |           |                       |\n      +-----+-----+-----------+-----------------------+\n\n      |  8  |  8  |   16      |           32          |\n      +-----+-----+-----------+-----------------------+\n      |     |     |           |                       |\n3.    | RET | link| msg space | bit space             |\n      |     |     |           |                       |\n      +-----+-----+-----------+-----------------------+\n\n      |  8  |  8  |  8  |  8  |\n      +-----+-----+-----+-----+\n      |     |     |     |     |\n4.    | GVB | link|  fM |  fB |\n      |     |     |  ^  |  ^  |\n      +-----+-----+--|--+--|--+\n                     |     |\n                     |     +-- bit fraction\n                     +-------- message fraction\n\n      |  8  |  8  |\n      +-----+-----+\n      |     |     |\n5.    | ECO |data |\n      |     |     |\n      +-----+-----+\n\n\n\n\n\n\n\n\n                                                                [Page 8]\n\f\n      |  8  |  8  |\n      +-----+-----+\n      |     |     |\n6.    | ERP |data |\n      |     |     |\n      +-----+-----+\n\n      |  8  |  8  |                       80                        |\n      +-----+-----+---------------------- // -----------------------+\n      |     |     |                                                 |\n7.    | ERR |     |  text                                           |\n      |     |  ^  |                                                 |\n      +-----+--|--+---------------------- // -----------------------+\n               |\n               +-- error code\n\n      |  8  |\n      +-----+\n      |     |\n8.    | RST |\n      |     |\n      +-----+\n\n      |  8  |\n      +-----+\n      |     |\n9.    | RRP |\n      |     |\n      +-----+\n\n\n\nThe values of the op codes are\n\n            NOP   =   0\n            RTS   =   1\n            STR   =   2\n            CLS   =   3\n            ALL   =   4\n            GVB   =   5\n            RET   =   6\n            INR   =   7\n            INS   =   8\n            ECO   =   9\n            ERP   =  10\n            ERR   =  11\n            RST   =  12\n            RRP   =  13\n\n\n\n                                                                [Page 9]\n\f\nDiscussion on Byte Streams\n\nThe previous specification that connections would be conduits of bit\nstreams provided maximum generality and minimum efficiency.  Pressure\nfor greater efficiency developed and the problen was examined.\n\nTwo separate kinds of inefficiency arose from bit streams.\n\n   1.  Receiving Hosts were equired to engage in expensive\n       shifting to concatenate the texts of successive\n       messages.  Sending Hosts often also had to shift text\n       fields to align them on word boundaries.\n\n   2.  Sending NCP's were prohibited from hanging onto ANY\n       text for an indefinite time if it were possible to send\n       even one bit.  This requirement was necessary to prevent\n       possible deadlocks.  For example, suppose processes A\n       and B have a conversation in progress over a pair of\n       connections, one in each directions.  Also suppose that\n       these processes produce exactly one bit of output for\n       each bit of input.  Then if A's NCP fails to send a\n       waiting bit because it wants to pack it together with\n       later output from A, then B will not be able to output\n       and neither will A.  It is clear then, that unless there\n       is some quantitee that the data in the sending NCP's\n       buffers are not crucially needed on the receive side, the\n       sending NCP must assume otherwise and transmit any\n       waiting data as soon as it is able.\n\nThese considerations led to the notion of a \"transmission unit,\" whose\nexistence would be known to the NCP's.  The questions then became what\nwere typical and/or possible transmission unit sizes. For\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                               [Page 10]\n\f\ncharacter-oriented interaction, 8-bit transmission units seemed\nreasonable.  For line-oriented interaction, the transmission unit might\nbest be the line itself, and therefore variable length; alternatively,\nit might be best consider the transmission unit to be a character.  For\nfile transfer, it might be desirable for the transmission unit to be a\nmultiple of the word lengths of both machines; however, the last part of\nthe file may not form a whole transmission unit, if the transmission\nunit is too large.  The consensus became that the transmission unit\nshould not be divisible under any circumstances, and should, therefore,\nbe fairly small.  The notion of transmission unit thus seems to be\nsynonymous with the notation of byte, and the term transmission unit was\ndropped.\n\nSubsequent discussion of the deadlocks and wakeup aspect revealed that\nthere may be two byte sizes associated with a single connection:\n\n   1.  Transmission from the sending process to the sending NCP\n       is in bytes of size S.  The sending NCP must send a\n       message whenever the link is unblocked, the message\n       counter is at least 1, the bit counter is at least S,\n       and the least S bits of text are ready.  The message\n       must contain an integral number of bytes.\n\n   2.  At the receiving side, there may be  a different byte\n       size R for transmission from the receiving NCP to the\n       receiving process.  An example of where R \u003c\u003e S, is\n       suggested by UCSB which is providing a file system for\n       transparently storing binary files.  It is reasonable that\n       a using HOST might send with 36 bit bytes, while the UCSB\n       file system might want to receive 32-bit increments.\n\nIt is clear that from a network protocol point of view, only the byte S\nis relevant, and this is quantity which is communicated in the STR\ncommand in every message.  The choice of the byte size R is up\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                               [Page 11]\n\f\nto the receiving user, and its meaning is how often the receiving NCP\nshould wakeup the receiving process.  It may also happen that a\nreceiving process has an agreement with the receiving NCP which is more\ncomplex than \"please wake me every R bits;\" for example, the NCP might\nscan for new-line characters before waking up the receiving process.\n\nIn the new protocol, it is the option of the receiver to refuse a\nrequest for connection on the basis of the proffered byte size.\nConceptually, we imagine that NCP's are capable of handling all byte\nsizes, and that such a choice would be up to the third level pro- grams\n(user programs, loggers, telnets, etc.)  Some Hosts, small ones in\nparticular, may know enough about their third level programs to restrict\nthe variety of byte sizes which can be sent or received.  While it is a\nmatter of a local policy, the committee strongly suggests that NCP's be\ncapable of handling all byte sizes.  One of our committee, moreover,\nfeels strongly that NCP's should be written to be able to receive all\nbyte sizes S and provide for different byte sizes R for transmission to\nthe user process.\n\n\n\n       [ This RFC was put into machine readable form for entry ]\n        [ into the online RFC archives by Enrico Bertone 4/97 ]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                               [Page 12]\n\f\n"
}