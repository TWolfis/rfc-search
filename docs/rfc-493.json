{
  "series": "Request for Comments",
  "number": "493",
  "howpublished": "RFC 493",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0493",
  "url": "https://www.rfc-editor.org/info/rfc493",
  "title": "GRAPHICS PROTOCOL",
  "pagetotal": "28",
  "year": "1973",
  "month": "apr",
  "day": "1",
  "body": "\n\n\n\n\n\nNetwork Working Group                                        J. Michener\nRequest for Comments: 493                                            MAC\nNIC: 15358                                                     I. Cotton\nReferences: 282, 258                                               MITRE\nObsoletes: 292                                                 K. Kelley\n                                                              U. of Ill.\n                                                               D. Liddle\n                                                              Ownes Ill.\n                                                                E. Meyer\n                                                                     MAC\n\n\n                           GRAPHICS PROTOCOL\n\nIntroduction\n\n   This document reflects opinions expressed and decisions reached at\n   the second meeting of the Network Graphics Group, held at the\n   Stanford Artificial Intelligence Laboratory in late November 1971.\n   It describes part of a proposed Network Standard Graphics Protocol\n   for transmitting graphics data within the ARPA network.  The\n   particular aspects of the protocol covered in this document relate to\n   the form and content of graphics information sent from a source of\n   graphical information (an application program, say, in the \"Serving\n   Host\") to a display package for output to a graphics console (at the\n   \"Using Host\").  This will take the form of a sequence of 8-bit bytes,\n   and will be called the graphics output byte stream.\n\n   This document is intended to serve as a basis for discussion and for\n   experimentation over the network.  This document does not include\n   form or content of graphics input (data sent from the Using Host to\n   the Serving Host) nor does it cover how the connection is established\n   between the hosts.  A proposal for the former will be generated\n   eventually by this committee; the latter is the job of the Connection\n   Committee (of the Network Graphics Group).\n\n   This RFC describes the commands which are available in the protocol\n   in terms of the effect they would have at the receiving (Using Host)\n   end.  Clearly, some subroutine package is desirable at the Serving\n   Host for use by applications in transmitting graphics data, but on\n   this topic this RFC does not intend to comment.\n\n   It may be observed by the reader that no facility is specified in\n   this protocol allowing the Using Host to report logical errors in the\n   graphics output byte stream to the Serving Host.  Such a facility\n   would have to be integrated with the graphics input byte stream,\n   since it involves most of the problems related to synchrony of\n   independent hosts.\n\n\n\nMichener, et. al.                                               [Page 1]\n\f\nRFC 493                    GRAPHICS PROTOCOL               26 April 1973\n\n\nBackground\n\n   The reader should probably peruse RFC 282: \"Graphics Meeting Report\"\n   by Mike Padlipsky to obtain some of the framework surrounding this\n   discussion of network graphics.  Also it might be valuable to make\n   note of the model described in RFC 285: \"Network Graphics\" by Donald\n   Huff.\n\nLevels and Ground Rules Pertaining Thereto\n\n   Functions within the graphics protocol will be classified into a\n   number of levels depending partly on how difficult it is to implement\n   those functions.  It is intended that any host which claims to\n   implement the functions of level N must implement all lower levels as\n   well.  Thus, it is envisioned that sites will implement levels\n   inclemently.  Implementations will be improved as a continuing\n   process to include more and more functions, and it is intended that\n   each implementation will be able to identify its own level to a\n   graphics protocol at a remote site which is requesting a graphics\n   interchange.  A side result is that each site will be able to\n   determine its own priorities in committing programmers to the\n   graphics protocol as opposed to other efforts.\n\n   It is also our intention that implementation of level N will require\n   no knowledge of level N+1.  Thus a site can implement a level in the\n   (reasonably) firm knowledge that no changes at higher levels will\n   alter the level implemented.  At some time it may be decided by the\n   Network Graphics Group to redefine a level which has previously been\n   firmed up.  It is not our intention that this shall happen but one\n   must recognize that the proposed Graphics Protocol is experimental\n   and may have to be changed.\n\n   One further ground rule: a stream of commands and data which is valid\n   at a given level, K, shall produce \"identical\" results on any\n   interpreter of level K or higher.  By this we mean that as long as\n   the commands and data take advantage only of strictly defined\n   operations, similar pictures should result.  Aspects of the protocol\n   which are not strictly defined (at this time) include character size,\n   character position relative to the beam, how control characters in\n   text output affect the terminal and what happens when the beam is\n   moved or a line drawn outside of the logical screen boundary.  This\n   rule forces upwards compatibility, so that an application written\n   using features of a low numbered level will still work at sites which\n   have moved on to implement higher levels.  Additionally, any aspects\n\n\n\n\n\n\n\nMichener, et. al.                                               [Page 2]\n\f\nRFC 493                    GRAPHICS PROTOCOL               26 April 1973\n\n\n   of this protocol which are explicitly \"left unspecified\" in the\n   detailed operations descriptions below shall be explicitly specified\n   in any public description of an actual implementation.\n\n   We now describe the framework which will be common to all levels.\n\nBasic Data Forms\n\n   Information in the Network Standard Graphics Protocol will be\n   expressed as a sequence of 8-bit bytes.  A command will consist of a\n   command byte followed by zero or more arguments.  The same command\n   byte will always take the same number of arguments in the same form.\n   The length of each argument may be fixed or variable depending on the\n   argument.\n\n   A simple type of argument is a \"value\", which is a 8-bit integer.\n   Another type of argument is a \"string\" which is a count followed by\n   (count) number of 8-bit bytes.  If the count is between 0 and 127, it\n   is sent in a single byte.  If the count is between 128 and 2**15-1\n   (**means exponentiation), it is sent in two bytes with the high order\n   bit of the first byte set to one.  The first byte contains the seven\n   high order bits of the number and the second byte contains the eight\n   low order bits.  A string is the only type of argument of a command\n   which can vary in length.  For example, whenever a command has\n   optional arguments, they will be represented inside of a string.\n\n   Coordinate data engendered considerable discussion at the second\n   Network Graphics Group meeting.  It was decided that a two-\n   dimensional Logical Coordinate System was required, and each\n   interpreter for the graphic command byte stream would be responsible\n   for mapping this coordinate system to physical device coordinates.\n   It was decided that data in the logical coordinate system would be in\n   twos-complement notation, that it would be fractional, that each edge\n   of the screen would have unit length, and that the origin would\n   correspond to the center of the screen on the output device.  The\n   vertical (horizontal) edges of the screen of the output device\n   correspond to the lines X (Y) = -1/2 or X=+1/2-e where e is a small\n   positive number determined by the precision of the fractional data.\n   Particularly the points (-1/2, -1/2) (-1/2, 1/2-e), (1/2-e, -1/2) and\n   (1/2-e, 1/2-e) shall be visible points at the corners of the logical\n   screen. (In the case of a non-square display surface, the implementer\n   may take his own decision.  Thus we shall say that the Logical\n   Coordinate System contains points whose coordinates range from -1/2\n   to a little less than +1/2.\n\n\n\n\n\n\n\nMichener, et. al.                                               [Page 3]\n\f\nRFC 493                    GRAPHICS PROTOCOL               26 April 1973\n\n\n   Commands which take coordinate data will be available in various\n   modes.  In absolute mode, a position is specified by giving its\n   coordinates in the Logical Coordinate System.  In relative mode, the\n   difference between the coordinates of the position and the\n   coordinates of the current position must be specified.  Thus a\n   coordinate datum which is an argument for an absolute mode operation\n   should be in the range -1/2 to +1/2-e, while one for a relative mode\n   operation should be in the range -1+e to +1-e.\n\n   Interest was expressed at the second Graphics Group Meeting in\n   eventually allowing a very large coordinate space (many bits of\n   precision in each fractional coordinate).  This is to be done by\n   permitting the length, in 8-bit bytes, of each coordinate datum to be\n   set (as a mode).  It was decided at the meeting that two bytes per\n   coordinate would suffice for now.  Thus \"e\" in the above discussion\n   is 2**(-15) (one in the least significant bit of a 15-bit plus sign\n   fractional coordinate).\n\n   Text data will be transmitted as an argument of various commands for\n   display on the output device.  Network ASCII will be used to\n   represent characters.  At the lowest-levels of the protocol only one\n   character size will be available -- whatever is \"normal\" on the\n   display device.  If the device has no \"normal\" size, 72 characters\n   per line would be desirable.  At higher levels the size of each\n   individual character can be specified.\n\n   Also, at the lowest levels, control characters will be passed along\n   to the device for it to do the best it can.  However, the consensus\n   of the graphics meeting was that at some reasonably low (but non-\n   zero) level, carriage return, line feed, and backspace should be\n   interpreted to do the right thing.\n\nPicture Subroutines and Related Topics\n\n   At the second Network Graphics Group meeting, it was decided that two\n   sorts of picture subroutines were desirable, the primary distinction\n   between them being relative difficulty of implementation.  At the\n   meeting, the simpler variety was called a subpicture, and the more\n   complex was called a subroutine.  This author believes that these\n   terms do not embody enough semantics to facilitate keeping the two\n   straight and so proposes to standardize on \"simple subroutine\" and\n   \"full subpicture\" instead.\n\n   The only parameter which can be passed to a simple subpicture is the\n   \"current beam position\".  In other words, if such a subpicture is\n   called more than once in a picture, the only difference in appearance\n\n\n\n\n\nMichener, et. al.                                               [Page 4]\n\f\nRFC 493                    GRAPHICS PROTOCOL               26 April 1973\n\n\n   between the various calls is a translation due to the beam position\n   at the time of the call.  Full subpictures, on the other hand, take\n   parameters which can cause scaling, rotation, reflection, or anything\n   else we come up with.\n\n   It is planned that a subpicture definition need be transmitted only\n   once (per network connection) and would not be deleted by a \"new\n   picture\" operation.  Thus a changing picture could be subdivided into\n   several parts on a basis of static versus changing information; only\n   definitions of parts which change need be transmitted to redraw the\n   picture.\n\n   Traditionally, picture subroutines which depend only on the initial\n   beam position have been restricted to relative data mode drawing\n   operations.  In view of the fact that subpictures will probably be\n   used to save static picture information, it is desirable to allow\n   absolute data mode operations in simple subpictures.\n\n   The next question naturally arises -- what does absolute data mean in\n   a full subpicture which takes both position and scale parameters? Is\n   absolute data really absolute in this case? This author believes that\n   the answer is as follows: the full subpicture is really a picture in\n   its own right, so it has its own logical coordinate system, and its\n   absolute data is really within this coordinate system.  Thus\n   \"shifting and scaling\" a full subpicture really means \"scale the\n   subpicture in its own coordinate system and shift the result as a\n   whole\".\n\n   In summary, then, a major difference between simple and full\n   subpictures is that a full subpicture has its own logical coordinate\n   system and a simple subpicture uses the logical coordinate system of\n   whoever calls it.  This distinction is the reason why full\n   subpictures are harder to implement than simple subpictures.\n\n   Another point discussed at the meeting was a special data mode\n   whereby a subpicture can display data at absolute positions on the\n   screen, i.e., absolutely in the main (picture) program.  To achieve\n   this, the meeting proposed special data modes for the three\n   operations: move beam invisibly, draw line, and display dot.  The\n   intent of these data modes was to bypass all rotation, scaling, and\n   clipping functions associated with the current level of subpicture\n   nesting until this mode was cleared in a certain way.  This same\n   effect can be achieved more directly and implemented more efficiently\n   by two commands: one to save and one to re-establish the logical\n   coordinate system for the current subpicture. (Additionally, of\n   course, the \"save\" operation would establish the initial, highest\n   level, logical coordinate system.)\n\n\n\n\nMichener, et. al.                                               [Page 5]\n\f\nRFC 493                    GRAPHICS PROTOCOL               26 April 1973\n\n\nSimple Subpicture Calls\n\n   Besides the \u003cidentifier\u003e of the subpicture to be called, a simple\n   subpicture call may specify two optional parameters; the first is an\n   \u003cidentifier\u003e which is the \"name\" (in a sense described below) of this\n   particular subpicture call and the second is an absolute position on\n   the calling page to be invisibly moved to, prior to calling the\n   subpicture.  When (eventually) the viewer is allowed to interact by\n   \"picking\" information displayed before him, if the information is\n   part of a subpicture, then the \"name\" of the subpicture call will be\n   part of the \"graphic input\" reported to the serving host.  If the\n   information picked by the viewer is within several levels of\n   subpicture calls, the names of each of the calls will be reported in\n   a manner which indicates their nesting. (Note that just the name of\n   the subpicture by itself is not sufficient, since one subpicture may\n   be displayed in several positions and the application may wish to\n   distinguish between individual calls.) If the identifier is not\n   specified it defaults to the null string.  If the position (for the\n   invisible move) is not specified, the current beam position is used.\n\n   Which of these two parameters are present is encoded by two bits in a\n   code byte which precedes the parameters.  If both parameters are\n   present then they are always in the same order; this order and the\n   bits of the code byte assigned to the two parameters are specified in\n   the detailed description of the Simple Instance command (and in the\n   BNF in Appendix 1).  Preceding even the code byte, and immediately\n   following the name of the subpicture which is being called upon, is a\n   count of the data in the remainder of the instance command.  Thus is\n   included so that it is not necessary to decode the code byte to\n   determine the total length of any one Simple Instance operation.\n\nWindowing: Clipping, Blanking, or (?)\n\n   While on the subject of coordinate systems and subpictures, it might\n   be good to touch on the topic of: who (which end of the connection)\n   is responsible for doing what, when a picture is potentially going to\n   be displayed beyond the edge of the virtual screen? It was the\n   consensus at the graphics meeting that the interpreter of the\n   graphics protocol (i.e., the using end) would not be held responsible\n   for doing anything reasonable in case a picture displays information\n   beyond the edge of the screen (e.g., by relative moves and draws).\n\n\n\n\n\n\n\n\n\n\nMichener, et. al.                                               [Page 6]\n\f\nRFC 493                    GRAPHICS PROTOCOL               26 April 1973\n\n\n   The interpreter must react properly to the next absolute data in the\n   proper range, however.  Various solutions to this situation in\n   existing graphics systems include:\n\n      clipping a line to display as much as is proper,\n\n      blanking the whole of a line if any part is invisible, or\n\n      discarding high order bits of the current position register, so\n      that no invisible positions can be represented (\"wraparound\").\n\n   In addition to problems of the edge effects at the highest level,\n   problems arise with respect to (full) subpictures.  It is nice to be\n   able to select a rectangular portion of a subpicture to be displayed\n   as part of a subpicture call. (See: Newman, Display procedures,\n   Communications of the ACM, Volume 14, Number 10, October 1971,\n   pp651-660).  In accordance with the consensus of the meeting, which\n   was to make this capability optional, this author merely hopes to\n   include in the protocol a method of encoding this information since\n   his site a) can handle some such windowing, and b) hopes to provide a\n   service facility to perform this function.\n\n   Appendix 2 describes how to concatenate several levels of portions\n   into a single rectangular test, as long as no rotations are involved.\n   It also outlines the problems related to rotations and portioning.\n\nFull Subpicture Calls\n\n   We are now in position to consider what may be specified as part of a\n   full subpicture call, in addition to the name of the subpicture being\n   called, which is, of course, required.  The data described below will\n   all be optional: a single code byte will precede all these data; the\n   presence or absence of one of the parameters will be indicated by a\n   bit in the code byte being one or zero.  The parameters will always\n   appear in the same order, if they are present.  This order is given\n   below in the detailed description of the Full Instance command (and\n   in the BNF in Appendix 1).  Additionally, preceding even the code\n   byte, will be a \u003ccount\u003e of the following bytes, including the code\n   byte to determine the total length of any particular Full Instance\n   operation.\n\n   One parameter is an \u003cidentifier\u003e which can be used to distinguish\n   this particular call to this subpicture from all other calls to the\n   subpicture.  This parameter was already described under Simple\n   Subpicture Calls.\n\n\n\n\n\n\nMichener, et. al.                                               [Page 7]\n\f\nRFC 493                    GRAPHICS PROTOCOL               26 April 1973\n\n\n   On parameter which may be specified is a translation: this will be\n   specified by giving the absolute coordinates of the center (on the\n   calling page) of the image of the subpicture; this will default to\n   the beam position current at the time of the call.\n\n   A rotation may be specified by giving a 16-bit fraction in the range\n   0 to .1111111111111111 (binary) inclusive; this fraction will\n   represent what part of a full circle (2pi) the rotation is.  The\n   default value of angle of rotation will be zero.\n\n   (Actually, the rotation representation scheme works identically if\n   one thinks of it as a two's complement fraction from -1/2 to just\n   less than +1/2.  That is, the same bit configurations encode the same\n   rotation, due to the periodic nature of sine and cosine.  For\n   example, binary zero always represents 0 pi 010000...0 denotes pi/2\n   in both schemes; 100...00 denotes 1/2 in one scheme and -1/2 in the\n   other, which correspond to rotations of +pi and -pi respectively,\n   i.e. identical rotations.)\n\n   Also specifiable as apart of a full subpicture call is a rectangular\n   portion of the called picture to be imaged on the calling picture\n   (see previous section for a discussion of clipping).  This rectangle\n   is specified by its center and one half its total size in x and y.\n   That is, the rectangle will consist of all points whose x coordinate\n   differs from that of the center by no more than the specified x-size\n   and whose y coordinate satisfies a similar condition.  The default\n   for these values will place the center at the origin and give both\n   the x half width and the y half width the value of +1/2.  Thus the\n   default includes the whole of the logical coordinate system of the\n   called page (and also some points one of whose coordinates are +1/2,\n   which, strictly speaking, lie \"outside\" of the coordinate system; how\n   this inconsistency is resolved is left unspecified).\n\n   Finally, one must specify the scaling to be applied in determining\n   the image; this can be done in many ways.  One way is to specify a\n   uniform magnification to be applied to the subpicture.  So that\n   magnifications in a wide range can be achieved, it is the author's\n   opinion that some form of scientific notation (i.e., floating point)\n   will have to be employed.  If there is already a network standard\n   floating point notation (which I am not aware of) it should be\n   employed.  Failing that, it is suggested that this notation consist\n   of an 8-bit (two's complement) exponent followed by a 16-bit (two's\n   complement) fractional part.\n\n   Another form of scaling is to specify separate magnifications in x\n   and in y, to be applied to the subpicture before any rotation is\n   performed.  Yet a third way is to specify a rectangular area in the\n   calling picture's coordinate system to be filled with the image of\n\n\n\nMichener, et. al.                                               [Page 8]\n\f\nRFC 493                    GRAPHICS PROTOCOL               26 April 1973\n\n\n   the subpicture.  Since the center of the image is already specified\n   (by the translation), this image information consists only of half-\n   edge size data.  If none of the three methods of scaling are chosen\n   (and an affine transformation (see below) is not given explicitly),\n   then a uniform magnification of unity (i.e., no scaling) is used.\n   Note that the three forms of scaling tend to contradict each other\n   and only one of them should be used in any one call.  What happens if\n   self-contradictory information is given in these fields is left\n   unspecified.\n\n   Appendix 2 presents the mathematics involved in transforming the\n   subpicture's coordinate system into the calling picture's coordinate\n   system.  It is shown there that all the individual operations\n   (scaling, rotating, and translating) can be represented as a single\n   affine transformation (which consists of 6 values).  It might be nice\n   to permit the serving program to specify this transformation\n   directly.  Accordingly, one possible parameter of a full subpicture\n   call will consist of six floating point numbers (of the form\n   described under magnification, above) to be interpreted as an affine\n   transformation.  Indeed, if the affine transformation has the\n   following form:\n\n   /_ |x  |y_/ = /_ x y_/ * / L11 L12  / + /_ T1 T2_/\n                           /_ L21 L22 _/\n\n   then the values shall (arbitrarily) be sent in the following\n   (columnar) order: L11, L21, L12, L22, T1, T2.  This affine\n   transformation should be invertible that is, L11*L22 - L21*L12 should\n   not be zero.\n\nViewporting\n\n   Another topic discussed at the meeting, and referred to the protocol\n   committee for decision, was the capability of placing the \"top level\"\n   picture in some rectangle of the virtual screen.  The default\n   rectangle might be the full screen.  Alternatively it might be left\n   up to the viewer to specify the default (via) interaction with the\n   graphics system at the Using Host).  In general, viewporting allows\n   more than one \"top level\" picture to be viewed at once.  The desire\n   to view several different pictures on the same screen arises in cases\n   where multiple users are working together and in cases where one user\n   is interacting with a group of applications (in separate serving\n   hosts).  This author maintains that the coordinate transformations\n   required by this feature are simpler than that of \"full subpictures\"\n   since no rotations are involved, and would be part of the same\n   mechanism in its implementation.  In particular, merely another\n   affine transformation (see Appendix 2) would be added to the levels\n   caused by full subpicture calls.  All that is required is keeping\n\n\n\nMichener, et. al.                                               [Page 9]\n\f\nRFC 493                    GRAPHICS PROTOCOL               26 April 1973\n\n\n   track of viewport identifiers and the associated rectangles.  Since\n   little extra work is involved, it is proposed that this feature be\n   included at some high level of the protocol.\n\nCommand Codes\n\n   Each command in the graphics protocol will be assigned a non-negative\n   value which will represent this command in the byte stream.  The\n   algorithm whereby values and commands are associated is, it turns\n   out, a very touchy subject.  There are five or ten different criteria\n   for a \"best\" algorithm, each criterion different in emphasis.  This\n   Gordian knot will be cut, in this proposal, by ordering the commands\n   approximately according to level, and then just numbering them.  In\n   addition, if several closely related commands occur at the same\n   level, some attempt will be made to encode variations of meanings in\n   terms of bit configurations.  Even if some later consideration causes\n   a change in ordering to be proposed, it is this committee's feeling\n   that the numbering should not be altered.  However, until this matter\n   is firmly settled, it is strongly advised that any implementation\n   take into account the possibility of reassignment of command codes.\n\nParticular Proposal for Level 0 Protocol\n\n   It is proposed that level 0 be kept very simple.  This is so that\n   implementation can be quickly accomplished and experimentation with\n   the protocol begun.  Another reason is that the least powerful host\n   and even programmable terminals should be able to implement it.  In\n   accordance with this, the \"rule\" was made that a command be included\n   only if its output is a function solely of the current command and\n   the \"beam position\" current at the start of the command.  In other\n   words, the interpreter for level 0 need have no internal storage for\n   \"modes\" or pushdown stacks.  With this restriction it is hoped that a\n   very simple implementation will be possible for level 0.  In\n   particular, perhaps one could eventually build a hardware translator\n   from level 0 code to one's own particular terminal's code.\n\n   Note that in the opcode assignment for level 0, bits 4, 2, and 1 have\n   special meaning for the move, line, and dot commands.  In particular,\n   the 1 bit encodes absolute versus relative data mode, the 4 bit\n   encodes whether any visible output occurs, and the 2 bit determines\n   whether the visible output is a line or a dot.\n\nLevel 0: Command Summary\n\n   The following is a list of commands (and their syntax) in level zero.\n   Detailed descriptions of these commands follow in the next section.\n   Commands dealing with protocol may be added by the Connection\n   Committee. (They currently request opcodes in the range 128 to 255.)\n\n\n\nMichener, et. al.                                              [Page 10]\n\f\nRFC 493                    GRAPHICS PROTOCOL               26 April 1973\n\n\n   (As described in Basic Data Forms, above, \u003cx coordinate\u003e, \u003cy\n   coordinate\u003e, \u003cx delta\u003e and \u003cy delta\u003e are two-byte coordinate values,\n   \u003cstring\u003e is a count followed by \u003ccount\u003e many bytes and \u003cvalue\u003e is an\n   eight bit number.)\n\nDecimal  Octal   Binary    Format\n0        0       00000000  Null\n1        1       00000001  Erase screen and reset beam\n2        2       00000010  Move Absolute \u003cx coordinate\u003e \u003cy coordinate\u003e\n3        3       00000011  Move Relative \u003cx delta\u003e \u003cy delta\u003e\n4        4       00000100  Draw Absolute \u003cx coordinate\u003e \u003cy coordinate\u003e\n5        5       00000101  Draw Relative \u003cx delta\u003e \u003cy delta\u003e\n6        6       00000110  Dot Absolute \u003cx coordinate\u003e \u003cy coordinate\u003e\n7        7       00000111  Dot relative \u003cx delta\u003e \u003cy delta\u003e\n8        10      00001000  Text \u003cstring\u003e\n9        11      00001001  TextR \u003cstring\u003e\n10       12      00001010  End of Picture\n11       13      00001011  Escape \u003cvalue\u003e \u003cstring\u003e\n\n\nLevel 0: Command Descriptions\n\n0       Null Statement (\"NULL\").\nThis statement has no arguments--and no effect, either.\n\n1       Erase screen and reset beam to origin (\"ERASE\").\nThis command indicates that a new picture is about to be drawn.  It\nshould always be (eventually) paired with a following End of Picture\ncommand.\n\n2       Move beam invisibly to absolute position\n(\"MOVEA\") \u003cx coordinate\u003e \u003cy coordinate\u003e.\nNothing is drawn; the beam is positioned to the specified absolute x,y\nposition.\n\n3       Move beam invisibly by relative amount\n(\"MOVER\") \u003cx coordinate\u003e \u003cy coordinate\u003e.\nNothing is drawn; the beam is shifted by the specified amount in x and\ny.\n\n4       Draw line to absolute position\n(\"DRAWA\") \u003cx coordinate\u003e \u003cy coordinate\u003e.\nA line is drawn from the current beam position to the specified absolute\nx,y position.\n\n\n\n\n\n\n\nMichener, et. al.                                              [Page 11]\n\f\nRFC 493                    GRAPHICS PROTOCOL               26 April 1973\n\n\n5       Draw line to relative position\n(\"DRAWR\") \u003cx delta\u003e \u003cy delta\u003e.\nA line is drawn from the current beam position to the position delta x\nand delta y away.\n\n6       Display a Dot at absolute position\n(\"DOTA\") \u003cx coordinate\u003e \u003cy coordinate\u003e.\nThe beam is moved invisibly to absolute position x,y and a dot is\ndisplayed there.\n\n7       Display a Dot at relative position\n(\"DOTR\") \u003cx delta\u003e \u003cy delta\u003e.\nThe beam is moved invisibly by the specified amount in x and y and a dot\nis displayed there.\n\n8       Display text (\"TEXT\") \u003cstring\u003e.\nAt the current beam position, display some characters at the normal size\nfor the device being operated. \u003cstring\u003e consists of a \u003ccount\u003e followed\nby count many characters.  If there is no \"normal size\", choose the size\nso that seventy-two characters are displayed per line. The characters in\nthe string are coded in network ASCII all codes between 0 and 127\n(decimal) inclusive are permitted. (At level zero, what happens to\ncontrol characters is left unspecified.) Where the beam is, following\nexecution of this command, is left unspecified, except that another\nDisplay Text command immediately following will append its text to the\nprevious string. (The use of the TEXT command is discouraged; use TextR\ninstead.) The position of the first character relative to the initial\nbeam position is left unspecified.\n\n9       Display text and restore beam (\"TEXTR\") \u003cstring\u003e.\nAt the current beam position, display a string of characters at the\nnormal size for the device being operated; then reposition the beam to\nwhere it was before the command. \u003cstring\u003e consists of a \u003ccount\u003e followed\nby count many characters. If there is no \"normal size\", choose the size\nso that seventy-two characters are displayed per line. The characters in\nthe string are coded in network ASCII; all codes between 0 and 127\n(decimal) inclusive are permitted. (At level zero, what happens to\ncontrol characters is left unspecified.) The position of the first\ncharacter relative to the initial beam position is left unspecified.\n\n10      End of Picture (\"ENDPIC\").\nThis command denotes the end of a new picture. It must be paired with a\npreceding ERASE command.\n\n11      Escape to device specifics (\"ESCDEV\") \u003cvalue\u003e \u003cstring\u003e.\nIf \"value\" is the code assigned (by the Protocol Committee) to the\ndevice being operated, then transmit the eight-bit bytes in \u003cstring\u003e\n(which starts with a \u003ccount\u003e indicating the number of bytes) to the\n\n\n\nMichener, et. al.                                              [Page 12]\n\f\nRFC 493                    GRAPHICS PROTOCOL               26 April 1973\n\n\ndevice without examining them. Otherwise ignore this command. If the\ndevice does not accept 8-bit information, reformat the data in some\ndevice specific way; an example would be throwing away the high order\nbit for a seven bit device, or gathering 5 8-bit bytes into one 36-bit\nword, again discarding the high order bits, perhaps. The action of the\nbytes in the string should leave alone (or at least restore) any\nhardware beam position registers in the device which the interpreter\nmight conceivably depend on.\n\nThis command really should not be used it was included at level 0 so\nthat specific applications can do mode setting and other device specific\nmanipulations. For example, ARDS terminals may optionally have several\nindependently addressable output scopes. The selection mechanism changes\nstate only when a particular sequence of ASCII characters reaches the\nterminal. Thus ESCDEV would be used to select which scope(s) is/are to\nbe affected by following commands. (The current state is invisible to\nthe graphics package at the Using Host.)\n\nFurther, suppose that another make of terminal has a similar option,\nwhich responds to a different code sequence. This possibility is the\nmotivation for conditionally ignoring the ESCDEV command based on the\n\"\u003cvalue\u003e\" specified. Given that a particular application will only be\nused to output to either an ARDS or this second make (with the multiple\nscope option), then the application could always send two ESCDEV\ncommands, one applicable only to ARDS terminals, and the other\napplicable only to the second make.\n\nLEVEL 1\n\n   *Set Line mode (\"LINMOD\") \u003cvalue\u003e.\n   This command sets the current line mode possible modes and the\n   \u003cvalue\u003e which sets each are: solid (0), dashed (1), dotted (2), and\n   others (3 or \u003e). At the beginning of a new picture (i.e., after an\n   Erase and Reset command), line mode is solid. If a site does not have\n   a certain mode readily available, it may a) simulate it in software,\n   b) substitute another in its place (dashed for dotted, or vice versa)\n   c) ignore it entirely. What is provided should be clearly indicated\n   in any public document. It is strongly recommend that at least solid\n   and one other mode be provided.\n\n   *Set intensity (\"SETINT\") \u003cvalue\u003e.\n   This command sets the intensity of lines, dots and characters\n   displayed following the command. If \u003cvalue\u003e is 128 decimal, normal\n   intensity should be set. If \u003cvalue\u003e is 255 decimal, brightest should\n   be selected, and if it is 0, then the beam should be blanked.\n   Intermediate values should be mapped appropriately as the implementer\n\n\n\n\n\nMichener, et. al.                                              [Page 13]\n\f\nRFC 493                    GRAPHICS PROTOCOL               26 April 1973\n\n\n   sees fit. For instance, if brightest is the same as normal, all\n   values from 128 through 255 should be mapped to normal. Information\n   displayed between the start of a new picture (the ERASE command) and\n   the first SETINT command appears at normal intensity.\n\n   *Text out (\"TEXTO\") \u003cstring\u003e.\n   Starting from the current beam position, this command displays the\n   \u003cstring\u003e (of network ASCII characters) formatted as if it were typed\n   material (at the current intensity). \u003cstring\u003e consists of a \u003ccount\u003e\n   followed by count many characters. That is, text extending past the\n   right margin will be broken and repositioned at the left margin on\n   the next line down. Of the control characters, only carriage return,\n   line feed, and backspace are required to be interpreted properly.\n\n   *Subpicture header (\"SUBHED\") \u003cidentifier\u003e \u003ccount\u003e \u003cheader info\u003e.\n   This command begins the definition of a subpicture named\n   \"\u003cidentifier\u003e\". This definition is terminated by a matching SUBEND\n   command. The definition will be remembered until a new one is\n   specified or until the graphics network connection is broken. Note\n   that \u003cidentifier\u003e is a \u003cstring\u003e consisting solely of capital letters\n   and numbers.\n\n   Subpicture definitions may be nested this will be equivalent to\n   transmitting the two definitions separately. In other words, all\n   subpicture names are globals and are \"known\" to all other\n   subpictures. If a subpicture definition has not been received prior\n   to its use in a picture, the empty subpicture should be displayed in\n   its place until a definition is received.\n\n   A subpicture definition need not be transmitted as part of a picture\n   (i.e., within an ERASE and END command pair). Indeed, all subpicture\n   definitions might precede the main picture.\n\n   Currently, the \u003ccount\u003e will always be 1, indicating only one byte of\n   \u003cheader info\u003e follows, but at higher levels of the protocol room for\n   expansion may be required. In the \u003cheader info\u003e, the 80 hex bit will\n   be set if this subpicture can be a simple subpicture, and the 40 hex\n   bit will be set if the subpicture can be a full subpicture. (It is\n   possible that one subpicture can be both.)\n\n   Other information that may eventually be present in \u003cheader info\u003e\n   include whether the current value of a certain mode or parameter\n   should be saved on entry to, and restored on exit from, this\n   subroutine whenever it is called. These modes and parameters include:\n   line mode, intensity, character size, and data length.\n\n\n\n\n\n\nMichener, et. al.                                              [Page 14]\n\f\nRFC 493                    GRAPHICS PROTOCOL               26 April 1973\n\n\n   *Subpicture end (\"SUBEND\").\n   This command ends the definition of a subpicture. Each SUBEND must\n   match a preceding SUBHED command.\n\n   *Simple instance (\"INSTS\") \u003cidentifier\u003e \u003csimple instance tail\u003e\n   This command indicates that the subpicture \u003cidentifier\u003e is to be\n   called (instanced). At this level, level 1, no subpicture may call\n   another; if one does, what happens is left unspecified. Also, this\n   must be a call to a simple subpicture. Thus the 80 hex bit of the\n   single byte of \u003cheader info\u003e must have been set in the SUBHED command\n   which started the definition of \u003cidentifier\u003e. If the subpicture\n   \u003cidentifier\u003e has never been defined, the empty subpicture should be\n   displayed in its place.\n\n   The \u003csimple instance tail\u003e begins with a count of the amount of\n   information which follows. This count may be zero. If non-zero, the\n   next byte is a code byte to be interpreted to see what further\n   information follows. If the 80-hex bit is set, next in the byte\n   stream is an \u003cidentifier\u003e (called \"AS information\"). This\n   \u003cidentifier\u003e is the name of this particular instance of the\n   subpicture as described under Simple Subpicture Calls. If the 40-hex\n   bit is set, then next in the byte stream (following the AS\n   information, if present) is an x,y position (in the calling picture's\n   coordinate scheme) at which the subpicture will be centered. (This is\n   called AT information.)\n\n   If AT information is not specified, the current beam position is used\n   as a default. If AS information is not specified, it defaults to the\n   \u003cstring\u003e containing zero characters. If neither the 40 hex nor the 80\n   hex bits are set, then neither the AT information not the AS\n   information is present, and the code byte should be zero. (Also, the\n   length count had better be 1.)\n\n   Changes to levels 0 commands for level 1.\n\n   TEXT and TEXTR -- Carriage return, line feed and backspace characters\n   should definitely be interpreted whenever they appear in \u003cstring\u003e.\n   The results of other control characters remain unspecified. The\n   intensity of the characters shall be affected by the SETINT command.\n\n   ERASE -- Normal intensity and solid line mode must be established at\n   the start of a new picture.\n\n   DRAWA and DRAWR -- Line mode and intensity shall be affected by the\n   LINMOD and SETINT commands.\n\n   DOTA and DOTR -- Intensity shall be affected by the SETINT command.\n\n\n\n\nMichener, et. al.                                              [Page 15]\n\f\nRFC 493                    GRAPHICS PROTOCOL               26 April 1973\n\n\nLEVEL 2\n\n   *Mark (\"MARK\").\n   This command causes the current x,y beam position to be saved on a\n   pushdown stack. This pushdown stack must be separate from the\n   subpicture call pushdown stack.\n\n   *Move to mark and pop (\"MOVEMK\").\n   This command sets the current beam position equal to the x,y position\n   at the top of the \"mark\" pushdown stack. If the stack is empty, the\n   origin is used, instead. Then the stack is popped up (unless it is\n   empty).\n\n   *Draw to mark and pop (\"DRAWMK\").\n   If the \"mark\" pushdown stack is not empty, this command draws a line\n   (of the current line mode and intensity) from the current beam\n   position to the x,y position at the top of the \"mark\" pushdown stack,\n   and sets the beam position to that value. Then the stack is popped.\n   If the stack is empty, the line is drawn to the origin and the beam\n   position is set there also.\n\n   Changes to level 0 and 1 for level 2.\n\n   INTS -- arbitrary levels of simple subpictures must be supported.\n   (Note that recursive use of subpictures is not allowed:  once\n   recursion starts, it can never be stopped.) The pushdown stack for\n   subpicture calls must be kept separate from the \"mark\" pushdown\n   stack.\n\nLevel 3\n\n   (Perhaps all rotational transformations should be put at a higher\n   level, for instance higher than viewport operations.)\n\n   *Full Instance (\"INSTF\") \u003cidentifier\u003e \u003cfull instance tail\u003e\n   This command indicates that the subpicture \u003cidentifier\u003e is to be\n   called (instanced) in a \"full\" manner as described in an explanatory\n   section. For one thing, this means that the 40 hex bit of the single\n   byte of \u003cheader info\u003e must have been set in the SUBHED command which\n   started the definition of \u003cidentifier\u003e. If \u003cidentifier\u003e has never\n   been defined, the empty subpicture (i.e., nothing) should be\n   displayed in its place.\n\n   The \u003cfull instance tail\u003e is similar to the \u003csimple instance tail\u003e\n   described under the INSTS command, but the former contains more\n   information. Below is a list of the information which can be\n   specified, and the bit assigned to the presence/absence of each piece\n   of information. The pieces of information which are present always\n\n\n\nMichener, et. al.                                              [Page 16]\n\f\nRFC 493                    GRAPHICS PROTOCOL               26 April 1973\n\n\n   appear in the byte stream in the order they are described in this\n   list. (All pieces of information are described more fully in Full\n   Subpicture Calls, except for the \"AS information\" which is described\n   in Simple Subpicture Calls.)\n\nBit (hex)   Information\n80          As information --\"name\" of this particular instance.\n            Consists of an \u003cidentifier\u003e.\n\n40          Translation information -- Center of the subpicture's image\n            on the calling page.  Consists of an \u003cx coordinate\u003e and a\n            \u003cy coordinate\u003e.\n\n20          Rotation -- Fractional part of 2pi to rotate the image\n            counterclockwise.  Consists of a 16-bit unsigned fraction.\n\n10          Portion Information -- Rectangular part of subpicture which\n            is to be displayed.  Consists of \u003cx coordinate\u003e,\n            \u003cy coordinate\u003e, \u003cx delta\u003e, and \u003cy delta\u003e.\n\n8           Uniform Magnification -- Amount to scale the whole\n            subpicture.  Consists of a floating point number (which\n            should not be zero).\n\n4           Separate x and y magnification -- Separate scales for the x\n            and y axes of the subpicture.  Consists of two floating\n            point numbers (neither of which should be zero).\n\n2           Image Size -- How large a rectangle on the calling page is\n            the image to occupy.  Consists of an \u003cx delta\u003e and a\n            \u003cy delta\u003e (neither of which should be zero).\n\n1           Affine transformation -- The map from the called to the\n            calling coordinates system.  Consists of six floating point\n            numbers.\n\n   Notes:\n\n   1) At most one of the three bits: 8, 4, and 2, should be set.\n\n   2) If the 1 bit is set, bits 2, 4, 8, 20, and 40, should not be set.\n\n   3) If additional optional parameters are ever added to the full\n   subpicture call, another code byte could follow all the above\n   information.  In that case, the \u003ccount\u003e part of the \u003cfull instance\n   tail\u003e would include this second code byte and any additional bytes of\n   information.\n\n\n\n\nMichener, et. al.                                              [Page 17]\n\f\nRFC 493                    GRAPHICS PROTOCOL               26 April 1973\n\n\n   *Escape to top level coordinate system (\"ESCTOP\").\n   Until a RESLEV command is (subsequently) executed, all display\n   commands (moves, draws, dots, and texts) shall operate as if they\n   were issued by the top level (main) picture instead of the subpicture\n   containing them.  That is, they shall be mapped to the screen\n   according to the map for the highest level.  Subpicture calls\n   themselves, which are made while an ESCTOP command is in effect, are\n   not affected by the command.  That is, transformations are calculated\n   as if the command were not in effect.  The calculated transformations\n   are ignored, however, and information displayed by the subpicture\n   still appears to be at the top level, until a RESLEV command\n   nullifies the ESCTOP mode.  Thus a subpicture call executed while an\n   ESCTOP command is in effect, acts as if a RESLEV were executed\n   immediately before the call, and an ESCTOP command were executed as\n   the first command of the subpicture.  Similar considerations hold for\n   returning from subpictures.\n\n   *Resume current level coordinate system (\"RESLEV\").\n   This command restores the logical coordinate system corresponding to\n   the subpicture currently executing, in case that coordinate system\n   was disabled by an ESCTOP command. (See ESCTOP.)\n\n   Changes to levels 0, 1, and 2 for level 3.\n\n   MARK -- the saved beam position shall be in terms of the logical\n   coordinate system, not the physical coordinate system.\n\n   TEXTR, TEXT, TEXTO -- Since a full subpicture is supposed to be\n   transformed as a whole, as if it were a picture in its own right, it\n   appears to this author that, in particular, all beam movements\n   related to characters should be affected.  This includes character\n   size, tab, carriage return and line feed.  In particular, carriage\n   return should set the beam to the left margin--that is, to the left\n   edge of the logical coordinate system of the called subpicture.  All\n   these changes may be very hard to accomplish, and what should be done\n   will be left unspecified at this time, with comment from readers\n   particularly invited.\n\nLevel 4\n\n   (Perhaps viewpoint operations can be included in level 3.)\n\n   *Declare Viewport\n   (\"SETVW\") \u003cviewport id\u003e \u003cx coordinate\u003e \u003cy coordinate\u003e \u003cx delta\u003e\n   \u003cy delta\u003e\n   Set the viewport identified by \u003cviewport id\u003e to represent the\n   indicated area of the logical screen.  The x and y data are not\n   physical screen coordinates, since that would involve device\n\n\n\nMichener, et. al.                                              [Page 18]\n\f\nRFC 493                    GRAPHICS PROTOCOL               26 April 1973\n\n\n   dependencies.  This command completely supersedes any previous\n   declaration of the same viewport.  If information is already\n   displayed within the viewport specified, this command causes the\n   displayed information to be relocated on the screen to its new\n   position.\n\n   If the area specified exceeds the limits of the graphics standard\n   display screen, what happens is left unspecified.  Viewports need not\n   be disjoint; in other words, two viewports can present display\n   information at the same point on the screen.\n\n   If \u003cx delta\u003e or \u003cy delta\u003e are negative, the viewport named should be\n   deleted.  All information displayed by it shall no longer appear.\n\n   Because it affects the top level picture, this author feels that this\n   command should not occur as part of a picture or in a subpicture\n   declaration.\n\n   *Add subpicture to viewport (\"ADDSVW\") \u003cidentifier\u003e \u003cviewport id\u003e\n   The subpicture named \u003cidentifier\u003e is displayed within the viewport\n   specified, if it is not already displayed there. (If it is, nothing\n   is done.) The subpicture must be capable of being called via a full\n   subpicture call.  If the viewport has never been declared via a SETVW\n   command what happens is left unspecified. (Three possibilities are:\n   nothing is displayed; the viewport defaults to the whole logical\n   screen; the human viewer is permitted by the Using Host to specify\n   the viewport.) If the viewport is subsequently declared, the\n   subpicture shall be displayed in it.  If the subpicture has never be\n   declared, nothing is displayed for it; when and if it is subsequently\n   declared, the new definition is displayed in the viewport.  More than\n   one subpicture may be displayed in a single viewport at once.\n\n   Because it affects the top level picture, this author feels that this\n   command should not occur as part of a picture or in a subpicture\n   declaration.\n\n   *Clear viewport (\"CLVW\") \u003cviewport id\u003e\n   All subpictures which have been added with the ADDSVW command to the\n   viewport specified in this command are removed from it.  Thus the\n   specified viewport contributes nothing to what the human viewer sees.\n   (After a CLVW, the area of the viewport may not be blank due to\n   other, non-cleared viewports which overlap it.)\n\n   Because it affects the top level picture, this author feels that this\n   command should not occur as part of a picture or in a subpicture\n   declaration.\n\n   Changes to levels 0, 1, 2, and 3 for level 4.\n\n\n\nMichener, et. al.                                              [Page 19]\n\f\nRFC 493                    GRAPHICS PROTOCOL               26 April 1973\n\n\n   ERASE -- All viewports are cleared (as in the CLVW command) but their\n   declarations are remembered.\n\n   ENDPIC -- This command partially loses its purpose: it no longer\n   serves to mark the end of all picture information to be presented to\n   the user, since viewport operations may follow which amend or alter\n   the picture.  This function is partially taken over by the DELAY and\n   NODELAY commands described below.\n\nLevel ?\n\n   *Set Character Size (\"SETCHS\") \u003cx delta\u003e \u003cy delta\u003e.\n   Until further notice, characters shall be displayed so that each\n   occupies approximately \u003cx delta\u003e and \u003cy delta\u003e in the appropriate\n   coordinate direction in the current logical coordinate system.\n   Inter-character and inter-line spacing could be certain percentages\n   (any ideas?) more than \u003cx delta\u003e and \u003cy delta\u003e, or they could be\n   specified separately.  In any case, only a \"best effort\" would be\n   expected at a site.  Character size is always set to normal (as\n   defined by level 0 character size being normal) by the ERASE command.\n   \u003cx delta\u003e and \u003cy delta\u003e should be positive, except that if \u003cx delta\u003e\n   is equal to zero, then \u003cy delta\u003e being negative, zero, or positive,\n   correspond to a character size which is \"smaller than normal\",\n   \"normal\", or \"larger than normal\".  How much smaller or larger than\n   normal is left up to the site.\n\n   Changes to levels 0 and 1 for level ?.\n\n   TEXTR, TEXT, and TEXTO -- Characters are to be displayed according to\n   the current character size.\n\n   ERASE -- Must establish normal character size, normal being that for\n   level 0.\n\nLevel ?'\n\n   *Set Data Length (\"SETDLN\") \u003cvalue\u003e.\n   Until this mode is explicitly changed with another SETDLN, various\n   data will consist of \u003cvalue\u003e number of bytes. \u003cvalue\u003e may be 1, 2, 3,\n   or 4.  Affected are the following syntactic types (refer to Appendix\n   1): \u003ccoordinate\u003e, \u003cx coordinate\u003e, \u003cy coordinate\u003e, \u003cdouble\n   coordinate\u003e, \u003cx delta\u003e, \u003cy delta\u003e, \u003cangle\u003e, and the fractional part\n   of a floating point number.  When a network connection is initially\n   established, the data length is two.\n\n\n\n\n\n\n\nMichener, et. al.                                              [Page 20]\n\f\nRFC 493                    GRAPHICS PROTOCOL               26 April 1973\n\n\nLevel ?''\n\n   (These commands should probably be at the same level as viewport\n   operations, if not earlier.)\n\n   *Extensive Changes Follow (\"DELAY\").\n   This optional command is designed to eliminate futile effort on the\n   part of the Using Host programs.  At some hosts and/or with some\n   output devices (particularly storage tubes) a non-negligible amount\n   of time may be required to present an image to the human viewer.  If\n   extensive changes are going to be made, this command would be used to\n   prevent the Using Host graphics package from updating the image after\n   every change.  A NODELAY command exits from the DELAY mode and causes\n   the image to be prepared and presented to the viewer.\n\n   For example, the current picture may display four subpictures each of\n   which is going to be redefined.  Without a DELAY command, the viewer\n   would see successive stages of the change, each possibly involving a\n   large amount of computation or transmission time.\n\n   *End of Extensive Changes (\"NODELAY\")\n   This optional command undoes the effect of the DELAY command.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMichener, et. al.                                              [Page 21]\n\f\nRFC 493                    GRAPHICS PROTOCOL               26 April 1973\n\n\nAppendix 1: BNF for the Graphics Protocol Byte Stream\n\nKey to below:\nNon-terminals are represented in \u003c \u003e.\nTerminals which are keywords standing for particular eight-bit values\nare in capitals.\nTerminals whose meaning should be clear to the reader are in lower case.\nNote that \"empty_string\" means \"zero bytes\", not \"a \u003cstring\u003e whose\n\u003ccount\u003e is zero.\"\n\n\u003cgraphics output byte stream\u003e ::= empty_string\n           | \u003cpicture\u003e \u003cgraphics output byte stream\u003e\n           | \u003csubpicture declaration\u003e \u003cgraphics output byte stream\u003e\n           | \u003cviewport operation\u003e \u003cgraphics output byte stream\u003e\n           | \u003ctransmission control stt\u003e \u003cgraphics output byte stream\u003e\n\u003cpicture\u003e ::= \u003cnew picture sst\u003e \u003cprogram stt group\u003e \u003cend picture stt\u003e\n\u003csubpicture declaration\u003e ::= \u003csubpicture header stt\u003e \u003cprogram stt\n                              group\u003e\u003csubpicture end stt\u003e\n\u003cviewport operation\u003e ::= \u003cdeclare viewport stt\u003e\n           | \u003cadd subpicture to viewport stt\u003e\n           | \u003cclear viewport stt\u003e\n\u003ctransmission control stt\u003e ::= \u003cset data length stt\u003e\n           | \u003cextensive changes follow stt\u003e\n           | \u003cend of extensive changes stt\u003e\n\u003cprogram stt group\u003e ::= empty_string | \u003cprogram stt \u003cprogram stt group\u003e\n\u003cprogram stt\u003e ::= \u003cpicture control stt\u003e | \u003cdisplay stt\u003e |\n              \u003ctransmission control stt\u003e\n\u003cpicture control stt\u003e ::= \u003cescape to device stt\u003e\n           | \u003cescape to highest coordinate system stt\u003e\n           | \u003crestore coordinate system stt\u003e\n           | \u003cmark stt\u003e\n           | \u003cnull stt\u003e\n           | \u003cline mode stt\u003e\n           | \u003cset intensity stt\u003e\n           | \u003csubpicture declaration\u003e\n           | \u003csimple instance stt\u003e\n           | \u003cfull instance stt\u003e\n           | \u003cset character size stt\u003e\n\u003cdisplay stt\u003e ::= \u003cmove absolute stt\u003e\n           | \u003cmove relative stt\u003e\n           | \u003cdraw absolute stt\u003e\n           | \u003cdraw relative stt\u003e\n           | \u003cdot absolute stt\u003e\n           | \u003cdot relative stt\u003e\n           | \u003cmove to mark and pop stt\u003e\n           | \u003cdraw to mark and pop stt\u003e\n\n\n\n\n\nMichener, et. al.                                              [Page 22]\n\f\nRFC 493                    GRAPHICS PROTOCOL               26 April 1973\n\n\n           | \u003ctext and restore beam stt\u003e\n           | \u003ctext stt\u003e\n           | \u003ctext out stt\u003e\n\u003cnew picture stt\u003e ::= ERASE\n\u003cend picture stt\u003e ::= ENDPIC\n\u003csubpicture header stt\u003e ::= SUBHED \u003cidentifier\u003e count\u003e \u003cheader info\u003e\n\u003cheader info\u003e ::= 80-hex | 40-hex | C0-hex\n\u003csubpicture end stt\u003e ::= SUBEND\n\u003cset viewport stt\u003e ::= SETVW \u003cviewport id\u003e \u003cx coordinate\u003e\n                       \u003cy coordinate\u003e \u003cx delta\u003e \u003cy delta\u003e\n\u003cadd subpicture to viewport stt\u003e ::= AADSVW \u003cidentifier\u003e \u003cviewport id\u003e\n\u003cclear viewport stt\u003e ::= CLVW \u003cviewport id\u003e\n\u003cextensive changes follow stt\u003e ::= DELAY\n\u003cend of extensive changes stt\u003e ::= NODELAY\n\u003cescape to device stt\u003e ::= ESCDEV \u003cdevice code\u003e \u003cstring\u003e\n\u003cescape to highest coordinate system stt\u003e ::= ESCTOP\n\u003crestore coordinate system stt\u003e ::= RESLEV\n\u003cnull stt\u003e ::= NULL\n\u003cmark stt\u003e ::= MARK\n\u003cline mode stt\u003e ::= LINMOD \u003cvalue\u003e\n\u003cset character size stt\u003e ::= SETCHS \u003cx delta\u003e \u003cy delta\u003e\n\u003cset data length stt\u003e ::= SETDLN \u003cvalue\u003e\n\u003cmove absolute stt\u003e ::= MOVEA \u003cx coordinate\u003e \u003cy coordinate\u003e\n\u003cmove relative stt\u003e ::= MOVER \u003cx delta\u003e \u003cy delta\u003e\n\u003cdraw absolute stt\u003e ::= DRAWA \u003cx coordinate\u003e \u003cy coordinate\u003e\n\u003cdraw relative stt\u003e ::= DRAWR \u003cx delta\u003e \u003cy delta\u003e\n\u003cdot absolute stt\u003e ::= DOTA \u003cx coordinate\u003e \u003cy coordinate\u003e\n\u003cdot relative stt\u003e ::= DOTR \u003cx delta\u003e \u003cy delta\u003e\n\u003cmove to mark and pop stt\u003e ::= MOVEMK\n\u003cdraw to mark and pop stt\u003e ::= DRAWMK\n\u003ctext and restore beam stt\u003e ::= TEXTR \u003cstring\u003e\n\u003ctext stt\u003e ::= TEXT \u003cstring\u003e\n\u003ctext out stt\u003e ::= TEXTO \u003cstring\u003e\n\n\u003csimple instance stt\u003e ::= INST \u003cidentifier\u003e \u003csimple instance tail\u003e\n\u003cfull instance stt\u003e ::= INSTF \u003cidentifier\u003e \u003cfull instance tail\u003e\n\u003csimple instance tail\u003e ::= eight_bits_of_binary_0\n                    | \u003ccount\u003e \u003ctail code\u003e \u003cas clause\u003e \u003cat clause\u003e\n\u003ctail code\u003e ::= bit_pattern_indicating_what_clauses_follow\n\u003cfull instance tail\u003e ::= eight_bits_of_binary_0\n                    | \u003ccount\u003e \u003ctail code\u003e \u003cas clause\u003e \u003cat clause\u003e\n                    \u003crotation clause\u003e \u003cportion clause\u003e\n                    \u003cuniform magnification clause\u003e\n                    \u003cseparate magnification clause\u003e \u003cimage size\n                    clause\u003e \u003ccomplete transformation clause\u003e\n\u003cas clause\u003e ::= empty_string | \u003cidentifier\u003e\n\u003cat clause\u003e ::= empty_string | \u003cx coordinate\u003e \u003cy coordinate\u003e\n\u003crotation clause\u003e ::= empty_string | \u003cangle\u003e\n\n\n\nMichener, et. al.                                              [Page 23]\n\f\nRFC 493                    GRAPHICS PROTOCOL               26 April 1973\n\n\n\u003cportion clause\u003e ::= empty_string | \u003cx coordinate\u003e \u003cy coordinate\u003e\n                     \u003cx delta\u003e \u003cy delta\u003e\n\u003cuniform magnification clause\u003e ::= empty_string |floating point number\u003e\n\u003cseparate magnification clause\u003e ::= empty_string |\n                    \u003cfloating point number\u003e \u003cfloating point number\u003e\n\u003cimage size clause\u003e ::= empty_string | \u003cx delta\u003e \u003cy delta\u003e\n\u003ccomplete transformation clause\u003e ::= empty_string | six_\u003cfloating point\n                    number\u003e's\n\n\u003cangle\u003e ::= 16-bit_non-negative_fractional_part_of_a_circle\n\u003cx coordinate\u003e ::= \u003ccoordinate\u003e\n\u003cy coordinate\u003e ::= \u003ccoordinate\u003e\n\u003cx delta\u003e ::= \u003cdouble coordinate\u003e\n\u003cy delta\u003e ::= \u003cdouble coordinate\u003e\n\u003ccoordinate\u003e ::= signed,_two_s-complement,_fraction_in_range\n                    -1/2_to_less_than_+1/2\n\u003cdouble coordinate\u003e ::= signed,_two_s_complement,_fraction,\n                    range _strictly_between_-1_and_+1\n\u003cfloating point number\u003e ::= network_standard_floating_point\n                    number_if_any\n                    | 8-bit_two_s_complement_exponent_part and a\n                    16-bit_two_s_complement_fraction_part \u003ccount\u003e\n                    ::= 7-bit_non-negative_integer\n                    | 15-bit_non-negative_integer_represented_in\n                    \"excess_2**15\"_notation\n\u003cstring\u003e ::= \u003ccount\u003e count_8-bit_bytes\n\u003cidentifier\u003e ::= \u003ccount\u003e count_upper_case_letters_or_numbers\n\u003cviewport id\u003e ::= \u003cidentifier\u003e\n\u003cdevice code\u003e ::= 8-bit_integer\n\u003cvalue\u003e ::= 8-bit_integer\n\nAppendix 2.  Mathematical Formulae for Subpictures\n\nTransformations\n\nIn this appendix positions in a logical coordinate system will be\nrepresented by a row vector with two elements, as in /_ x y_/.  Vectors\nand matrices will be delimited by these funny brackets: /_ _/.  Various\nsymbols will be used to represent parameters in a full subpicture call\nrelating to a transformation from one coordinate system to another;\nthese are defined below:\n\nMx and My : magnifications in x and y to be applied before any\n            rotation.\n            They may be negative indicating reflection.\nA: an angle of rotation in the range 0 to just less than 2pi.\n/_ |cx |cy_/ : the center (in the calling picture) of the image of the\n          subpicture.\n\n\n\nMichener, et. al.                                              [Page 24]\n\f\nRFC 493                    GRAPHICS PROTOCOL               26 April 1973\n\n\n|sx |sy : the half-sizes, in the x and y directions, of the\n           image on the calling page in terms of the calling page's\n           coordinate system.\n           They may be negative to indicate reflection.\n/_ x y_/ : a position on the called page.\n/_ |x |y_/ : the position on the calling page corresponding to /_x y_/.\n/_ Pcx Pcy_/ : The center of the portion of the called subpicture's\n               coordinate system which is to be mapped to the calling\n               page.\n               This defaults to /_ 0 0_/ if not specified.\nPsx and Psy : The half-sizes in x and y of the portion of the\n              subpicture to be mapped. These both default to +1/2\n              in not specified.\n\n(If a uniform magnification is specified, set Mx and My equal to it and\nproceed below as if they were specified.)\n\nIf magnifications are specified, the following holds:\n\n/_ |x |y_/ = (/_ x y_/ - /_ Pcx Pcy_\u003e) * / Mx/Psx  0    / *\n                                        /_   0  My/Psy_/\n\n          / cos 0 sin 0 / * / 1/2 0  / + /_ |cx |cy_/\n         /_ -sin0 cos0_/  /_ 0  1/2_/\n\nor in other words,\n\n1)\n/_|x |y_/ = /_ x-Pcx y-Pcy_/ * / Mx cosA/2Psx Mx sinA/2Psx /\n                             /_ -My sinA/2Psy My cosA/2Psy_/\n            +/_ |cx |cy_/\n\n(The factor of 1/2 is necessary because, for instance, (x-Pcx)/Psx\nranges from -1 to +1 for x values within the portion (i.e., such that\n|x-Pcx| \u003c|Psx| ) whereas the image, in the calling subpicture's\ncoordinate system, should only range from -1/2 to +1/2.)\n\nIf the image size is specified instead of the magnification, we have the\nfollowing:\n\n/_ |x |y_/ = (/_ x y_/ - /_Pcx Pcy_/) * / 1/Psx  0    / *\n                                       /_  0  1/Psy _/\n\n          / cosA sinA    / * / |sx 0    / + /_ |cx |cy_/\n         /_ -sinA cosA _/   /_ 0  |sy _/\n\n\n\n\n\n\nMichener, et. al.                                              [Page 25]\n\f\nRFC 493                    GRAPHICS PROTOCOL               26 April 1973\n\n\nor, in other words,\n\n2)\n/_|x |y_/ = /_x-Pcx y-Pcy_/ * /|sx cosA/Psx |sy sinA/Psx /\n                            /_-|sx sinA/Psy |sy cosA/Psy_/\n\n           + /_|cx |cy_/\n\nExpanding the parenthesized quantities in equations 1) and 2), we\nhave:\n\n3a) /_|x |y_/ = /_x y_/ * /Mx cosA/2Psx   Mx  sinA/2Psx /\n                         /_-My sinA/2Psy  My cosA/2Psy_/\n\n           + /_|cx-PcxMxcosA/2Psx+PcyMysinA/2Psy\n                      |cy-PcxMxsinA/2Psx-PcyMycosA/2Psy _/\n\nand\n\n3b) /_|x |y_/ = /_x y_/ * /|sx cosA/Psx |sy sinA/Psx  /\n                        /_-|sx sinA/Psy |sy cosA/Psy_/\n\n           + /_|cx-Pcx|sxcosA/Psx+Pcy|sxsinA/Psy\n                      |cy-Pcy|sysinA/Psx-Pcy|sycosA/Psy_/\n\nVarious interesting substitutions can be made in 3a) and 3b).\nFor example, if A=0 (no rotation), then we have:\n\n4a) /_|x |y_/ = /_x y_/ * /Mx/2Psx 0 / + /_|cx-PcxMx/2Psx\n|cy-PcyMy/2Psy_/\n                         /_ 0 My/2Psy_/\n\n4b) /_|x |y_/ = /_x y_/ *  /|sx/Psx 0 / + /_|cx-Pcx|sx/Psx\n|cy-Pcy|sy/Psy_/\n                          /_ 0 |sy/Psy_/\n\nAnother example is if no portioning is done (Pcx=Pcy=0, Psx=Psy=1/2):\n\n5a) /_|x |y_/ = /_ x y_/  * /Mx cosA Mx sinA   / + /_|cx |cy_/\n                           /_-My sinA My sinA_/\n\n5b) /_|x |y_/ = /_ x y_/ * /2|sx cosA 2|sy sinA   / + /_|cx |cy_/\n                          /_-2|sx sinA 2|sx cosA_/\n\n\n\n\n\n\n\n\nMichener, et. al.                                              [Page 26]\n\f\nRFC 493                    GRAPHICS PROTOCOL               26 April 1973\n\n\nIf in addition, 0=0, we have:\n\n6a) /_|x |y_/ =  /_ xMx+|cx  yMy+|cy_/\n\n6b) /_|x |y_/ = /_ x*2|sx+|cx y*2|sy+|cy_/\n\nOf course, in all cases, the transformation from /_x y_/ to /_|x |y_/\ncan be written in the form:\n\n/_|x |y_/ = /_x y_/ * / 2 by 2 / + /_ translation _/\n                     /_ matrix _/\n\nIn general, a transformation combining a linear transformation and a\ntranslation is called an affine transformation.\n\nTransformations with Nested Levels\n\nThe combination of two affine transformations is again an affine\ntransformation.  Indeed, if\n\n/_|x |y_/ = /_x y_/ * / Mat1 / + /_ Tran1 _/\n                     /_     _/\nand\n\n/_|x_ |y__/ = /_|x |y_/ * ( / Mat1 / * / Mat2 /)\n                           /_    _/   /_    _/\n            + (/_ Tran2 _/ + /_ Tran1 _/ * / Mat2 /)\n                                          /_    _/\n\nThus if one has nested full subpicture calls, the data at any level need\nbe transformed only once, namely, by the transformation which is the\ncombination of the single step transformations at each level of nesting.\nA new \"grand combination\" affine transformation should be computed\nwhenever a full subpicture is called (after pushing down the current\ntransformation) by combining the current grand combination with the\naffine transformation for this particular subpicture call.\n\nPortions with Nested Levels\n\n   As long as no rotations are involved, or even only rotations in\n   multiples of pi/2, then multiple levels of portions are easy to\n   implement.  In the discussion in the next two paragraphs let us\n   assume that no rotations other than whole multiples of pi/2 are\n   involved.\n\n   Just as one can keep track of a \"grand combination\" affine\n   transformation, so can one keep a grand combination of portions.  At\n   each level, one can proceed as follows: Save a copy of the current\n\n\n\nMichener, et. al.                                              [Page 27]\n\f\nRFC 493                    GRAPHICS PROTOCOL               26 April 1973\n\n\n   grand portion, and use the inverse of the single level affine\n   transformation (specified in the subpicture call) to determine what\n   rectangle of the called page corresponds to the current grand portion\n   (on calling page).\n\n   Various relations may exist between this rectangle and the rectangle\n   specified (or defaulted) in the subpicture call.  They may be\n   disjoint (in which case this subpicture need not be called at all);\n   they may be equal (an easy case); one may contain the other or they\n   may partially overlap.  If there is any intersection, it will be a\n   rectangle, and this rectangle becomes the new grand combination\n   portion.\n\n   The problem with rotations other than multiples of pi/2 is that the\n   inverse image of the rectangle is no longer in the standard\n   orientation (vertical and horizontal edges).  This means that its\n   intersection with the portion specified on the subpicture call may\n   have 3, 4, 5, 6, 7, or 8 edges (if it is non-empty).  Deeper levels\n   may get even worse if they involve rotations too.  While there may be\n   no conceptual difficulty (for some) in working with such a situation,\n   significantly more computation is involved than in the simple\n   horizontal and vertical edge case.\n\n   This protocol puts forward no recommendation in the case that\n   rotations other than whole multiples of pi/2 are involved with\n   portions.  It does suggest that nested portions be handled as\n   described above in the more straightforward case.\n\n\n          [This RFC was put into machine readable form for entry]\n    [into the online RFC archives by Helene Morin, Via Genie, 12/1999]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMichener, et. al.                                              [Page 28]\n\f\n"
}