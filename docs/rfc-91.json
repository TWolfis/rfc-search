{
  "series": "Request for Comments",
  "number": "91",
  "howpublished": "RFC 91",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0091",
  "url": "https://www.rfc-editor.org/info/rfc91",
  "title": "Proposed User-User Protocol",
  "pagetotal": "12",
  "year": "1970",
  "month": "dec",
  "body": "\n\n\n\n\n\nNetwork Working Group                                    George H. Mealy\nRequest for Comments: 91                              Harvard University\n                                                       December 27, 1970\n\n\n                     A PROPOSED USER-USER PROTOCOL\n\nINTRODUCTION:\n\n   There are many good reasons, and maybe one or two bad ones, for\n   making it appear that communication over the Network is only a\n   special case of input/output -- at least as far as user programming\n   is concerned.  Thus, for instance, the Harvard approach toward\n   implementing the HOST-HOST protocol and Network Control Program\n   treats each link as a \"logical device\" in PDP-10 terminology.\n   Setting up a connection is similar to local device assignment, and\n   communication over a link will make use of the standard system\n   input/output UUO's.  This makes it possible to use existing programs\n   in conjunction with the Network without modification -- at least if\n   other PDP-10's are being dealt with.\n\n   This takes us only so far, however.  The notion of a \"logical device\"\n   does not exist on the PDP-10; it does on the IBM 360 (I am speaking\n   here at the level of the operating system -- user program interface).\n   Furthermore, in the absence of a Network standard requiring fixed\n   representations for integers, reals, etc. (which I would oppose), any\n   pair of user processes must arrive at a local agreement, and one or\n   both must assume the burden of data conversion where necessary.  Any\n   standard protocol should allow such agreements to be given expression\n   and should accommodate at least the minimum of control information\n   that will allow such agreements to function in practice.  Finally, we\n   must note that the IMP-IMP and HOST-HOST protocols do not provide for\n   a check that an action requested by a user process is actually\n   accomplished by the other processes; this type of issue has always\n   been regarded as subject to treatment at the USER-USER protocol\n   level.\n\n   This proposal is intended to face the above three types of issue only\n   to a certain extent.  I can best explain that extent by stating the\n   criteria I would use to judge any USER-USER protocol proposal:\n\n\n\n\n\n\n\n\n\n\n\nMealy                                                           [Page 1]\n\f\nRFC 91               A Proposed User-User Protocol         December 1970\n\n\n   1.   The notion of a (logical) _record_ should be present, and the\n        notion of a _message_ should be suppressed. (To a FORTRAN pro-\n        grammer, that which is written using one WRITE statement with no\n        accompanying FORMAT is a record; to an OS/360 machine language\n        programmer, PUT writes a record).\n\n   2.   It should be possible to so implement the protocol in HOST sys-\n        tems and/or library routines that now existing user programs can\n        access files anywhere in the Network without program modifica-\n        tion. (Initially, at least, this ability must be restricted to\n        HOST systems of the same type).\n\n   3.   The protocol should be implementable (not necessarily imple-\n        mented) in any HOST system at the SVC or UUO level.  Specific\n        knowledge of the characteristics of the other HOST involved\n        should be unnecessary.\n\n   It should be noted that the above imply that some user programs must\n   be aware of the nature of the other HOST -- at least in each case\n   where the second criterion fails.  As we make progress in (or give up\n   on) the cases where the failure now occurs, the burden of accommodat-\n   ing system differences will shift toward implementation in protocols\n   (i.e., the HOST systems) or, by default, in user programs.\n\n   Quite clearly, any proposal initiated today should be suspect as to\n   the extent to which it \"solves\" ultimate problems.  How ambitious to\n   be is strictly a matter of taste.  At this stage, I prefer to try\n   something which I believe can be used by all of us (and, hence, is\n   worth doing), goes a reasonable distance towards solving our short-\n   range problems, is easy to do, and offers hope of viability in the\n   long range view.  In the following, I intend to describe the proposal\n   itself with, I hope, proper motivational arguments for its pieces.  I\n   will then sketch the specific implementation we at Harvard are making\n   for the PDP-10 and describe how we intend to apply it in the specific\n   case of storage of files on other PDP-10's in the Network.\n\nUSER-USER PROTOCOL (PROPOSAL)\n\n   The following protocol is intended to apply to the data bits in mes-\n   sages between the end of the marking bits and the beginning of the\n   padding bits. _The present IMP-IMP and HOST-HOST protocols are unaf-\n   fected by this proposal_.\n\n   The general principle is that each segment (this is not a technical\n   term) of data is preceded by control information specifying its\n   nature and extent.  The basic scheme has been evolved from that used\n   in the SOS buffering system (see the papers in JACM, April 1959 and\n   especially that by O.R. Mock).\n\n\n\nMealy                                                           [Page 2]\n\f\nRFC 91               A Proposed User-User Protocol         December 1970\n\n\n   Our point of view is that a link is a carrier of information.  Infor-\n   mation is carried in segments of a fixed maximum length called _mes-\n   sages_ [1].  That this is so is an accident, from the user's point of\n   view; when he wishes to transmit a contiguous stream of data, he will\n   in general, segment it in a different (from the IMP-IMP or HOST-HOST\n   protocol view) manner -- we will call his segment a _record_.  It\n   should be clear that this is entirely analogous between the notion of\n   (physical) _block_ and (logical) record.  On the side, file storage\n   systems also make use of control and status information; we will\n   also.\n\n   At the USER-USER protocol level, all information transmitted over the\n   link is a sequence of flags followed by (possibly null) data blocks.\n\n   The general format will be:\n\n        OPERATION     COUNT     DATA\n\n   The OPERATION field is always present and is four bits long.  The\n   COUNT field, when present, gives the number of data bytes following\n   in the data block.  The byte size is set by the last preceding SIZE\n   flag (in most cases).  The byte may be between zero and 255 bits long\n   (Yes, Virginia, zero is zero even when you have a System/360).  The\n   OPERATION field and the COUNT field (when present) are called the\n   flag and the data bytes (when present) the data block.  Flags fol-\n   lowed by data blocks (even when null due to a zero count) are called\n   block flags, and other flags are called whyte [2] flags.\n\n   It is to be noted that, since the SIZE flag sets the byte size for\n   the following blocks, byte size may be set at that \"natural\" for the\n   sending or for the receiving HOST, depending on local agreement\n   between the sending and receiving processes.  It is specifically\n   required that a SIZE flag appear in each message prior to any block\n   flag (except the ASCII flag); the SIZE flag may be introduced on a\n   default basis by the routine(s) implementing the protocol and is\n   intended partially as a means of detecting certain classes of error.\n\n   The COUNT field is 8 bits in length (except in the EOM flag, where it\n   is 16 bits long).  The flags are as follows:\n\n   Whyte Flags:\n\n      0 - NUL             No operation (consider next flag)\n      1 - RS              Record Separator (end of record)\n      2 - GS              Group Separator (end of group)\n      3 - FS              File Separator (end of file)\n      4 - ESC             Escape to local convention for flags\n      5 -                 (reserved for later assignment)\n\n\n\nMealy                                                           [Page 3]\n\f\nRFC 91               A Proposed User-User Protocol         December 1970\n\n\n      6 - EOM N           End of Message (N is total bit count)\n      7 - SIZE N          Byte size is N bits\n      8 - IGNORE N        Ignore following data bits\n\n   Block Flags:\n       9 - SYS N          N bytes of data for receiving HOST system\n      10 - CONTROL N      N bytes of control data follow\n      11 - STATUS N       N bytes of status data follow\n      12 - LABEL N        N bytes of identification data follow\n      13 - KEY N          N bytes of key data follow\n      14 - ASCII N        N (8-bit) bytes of ASCII data follow\n      15 - BLOCK N        N bytes of data follow\n\n   I have already mentioned the requirement for SIZE.  Absence of the\n   SIZE flag in any message containing block flags (except ASCII) is a\n   definite error.  EOM is partially another error-checking device and\n   partially a device for bypassing the padding conundrum.  A user pro-\n   gram should never see EOM on input; the user may write an EOM to\n   force transmission.  EOM delimits the end of the useful information\n   in the message and restates the total number of bits in the message,\n   starting with the first bit following the marking and ending with the\n   last bit of the EOM count field, to check possible loss of informa-\n   tion.  This is a check against errors in the IMP-HOST electrical\n   interface and in the HOST mushyware.  EOM must appear at the end of\n   each messager, unless ESC has apeared.\n\n   ESC is intended as a (hopefully) unused escape hatch, for nonuse by\n   those installations and/or applications wishing to avoid using more\n   than four bits of the USER-USER protocol on any link.  For instance,\n   it may be desired to use a link as a bit stream, ignoring even mes-\n   sage boundaries.  If and when anarchists can achieve local agreement,\n   more power to them!\n\n   NUL and IGNORE are intended to be space fillers, in case it is help-\n   ful to make the first bit of the subsequent data block occur on a\n   convenient address boundary. (An especially helpful HOST interrupt\n   routine might even paste a combination of NUL and IGNORE over the\n   marking bits when receiving a message -- in which case, their bit\n   count should be transmitted on to the GET routines to correct the EOM\n   bit count check).  The separator operations introduce the notions of\n   logical record, group, and file.  Specifically, there is no require-\n   ment that a record be contained entirely within a message or that\n   only a single record be contained in a message!  In addition, there\n   is no requirement that only one file be transmitted during a connec-\n   tion.  For instance, a user might wish to use a link to transmit a\n   collection of rountines, and then do something else with the link.\n\n\n\n\n\nMealy                                                           [Page 4]\n\f\nRFC 91               A Proposed User-User Protocol         December 1970\n\n\n   By local agreement, then, a single routine might consist of a number\n   of records forming a group, the whole collection might form a file,\n   and the link might remain connected after the FS flag is received.\n\n   The interpretation of the various block flags is similarly open to\n   local agreement.  The two flags intended to convey pure data are\n   ASCII and BLOCK; the difference between them is only (as far as the\n   protocol is concerned) that the byte size is implicit for ASCII (8\n   bits) and explicit for BLOCK (the count field of the next preceding\n   SIZE flag).  Beyond this, however, the semantic content of the block\n   following ASCII is governed by the current standards for ASCII;\n   EBCDIC information may not be transmitted in an ASCII block!!\n\n   CONTROL and STATUS are intended for communication of control informa-\n   tion between user processes, and the interpretation of their accom-\n   panying data blocks is open to local agreement.  Generically, CONTROL\n   means \"try to do the following\" and STATUS means \"but I feel this\n   way, doctor.\"  A CONTROL flag will prompt a returned STATUS flag,\n   sooner or later, or never.  LABEL is intended for use in identifying\n   the following unit(s) of data, at the file or group level.  Again,\n   the specific interpretation is a matter of local agreement.  KEY is\n   intended to mimic the notion of address or key -- this is at the\n   record, data item, or even physical storage block level.  For the\n   familiar with PDP-10 system and/or OS/360, the following parallels\n   are offered for guidance:\n\n   USER-USER protocol      OS/360            PDP-10\n   __________________      ______            ______\n\n     CONTROL               OPEN              OPEN\n\n                           CLOSE             CLOSE\n\n     LABEL                 DSCB              File retrieval information\n\n     KEY                   KEY               USETI/USETO argument\n\n     CONTROL               READ              IN/INPUT\n\n                           WRITE             OUT/OUTPUT\n\n                           ALLOCATE ?        ENTER\n\n                           OPEN ?            LOOKUP\n\n     STATUS                ?                 GETSTS\n\n\n\n\n\nMealy                                                           [Page 5]\n\f\nRFC 91               A Proposed User-User Protocol         December 1970\n\n\n   The \"?\" notations above indicate lack of a very direct parallel.  It\n   is worth noting that the OS/360 GET and PUT have direct parallels in\n   any implementation of the USER-USER protocol that embodies the notion\n   of record; our implementation of the protocol will lead to introduc-\n   tion of this notion for all PDP-10 input/output involving disc and\n   tape storage, as well as IMP communication.\n\n   If I knew the MULTICS terminology, I could extend the set of paral-\n   lels above with more precision.  Although my terminology has been\n   drawn from systems with explicit input/output imperatives, I wish to\n   emphasize that this setup in intended to handle control and data com-\n   munication in general; MULTICS is a system in which the classical\n   distinction between external and internal storage is blurred (from\n   the user's point of view) in a manner I wish it blurred in the USER-\n   USER protocol.  I offer SYS with only slight trepidation.  The gen-\n   eral notion is that one should be able to communicate directly with a\n   foreign HOST rather than via a foreign user process as its intermedi-\n   ary.  SYS is like a UUO or SVC, but for the foreign HOST's consump-\n   tion rather than my HOST's.  From the HOST's point of view, the prob-\n   lem in implementation is in establishing a process context record\n   unconnected with any local user process.  This, however, is strongly\n   associated with our current LOGON conundrum.  On the PDP-10, for\n   instance, users are more or less identified with local teletype\n   lines, and any link is not one of those! Hence, subterfuge is neces-\n   sary to let a foreign user log on.  OS/360 is as (actually, more)\n   perverse in its own way.\n\n   The process of logging a foreign process onto my local system is not\n   (except possibly for MULTICS) a simple matter of having a special\n   (!!)  user job present which is responsible for doing it.  When and\n   if anything else is possible, the HOST must provide a system instruc-\n   tion (UUO or SVC or whatever) that gives the requisite information\n   establishing a process independent in all senses of the process that\n   made the request.  Otherwise, self-protection mechanisms which are\n   reasonable for any system will make us all much more interdependent\n   that we wish.  To do this, there must exist in every system a UUO/SVC\n   that does the right thing (ATTACH, but forget me).  If this is true,\n   then the LOGON process over the Network is tantamount to issuance of\n   a foreign UUO/SVC by another node in the Network.  I see no reason-\n   able way around this.  If that is the case, then SYS N is the kind of\n   flag to use to convey the requisite data.  If that is so, then it is\n   only reasonable to let SYS convey a request for any OS instruction at\n   the user program-operating system interface level!\n\n   The practical questions of implementation are something else! In the\n   case of the PDP-10, I can pretty well see how to turn a SYS into\n   either a LOGON request to execute a monitor command or UUO (would\n   that they were the same) as the case might be.  OS/360 is more\n\n\n\nMealy                                                           [Page 6]\n\f\nRFC 91               A Proposed User-User Protocol         December 1970\n\n\n   sophisticated, unfortunately.  MULTICS might make it.  Naytheless, I\n   hope that is clear that what we want to do, which is what the proto-\n   col should reflect, is quite a different question from that of how it\n   is to be done in the context of a specific HOST system.  What we want\n   to do is, in general, rather independent of the system we are dealing\n   with as far as the protocol is concerned, and we should not fail to\n   introduce general notions into the protocol just because we are unc-\n   ertain as to how they may have to be translated into particular\n   implementation practice.\n\n   A PDP-10 IMPLEMENTATION\n\n   Although the following can be implemented as either a set of user\n   routines or imbedded in the monitor as UUO's (our first implementa-\n   tion will be the former), the latter version will be used for\n   descriptive purposes.  The UUO's would be:\n\n        PUTF    CH, E   Put flag\n\n        PUTD    CH, E   Put data\n\n        PUT     CH, E   Put record\n\n        GETFD   CH, E   Get flag or data\n\n        GET     CH, E   Get record\n\n   In the above, \"CH\" is the logical channel number.  The customary OPEN\n   or INIT UUO is used to open the channel.  Standard format user\n   buffers are assigned.  However, the ring and buffer headers will be\n   used in a nonstandard way, so that data mode 12 is assigned for use\n   with Network buffering and file status bit 31 must be on for input.\n   (Any of the devices DSK, DTA, MTA, or IMP can be used in this mode.)\n\n   In the Harvard NCP and HOST-HOST protocol implementation, user\n   buffers do not correspond directly to messages.  On output, each user\n   buffer will be formatted into a message; on input, a message may\n   become one or two user buffer loads (128 word buffers are used in\n   order to make maximum use of the facilities of the disk service rou-\n   tines).\n\n\n\n\n\n\n\n\n\n\n\nMealy                                                           [Page 7]\n\f\nRFC 91               A Proposed User-User Protocol         December 1970\n\n\n   PUTF UUO:\n\n      This UUO places a flag into the output buffer.  The effective\n      address is the location of a word:\n\n         XWD operation, count\n\n      In the case of block flags, the count is ignored, since it will be\n      computed from the number of bytes actually placed in the buffer\n      before the next use of PUTF.  PUTF and PUTD will insert EOM flags\n      automatically as each buffer becomes full; if data bytes are\n      currently being placed in the buffer by PUTD, it will also insert\n      an EOM flag after computing the count for the previous block flag\n      in the buffer and place a new block flag of the same type at the\n      beginning of the next buffer, after inserting a SIZE flag stating\n      the then current byte size.\n\n   PUTD UUO:\n\n      This UUO places data into the output buffer.  The effective\n      address is the location of the data byte (if the byte size is less\n      than 36) or of the next 36 bit word of data to be placed in the\n      buffer.  In the first case, the byte is assumed to be in the low\n      order part of the word addresses.  In the second case, the data\n      word containing the final bits of the byte contains them in the\n      high order part of the word, and the next data byte starts a new\n      word in PDP-10 storage.  Thus, for a byte size of 64, two entries\n      to PUTD would be used per byte transmitted, the first containing\n      36 bits and the second containing 28 bits, left-justified.  This\n      strategy allows maximum use of the PDP-10 byte handling instruc-\n      tions.\n\n   PUT UUO:\n\n      This UUO places a whole logical record in the output buffer(s).\n      The effective address is that of a word:\n\n         IOWD count, location\n\n      A PUTF UUO must have been used to output the proper SIZE flag.\n      Thereafter, each use of PUT will output a BLOCK flag, [3] simulate\n      a number of calls to PUTD using the IOWD to discover the location\n      and size of the user data area, and then output a RS flag to indi-\n      cate end of record.\n\n\n\n\n\n\n\nMealy                                                           [Page 8]\n\f\nRFC 91               A Proposed User-User Protocol         December 1970\n\n\n      In the case of byte size of less than 36 bits, PUT will use the\n      ILDB instruction to pick up bytes to be output by PUTD.  Hence,\n      the standard PDP-10 byte handling format is used, and the count\n      part of the IOWD is the total byte count, not word count.\n\n      The above UUO'S have both an error return and a normal return.\n\n   GETFD UUO:\n\n      The calling sequence for this UUO is:\n\n         GETFD CH, E\n         error return\n         whyte flag return\n         block flag return\n         data return\n\n      The effective address is the location at which the flag or data\n      will be returned.  The flag is returned in the same format as for\n      PUTF and the data in the same format as for PUTD.  Certain flags\n      (NUL, IGNORE, and EOM) will be handled entirely within the UUO and\n      will not be reported to the user.  SYS should eventually be han-\n      dled this way, but initially will be handled by the user.\n\n   GET UUO:\n\n      The calling sequence for this UUO is:\n\n         GET CH, E\n         error return\n         end of file return\n         end of group return\n         normal return\n\n      GET transmits the next logical record to the user, using GETFD\n      together with an IOWD in the same format as for PUT.  If the IOWD\n      count runs out before end of record, the remainder of the record\n      will be skipped.  In any case, the updated IOWD will be returned\n      at the effective address of the UUO in order to inform the user\n      how much data was transmitted or skipped.\n\nPDP-10 FILE TRANSMISSION:\n\n   Assume that I have a link connected to another PDP-10 and a user\n   process there that is listening.  In order to get that process to\n   send me a file, the sequence of flags that might be transmitted can\n\n\n\n\n\nMealy                                                           [Page 9]\n\f\nRFC 91               A Proposed User-User Protocol         December 1970\n\n\n   be represented as follows, where the UUO'S executed by me are in the\n   left margin, the flags are indented, and the commentary opposite them\n   indicates the nature of the data block transmitted:\n\n   PUT F\n        CONTROL   Data with OPEN parameters, requesting OPEN\n        LABEL     File identification data for LOOKUP\n        EOM       Forces message to be transmitted\n\n   GETFD\n        STATUS    Status returned by OPEN\n        SIZE      Byte size to be used\n        LABEL     File retrieval information\n\n   PUTF\n        CONTROL   Data requesting INPUT from file\n        EOM       Forces request to be transmitted\n\n   GETFD\n        STATUS    Status bits returned by INPUT\n\n   GET            Logical record (one file buffer load)\n        (loop back to second PUTF, above, for other records)\n\n   Finally, the status information returned by the second GETF indicates\n   end of file, and I wind up with the sequence:\n\n   PUTF\n        CONTROL   Data requesting a CLOSE\n        EOM       Forces transmission\n\n   GETFD\n        STATUS    Status bits returned by CLOSE\n\n   In the case I am getting a file, the main loop looks like:\n\n   PUTF\n        CONTROL   Data requesting OUTPUT\n\n   PUT            Logical record (one file buffer load)\n\n   PUTF\n        EOM       Forces transmission\n\n   GETFD\n        STATUS    Status bits returned by OUTPUT\n\n\n\n\n\nMealy                                                          [Page 10]\n\f\nRFC 91               A Proposed User-User Protocol         December 1970\n\n\n   The use of both the record and the flag transmission UUO's is worth\n   noting, as well as the use of the EOM flag to force transmission of a\n   message when switching between input and output over the link.  PUT\n   and GET UUO's are clearly required above for transmission of the CON-\n   TROL and LABEL data; I suppressed them for the sake of clarity.\n\n   For this application, the handshaking nature of the transmission of\n   CONTROL and STATUS flags are mandatory.  While the protocol would\n   permit transmission of a complete file without the handshaking, it\n   would be an all or nothing proposition - a single error would neces-\n   sitate doing it all over again, presuming that the receiving process\n   did not end up in a complete tangle.\n\n   BRIEF DISCUSSION:\n\n   The PDP-10 space required to implement the above protocol is about\n   400 instructions, divided equally between the input and the output\n   side.  Enough experimental coding has been done to confirm the feasi-\n   bility of this basic strategy, taken together with experience with\n   implementation and use of the SOS buffering system.\n\n   The above does not touch the question of LOGON protocol, except\n   indirectly.  My belief is that it can be accommodated in the frame-\n   work of this proposal, but I have not tested this theory as yet.  As\n   indicated further above, I would be tempted to handle the matter with\n   the SYS flag, given that SYS data is interpreted directly by the sys-\n   tem (in our system, we would use the RUN UUO to run the LOGON CUSP,\n   which would, in turn handshake using ASCII data over the link).  In\n   this way, I think we might be able to dispense with the notion of\n   dedicated sockets and the reconnection morass.\n\n   One other point that needs thought is the question of how to handle\n   the interrupt on link facility.  Should it have any direct relation\n   to the GET/PUT UUO's, or be handled on the side?  I am inclined to\n   think that it should be treated _qua_ interrupt of the user process,\n   quite independently of the matter of data transmission over the link.\n   Some of our current work on the PDP-10 monitor would lend itself\n   rather easily to implementation as a true interrupt.\n\n\n   ENDNOTES*\n\n   1.  A message is that string of bits between any two HOST-HOST\n   headers.\n\n   2.  In memory of an attractive, but nonspelling, SDC secretary who\n   could not distinguish between black and white, at least during 1957\n   and in manuscript form.\n\n\n\nMealy                                                          [Page 11]\n\f\nRFC 91               A Proposed User-User Protocol         December 1970\n\n\n   3.  PUTF may be used to ouput the block flag, if a different from\n   BLOCK is required.\n\n\n\n\n         [ This RFC was put into machine readable form for entry ]\n         [ into the online RFC archives by Colin Barrett  9/97   ]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMealy                                                          [Page 12]\n\f\n"
}