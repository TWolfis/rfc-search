{
  "series": "Request for Comments",
  "number": "88",
  "howpublished": "RFC 88",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0088",
  "url": "https://www.rfc-editor.org/info/rfc88",
  "title": "NETRJS: A third level protocol for Remote Job Entry",
  "pagetotal": "9",
  "year": "1971",
  "month": "jan",
  "body": "\n\n\n\n\n\nNetwork Working Group                                          R. Braden\nRequest for Comments: 88                                        S. Wolfe\nNIC: 5668                                                       UCLA/CCN\n                                                         13 January 1971\n\n\n          NETRJS - A THIRD LEVEL PROTOCOL FOR REMOTE JOB ENTRY\n\n   A.  Introduction\n\n   NETRJS is the name for a message protocol and set of control\n   conventions which will allow users at remote Hosts to access the RJS\n   (\"Remote Job Service\") remote batch subsystem of CCN.  RJS[1] was\n   written at CCN to support remote batch (car reader/line printer)\n   terminals over communications lines.\n\n   RJS makes a remote batch terminal's unit record devices operate as if\n   they were at the central site; thus, a remote user enters OS/360\n   jobs, complete with JCL, into the remote reader.  The jobs are\n   spooled into the operating system and run in their turn, and the\n   printed and/or punched output is returned to the remote terminal from\n   which the jobs originated (unless the user or operator re-routes the\n   output).  The remote terminal may also include a console typewriter\n   to be used by the remote operator to receive and send messages and to\n   exert control over his terminal [2].\n\n   When RJS is used via the ARPA Network, the \"remote terminal\" is\n   expected to be a multiprogrammed user process in a remote Host.  We\n   will use the RJS term \"remote site\" for such a user process, which\n   presumably simulates unit record devices by file I/O.  Furthermore,\n   several users at the same remote Host may simultaneously use NETRJS,\n   acting as independent \"remote sites\" distinguished by 8-character\n   names called _terminal-ids_ (because each remote site appears to RJS\n   as a separate physical terminal).  Valid terminal-ids will be\n   assigned to individual users or user groups at remote Hosts who wish\n   to use NETRJS.\n\n   Under NETRJS, a separate ARPA network connection is opened from this\n   remote site to CCN for each (simulated) unit record device.  Each\n   such connection will be called a _channel_ and be designated _input_\n   or _output_ with reference to CCN.  We define a _standard_ remote\n   site in NETRJS to have the following five channels (See Figure 1):\n\n      1._Operator Input Channel_ - Commands and messages entered by\n         remote \"operator\" console.\n\n      2 _Operator Output Channel_ - Message stream which would normally\n         be directed to remote operator.\n\n\n\nBraden, et. al.                                                 [Page 1]\n\f\nRFC 88              NETRJS - A THIRD LEVEL PROTOCOL      13 January 1971\n\n\n      3._Input Stream_ - One simulated Hollerith card reader for job\n         submission.\n\n      4._Printer Stream_ - One simulated line printer to record printed\n         output (system messages and SYSOUT data sets) from jobs.\n\n      5._Punch Stream_ - One simulated card punch, capable of recording\n         arbitrary (i.e., transparent) binary text.\n\n   RJS actually will support more than one reader, printer, and punch at\n   each remote terminal, so the NETRJS protocol could easily be expanded\n   to allow multiple simultaneous I/O streams to each Network user.\n   However, this does not presently appear useful, as the ARPA Network\n   bandwidth will normally be the limitation on the transmission speed\n   under NETRJS.\n\n   Under NETRJS, the text of a single network message is called a\n   _block_.  A block is of variable length, up to 900 bytes (except\n   operator input and output blocks, which may not exceed 130 bytes).\n   Here the term _byte_ refers to the set of 8 bits representing one\n   character; each byte is to be aligned on an 8-bit boundary within the\n   message (and block).  Thus we may consider a block to be a string of\n   bytes.  The detailed format of a block will be defined in Sections E,\n   F, and G, using essentially the formalism suggested by Bobrow and\n   Sutherland in RFC #31.\n\n   Since the central site Host (CCN) is an IBM 360, NETRJS uses the IBM\n   EBCDIC character code to avoid redundant code conversion at both\n   hosts in those cases when the remote host also uses EBCDIC\n   internally.  However, the message formats make no assumption about\n   the code, and in fact, \"object decks\" sent to the (simulated) card\n   punch will normally contain arbitrary binary text.\n\n   To maximize the use of the available Network bandwidth, we strongly\n   recommend transmitting input blocks as large as possible; CCN will\n   always fully block NETRJS output.  Furthermore, to avoid excessive\n   overhead, we urge that all NETRJS users make their marking _a\n   multiple of 8 bits_, so the messages received at CCN arrive on a byte\n   boundary.\n\n   B.  Starting a Session[3]\n\n   The initial connection protocol for NETRJS is essentially that of\n   Crocker in RFC #66 (as restated by Harslem and Heafner in RFC #80),\n   with some extensions.  User U at a remote Host presumably requests\n   his outgoing logger to make a NETRJS connection to CCN.  This\n\n\n\n\n\nBraden, et. al.                                                 [Page 2]\n\f\nRFC 88              NETRJS - A THIRD LEVEL PROTOCOL      13 January 1971\n\n\n   logger does so by first sending an initial RFC to connect socket\n   (user,aen) = (U,s) to CCN socket (0,5).  User 0 at CCN is the\n   incoming logger, and aen = 5 signifies NETRJS.\n\n   The CCN incoming logger will allocate a set of (six) consecutive aen\n   numbers A, A+1,......A+5, for user U, return a message containing the\n   socket number (U,A) as specified in RFC #66, and close the initial\n   connection.  The remote and central sites will then open an input\n   channel between CCN socket (U,A) (socket f in Figure 1) and remote\n   socket (U, s+1).  This is the remote operator input channel.  The\n   other devices have fixed aen's at CCN assigned relative to A, in\n   particular:\n\n                                 CCN Socket\n         Channel                 (User,aen)\n\n         Operator Input          (U,A)\n         Operator Output         (U,A+1)\n         Card Reader (No. 1)     (U,A+2)\n         Printer (No. 1)         (U,A+3)\n         Punch (No. 1)           (U,A+5)\n\n   Once the operator input channel is open, the remote site must\n   transmit a valid RJS signon message [2].  This message is free-format\n   and consists of the command verb \"SIGNON\" followed by the user's\n   terminal-id.  If RJS does not recognize the terminal-id or has no\n   available Line Handler for the Network, it will indicate refusal by\n   closing the operator input channel.  Central site issues subsequent\n   RFC's for the other channels listed above only in response to\n   corresponding RFC's from the remote site\n\n   To terminate the session, the remote site may close the console input\n   channel (socket \"a\" in figure 1).  Alternatively, the user can enter\n   a SIGNOFF command through the operator input channel; in this case,\n   RJS will wait until the current job output streams are complete and\n   then terminate the session.  RJS terminates the session by closing\n   the console output channel (socket g).  Also, if RJS should abend\n   then socket g will close.  If either site terminates the session, all\n   other connections for this remote site should be closed.  Note that a\n   user can submit a number of jobs, sign off, and later receive his\n   output when he signs on again.\n\nC.  Channel Control\n\n   Flow control in NETRJS is handled by the Network protocol ALL\n   mechanism.  Before transmission of a stream of records can begin on a\n   particular channel, the remote site must issue an RFC and Central\n   must reply.  This allows the central site to determine the remote\n\n\n\nBraden, et. al.                                                 [Page 3]\n\f\nRFC 88              NETRJS - A THIRD LEVEL PROTOCOL      13 January 1971\n\n\n   configuration dynamically.  A particular card reader, printer, or\n   punch channel is open only while it is active, so the receiver need\n   not tie up buffer space needlessly.  Each of these channels, when\n   open, assumes a buffer allocation of at least 900 bytes at the\n   receiver.\n\n   The operator input and output channels, on the other hand, are open\n   throughout the session.  On these channels the receiver must provide\n   an allocation of at least 130 bytes.\n\n   After sending the SIGNON command over the operator input channel, the\n   remote site should send RFC's for all output channels which are ready\n   to receive data.  When output is available for that site, Central\n   returns an RFC and begins transmission.  Central closes an output\n   channel (socket i and j) at the end of the output for each complete\n   batch job.[4]  The remote site must then send a new RFC and Central\n   must reply with an RFC to start output for another job to that\n   device.  This gives the remote site a chance to allocate a new file\n   for each job without breaking the output within a job.  If the user\n   at the remote site wants to cancel (or backspace or defer) the output\n   of a particular job, he enters appropriate RJS commands[2] on the\n   operator input channel.\n\n   When the remote site is ready to submit a job (or stack of\n   consecutive jobs), it issues an RFC for the card reader input\n   channel.  The remote site is not required to close the channel\n   (socket c) after each job in a \"stack\" of jobs, but he must close it\n   following the last job in the stack to initiate its processing.\n\n   It may be necessary for the receiver site to abort a particular\n   channel, perhaps due to a transmission error (see Section D below on\n   checking) or a disk I/O error.  The receiver may abort a channel\n   (other than console output) by closing it (sockets d, e, f, and h).\n   This action signals the transmitter to re-transmit the information\n   after the channel has been reopened (initiated by the remote site, as\n   always).  The transmitter, on the other hand, aborts a channel by\n   sending a block with a particular bit combination (e = 2 in BCBYTE;\n   see Section E).\n\n   If either site aborts card reader (input) channel, RJS will discard\n   the text of the last partially-spooled job; the remote site should\n   re-transmit this job.  Note that repeating an entire stack will enter\n   duplicate jobs into the system, but the second copy of a job will\n   \"flush\" due to its duplicate job name.\n\n   If a printer or punch (output) channel is aborted, Central will re-\n   transmit from the beginning of the current SYSOUT data set; the\n   effect is the same as a RESTART command.[2]\n\n\n\nBraden, et. al.                                                 [Page 4]\n\f\nRFC 88              NETRJS - A THIRD LEVEL PROTOCOL      13 January 1971\n\n\n   If the operator input channel is aborted, the remote site must re-\n   transmit the last _block_.  Finally, the operator output channel has\n   no abort condition defined.  Central will never send Channel Abort\n   message on this channel; if the remote site closes its socket (socket\n   b), Central will not re-transmit, but simply cease sending messages\n   until the channel is reopened.  Therefore a remote site can operate\n   without an operator output channel; however we do not recommend this,\n   as the user will then miss operator advisory messages such as a\n   warning of an impending IPL.\n\nD.  Checking\n\n   The nature of remote job entry service is such that a low rate of\n   undetected errors is mandatory.  The IMP's use CRC's and sequence\n   numbers over the communication lines, so the effective IMP-IMP error\n   rate should be negligible.  Although there is no checking provided\n   for the IMP-Host interface, it seems likely that these interfaces\n   will either be reliable or fail catastrophically; it seems unlikely\n   that \"drop-outs\" or other random failures will occur.  Therefore only\n   the following simple checks are provided:\n\n   1. Each block will (at least initially) contain a fixed bit check\n      pattern using both on and off states of each bit path in the 16\n      bit PDA interface at CCN.\n\n      It is anticipated that even this crude check on IMP-Host\n      transmission will be useful both during the initial checkout of\n      hardware and software and also later if the interface becomes\n      marginal.  However, either site can omit the check pattern if it\n      sets a bit in the Block Control Byte (BCBYTE); see Section F.\n\n   2. Each block contains a sequence number.  Again this is intended for\n      initial checkout and to signal catastrophic hardware or software\n      problems.  If the receiver detects an incorrect check pattern or\n      block sequence number, he aborts the channel by closing the\n      corresponding network connection; the remote site should then\n      issue an RFC to re-establish the network connection.  The sequence\n      number of the first block after an RFC is 0.  The  numbers are\n      never reset while the connection is open.\n\n\n\n\n\n\n\n\n\n\n\n\nBraden, et. al.                                                 [Page 5]\n\f\nRFC 88              NETRJS - A THIRD LEVEL PROTOCOL      13 January 1971\n\n\nE.  Block Format\n\n      BLOCK \u003c---- BLOCKHEAD + (RECORD = r) + ENDOFBLOCK\n\n                  Here r \u003e 0\n                         =\n   BLOCKHEAD \u003c--  BCBYTE + [e=0=\u003eCHECK] + DEVBYTE\n\n                  The Blockhead field consists of a Block Control Byte,\n                  a 32-bit check field CHECK, and a Device Byte.\n\n   BCBYTE \u003c----   '1'BIT + e:ERRORCONTROL + b:BLKSEQ\n\n                  Here BLKSEQ contains a 5-bit modulo 32 block sequence\n                  number b.  ERRORCONTROL is a 2 bit field with the\n                  following meanings:\n\n                  e=0 :  Normal block.  Contains a (presumably valid)\n                         check field CHECK.\n\n                  e=1 :  Block contains no check field CHECK.\n\n                  e=2 :  Abort channel, initiated by transmitter.\n                         Channels is not closed, transmission restarts\n                         on job-related boundary.\n\n   DEVBYTE \u003c----  '1'BIT + n:DEVNO + t:DEVTYPE\n\n                  This byte identifies a particular remote device, i.e.,\n                  it identifies a stream.  DEVTYPE specifies the type of\n                  device, as follows:\n\n                  t=1:  Output to remote operator console.\n                    2:  Input from remote operator console.\n                    3:  Input from card reader.\n                    4:  Output to printer.\n                    5:  Output to card punch.\n                  6,7:  Unused.\n\n                  DEVNO is a 3-bit integer which identifies the\n                  particular device type of type t at this remote site.\n\n   CHECK \u003c---     '10101111'BYTE + 01010000'BYTE + '11111010'BYTE +\n                                                   '00000101'BYTE\n   ENDOFBLOCK\u003c----'0'BYTE\n\n\n\n\n\n\nBraden, et. al.                                                 [Page 6]\n\f\nRFC 88              NETRJS - A THIRD LEVEL PROTOCOL      13 January 1971\n\n\nRecord Format\n\n      RECORD \u003c------ DATA RECORD | JOBNAMERECORD\n\n   The first record sent on a printer or punch output channel will be a\n   JOBNAMERECORD, identifying the OS/360 jobname of the job which\n   produced the following output.\n\n   DATARECORD \u003c---   '10'BIT2 + DEVCNTRL + (STRING=p) + ENDOFRECORD\n\n   JOBNAMERECORD \u003c-- '11000000'BYTE + '11001000'BYTE + JOBNAME +\n                     ENDOFRECORD\n\n   JOBNAME \u003c----     (TEXTBYTE = 8)\n\n                     This is the 8-character OS/360 jobname for the\n                     following job.\n\n   DEVCNTRL \u003c-----    d:BIT2 + k:BIT4\n\n                     DEVCNTRL specifies carriage control for a printer,\n                     so if the device is not a printer then DEVCNTRL\n                     should be '000000'.  For a printer:\n\n                     d=0     : Space k lines after printing; 0 \u003c k \u003c 3\n                                                               =   =\n                               is allowed\n\n                     d=2     : Immediately space k lines.\n\n                     d=1, k=1: Skip to top of new page after printing.\n\n                     d=3, k=1: Immediately skip to top of new page.\n\n   STRING \u003c---         ('100' + i:DUPCOUNT)| This is a string of i\n                     consecutive blanks.\n\n                     ('101' + i:DUPCOUNT + TEXTBYTE)|\n\n                     This is a string of i consecutive duplicates of\n                     TEXTBYTE.\n\n                     ('11' + j:LENGTH + (TEXTBYTE=j)| This is an\n                     uncompressed string of j characters.\n\n   ENDOFRECORD \u003c----   '0'BYTE\n\n\n\n\n\nBraden, et. al.                                                 [Page 7]\n\f\nRFC 88              NETRJS - A THIRD LEVEL PROTOCOL      13 January 1971\n\n\nG.  Field Definitions\n\n   Name*           Meaning                 Length (bits)\n   _____           _______                 _____________\n\n   BIT             1-bit field                  1\n\n   BIT2            2-bit field                  2\n\n   BIT4            4-bit field                  4\n\n   BLKSEQ          Block sequence number        5\n\n   BYTE            8-bit field aligned on 8-bit 8\n                   boundary\n\n   CHECK           Block check number          32\n\n   DEVNO           Device number of a given     3\n                   type\n\n   DEVTYPE         Device type                  4\n\n   DUPCOUNT        Number of replications of    5\n                   duplicated character in\n                   compressed text.\n\n   ERRORCONTROL    Block transmission error     2\n                   control.\n\n   LENGTH          Length in bytes of the       6\n                   following string of text.\n\n   TEXTBYTE        An 8-bit byte of text        8\n\n   *Note:  All non-terminal fields whose names end in\n           \"...BYTE\" represent bytes in both length and\n           alignment.\n\n\n\n\n\n\n\n\n\n\n\n\n\nBraden, et. al.                                                 [Page 8]\n\f\nRFC 88              NETRJS - A THIRD LEVEL PROTOCOL      13 January 1971\n\n\n   H.  NOTES AND REFERENCES\n\n   1. Martin, V.A. and Springer, T.W., \"Implementation of A Remote Job\n      Service\", Technical Report TR2, Campus Computing Network, UCLA,\n      Los Angeles, (undated).\n\n   2. The RJS operator commands and messages are described in detail in\n      Reference 1.\n\n   3. We use the phrase \"starting a session\" rather than \"logging on\"\n      because RJS has its own log on procedure, which is, we suppose, a\n      fourth-level protocol.\n\n   4. Note that NETRJS uses closing of connections as end-of-file\n      signals.\n\n\n\n           REMOTE SITE             CENTRAL SITE (CCN)\n      +---------------------+    +--------------------+\n      |                 a   |    |                    |\n      | Console Input  o-----------\u003eo f               |\n      |                 b   |    |                    |\n      | Console Output o\u003c-----------o g               |\n      |                 c   |    |                    |\n      | Card Reader    o------------o h               |\n      |                 d   |    |                    |\n      | Printer        o\u003c-----------o i               |\n      |                 e   |    |                    |\n      | Card Punch     o\u003c-----------o j               |\n      |                     |    |                    |\n      +---------------------+    +--------------------+\n\n                           FIGURE 1\n                ARPA Network Connections (Channels)\n              For a Standard Remote Site Under NETRJS\n\n      R.T. Braden/rb.\n      S.M. Wolfe\n\n\n           [This RFC was put into machine readable form for entry]\n            [into the online RFC archives by Lorrie Shiota, 10/01]\n\n\n\n\n\n\n\n\nBraden, et. al.                                                 [Page 9]\n\f\n"
}