{
  "series": "Request for Comments",
  "number": "426",
  "howpublished": "RFC 426",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0426",
  "url": "https://www.rfc-editor.org/info/rfc426",
  "title": "Reconnection Protocol",
  "pagetotal": "12",
  "year": "1973",
  "month": "jan",
  "body": "\n\n\n\n\n\nNetwork Working Group                                         Bob Thomas\nRequest for Comments: 426                                      BBN-TENEX\nNIC: 13011                                               23 January 1973\nCategories: Protocols, TELNET\nReferences: 36,318,333,435\n\n\n                         Reconnection Protocol\n\n   There are situations in which it is desirable to move one or both\n   ends of a communication path from one host to another.  This note\n   describes several situations in which the ability to reconnect is\n   useful, presents a mechanism to achieve reconnection, sketches how\n   the mechanism could be added to Host-Host or TELNET protocol, and\n   recommends a place for the mechanism in the protocol hierarchy.\n\n1. Some Examples:\n\nA. Consider the case of an executive program which TIP users could use\n   to get network status information, send messages, link to other\n   users, etc.  Due to the TIP's limited resources the executive program\n   would probably not run on the TIP itself but rather would run on one\n   or more larger hosts who would be willing to share some of their\n   resources with the TIP (see Figure 1).\n\n   The TIP user could access the executive by typing a command such as\n   \"@ EXEC\"; the TIP would then ICP to Host1's executive port.  After\n   obtaining the latest network news and perhaps sending a few messages,\n   the user would be ready to log into Host2 (in general not the same as\n   Host1) and do some work.  At that point he would like to tell the\n   executive program that he is ready to use Host2 and have executive\n   hand him off to Host2.  To do this the executive program would first\n   interact with Host2, telling it to expect a call from TIP, and then\n   would instruct the TIP to reconnect to Host2.  When the user logs off\n   Host2 he could be passed back to the executive at Host1 prepatory to\n   doing more work elsewhere. The reconnection activity would be\n   invisible to the TIP user.\n                                Reconnection\n          ______               |              ______\n         |      |              |             |      |\n         | EXEC |\u003c-------------+------------\u003e| USER |\n         |______|              |  /          |______|\n           Host1               V /              TIP\n                 ______         /\n                |      |\u003c------/\n                |______|\n                 Host2\n                               Figure 1\n\n\n\nThomas                                                          [Page 1]\n\f\nRFC 426                  Reconnection Protocol              January 1973\n\n\nB. Imagine a scenario in which a user could use the same name and\n   password (and perhaps account) to log into any server on the network.\n   For reasons of security and economy it would be undesirable to have\n   every name and password stored at every site.  A user wanting to use\n   a Host that doesn't have his name or password locally would connect\n   to it and attempt to log in as usual (See Figure 2).  The Host,\n   discovering that it doesn't know the user, would hand him off to a\n   network authentication service which can determine whether the user\n   is who he claims to be. If the user passes the authentication test he\n   can be handed back to Host which can then provide him service.  The\n   idea is that the shuffling of the user back and forth between Host\n   and Authenticator should invisible to the user.\n\n   (a)   ______      for authentication     ______\n        |      |            |              |      |\n        |      |\u003c-----------+-------------\u003e| User |\n        |______|            | /            |______|\n          Host              |/\n                            X\n                           /|\n             _______      / |\n            |       |    /  v\n            |       |\u003c---\n            |_______|\n          Authenticator\n\n   (b)\n         ______                             ______\n        |      |                           |      |\n        |      |\u003c--\\             ^     /--\u003e| User |\n        |______|    \\            |    /    |______|\n          Host       \\           |   /\n                     ------------+--/\n                                 | /\n                                 |/\n                                 |\n                                /|\n                               / |\n                              /  | authentication\n             _______         /   | complete\n            |       |       /\n            |       |\u003c------\n            |_______|\n          Authenticator\n\n                           Figure 2\n\n\n\n\n\nThomas                                                          [Page 2]\n\f\nRFC 426                  Reconnection Protocol              January 1973\n\n\n   If the user doesn't trust the Host and is afraid that it might read\n   his password rather than pass him off to the authenticator he could\n   connect directly to the authentication service.  After\n   authentication, the Authenticator can pass him off to the Host.\n\nC. The McROSS air traffic simulation system (see 1972 SJCC paper)\n   already supports reconnection.  It permits an on-going simulation to\n   reconfigure itself by allowing parts to move from computer to\n   computer.  For example, in a simulation of air traffic in the\n   Northeast the program fragment simulating the New York Enroute air\n   space could move from Host2 to Host5 (see Figure 3).  As part of the\n   reconfiguration process the New York Terminal area simulator and\n   Boston Enroute area simulators break their connections with New York\n   Enroute simulator at Host2 and reconnect to it at Host5.\n\n   NY Terminal     NY Enroute    Boston Enroute  Boston Terminal\n     _____            _____            _____         _____\n    |     |      /   |     |   \\      |     |       |     |\n    |Host1|\u003c----/---\u003e|Host2|\u003c---\\----\u003e|Host3|\u003c-----\u003e|Host4|\n    |_____|  \\ /     |_____|     \\ /  |_____|       |_____|\n              X        move       X\n             / \\        |        / \\\n             |  \\       V       /  |\n             V   \\    _____    /   V\n      reconnect   \\  |     |  /   reconnect\n                   -\u003e|Host5|\u003c-\n                     |_____|\n                    NY Enroute\n\n                             Figure 3\n2. A Reconnection Mechanism\n\n   The mechanism proposed here could be added to the existing Host-Host\n   protocol or to the TELNET protocol.  The mechanism is first described\n   and then its adaptation to each of the protocols is discussed.\n\n      The reconnection mechanism includes four commands:\n\n         Reconnect Request: RRQ \u003cpath\u003e\n         Reconnect OK:      ROK \u003cpath\u003e\n         Reconnect No:      RNO \u003cpath\u003e\n         Reconnect Do:      RDO \u003cpath\u003e \u003cnew destination\u003e\n\n   where \u003cpath\u003e is the communication path to be redirected to \u003cnew\n   destination\u003e.\n\n   Assume that H1 wants to move its end of communication path A-C from\n   itself to port D at H3 (See figure 4).\n\n\n\nThomas                                                          [Page 3]\n\f\nRFC 426                  Reconnection Protocol              January 1973\n\n\n     (a) situation                 (b) desired situation\n\n     H2          H3                  H2           H3\n    ___         ___                 ___          ___\n   |   |       |   |               |   |        |   |\n   |  C|\u003c-+    |D  |               |  C|\u003c------\u003e|D  |\n   |___|  |    |___|               |___|        |___|\n          |\n          |\n          |   ___                             ___\n          |  |   |                           |   |\n          +-\u003e|A  |                           |A  |\n             |___|                           |___|\n               H1                              H1\n\n                          Figure 4\n\n\n   The reconnection proceeds by steps:\n\n           a. H1 arranges for the reconnection by sending RRQ to\n              H2:\n                   H1-\u003eH2:   RRQ (path A-C)\n\n           b. H2 agrees to reconnect and acknowledges with ROK:\n\n                   H2-\u003eH1:   ROK (path C-A)\n\n           c. H1 notes that H2 has agreed to reconnect and\n              instructs H2 to perform the reconnection:\n\n                   H1-\u003eH2:   RDO (path A-C) (Host H3, Port D)\n\n           d. H1 breaks paths A-C.\n              H2 breaks path C-A and initiates path C-D.\n\n   In order for the reconnection to succeed H1 must, of course, have\n   arranged for H3's cooperation.  One way H1 could do this would be to\n   establish the path B-D and then proceed through the reconnection\n   protocol exchange with H3 concurrently with its exchange with H2 (See\n   Figure 5):\n\n           H1-\u003eH3:  RRQ (path B-D)\n           H3-\u003eH1:  ROK (path D-B)\n           H1-\u003eH3:  RDO (path B-D) (Host H2, Port C)\n\n\n\n\n\n\nThomas                                                          [Page 4]\n\f\nRFC 426                  Reconnection Protocol              January 1973\n\n\n          H2                                   H3\n        ______                               ______\n       |      |                             |      |\n       |   C  |                             |  D   |\n        ---\\--                               -/----\n            \\       /--\u003e          \u003c--\\       /\n              \\- -/--- --- --- --- --- \\---/\n               \\ /                      \\ /\n                X                        X\n               / \\                      / \\\n              /   \\                    /   \\\n    reconnection   \\                  /   reconnection\n                    \\    ________    /\n                     ---|A      B|---\n                        |        |\n                        |________|\n                            H1\n\n                          Figure 5\n\n   Either of the parties may use the RNO command to refuse or abort the\n   reconnection.  H2 could respond to H1's RRQ with RNO; H1 can abort\n   the reconnection by responding to ROK with RNO rather than RDO.\n\n   It is easy to insure that messages in transit are not lost during the\n   reconnection.  Receipt of the ROK message by H1 is taken to mean that\n   no further messages are coming from H2; similarly receipt of RDO from\n   H1 by H2 is taken to mean that no further messages are coming from\n   H1.\n\n   To complete the specification of the reconnection mechanism consider\n   the situation in which two \"adjacent\" entities initiate\n   reconnections:\n\n      (a) situation               (b) desired situation\n\n     H1            H4                H1            H4\n    ____          ____              ____          ____\n   |    |        |    |            |    |        |    |\n   |   C|        |E   |            |   C|--------|E   |\n   |____|        |____|            |____|        |____|\n\n     H2            H3                H2            H3\n    ____          ____              ____          ____\n   |    |        |    |            |    |        |    |\n   |   B|--------|D   |            |   B|        |D   |\n   |____|        |____|            |____|        |____|\n\n\n\n\nThomas                                                          [Page 5]\n\f\nRFC 426                  Reconnection Protocol              January 1973\n\n\n   H2 and H3 \"simultaneously\" try to arrange for reconnection:\n\n           H2-\u003eH3:  RRQ (path B-D)\n           H3-\u003eH2:  RRQ (path D-B)\n\n   Thus, H2 sees an RRQ from H3 rather than an ROK or RNO in response to\n   its RRQ to H3.  This \"race\" situation can be resolved by having the\n   reconnections proceed in series rather than in parallel: first one\n   entity (say H2) performs its reconnect and then the other (H3)\n   performs its reconnect. There are several means that could be used to\n   decide which gets to go first.  Perhaps the simplest is to base the\n   decision on sockets and site addresses: the entity for which the 40\n   bit number formed by concatenating the 32 bit socket number with the\n   8 bit site address is largest gets to go first.  Using this mechanism\n   the rule is the following:\n\n      If H2 receives an RRQ from H3 in response to an RRQ of its own:\n         (let NH2,NH3 = the 40 bit numbers corresponding to H2 and H[2])\n\n      a. if NH2\u003eNH3 then both H2 and H3 interpret H3's RRQ as an ROK in\n         response to H2's RRQ.\n\n      b. if NH2\u003cNH3 then both interpret H3's RRQ as an RNO in response\n         to H2's RRQ.  This would be the only case in which it makes\n         sense to \"ignore\" the refusal and try again - of course,\n         waiting until completion of the first reconnect before doing\n         so.\n\n   Once an ordering has been determined the reconnection proceeds as\n   though there was no conflict.\n\n   The following diagram describes the legal protocol command/response\n   exchange sequences for a reconnection initiated by P:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThomas                                                          [Page 6]\n\f\nRFC 426                  Reconnection Protocol              January 1973\n\n\n                        ___                 ___\n                       | P |---------------| Q |\n                       |___|               |___|\n    ____________________\n   | P --\u003e Q ||  R R Q  |\n   |_________||_________|\n                  |\n        +---------+\n        |\n    ____V_______________________________________\n   |         ||         |             |         |\n   | Q --\u003e P ||  R O K  |  R N O  ----|  R R Q  |\n   |         ||         |         | E |         |\n   |_________||_________|_________|___|_________|\n                   |                       |\n      +------------+                       v\n      |                      Yes   +----------+   No\n      |   +------------------------| NP \u003e NQ? |------+\n      |   |                        +----------+      |\n    __v___v_______________________________           |\n   |         ||             |             |          |\n   | P --\u003e Q ||  R D O  ----|  R N O  ----|          |\n   |         ||         | E |         | E |          |\n   |_________||_________|___|_________|___|          |\n                                                     |\n        +--------------------------------------------+\n        |\n    ____v_________________________________\n   |         ||             |             |\n   | Q --\u003e P ||  R D O  ----|  R N O  ----|\n   |         ||         | E |         | E |\n   |_________||_________|___|_________|___|\n\n   NP and NQ are the 40 bit numbers for P and Q; E indicates end of\n   sequence.\n\n3.  Adding the Reconnection Mechanism to Host-Host Protocol\n\n        The four reconnect commands could be included directly in\n        Host-Host protocol as follows:\n\n           RRQ \u003cmy socket\u003e \u003cyour socket\u003e\n           ROK \u003cmy socket\u003e \u003cyour socket\u003e\n           RNO \u003cmy socket\u003e \u003cyour socket\u003e\n           RDO \u003cmy socket\u003e \u003cyour socket\u003e \u003cnew host\u003e \u003cnew socket\u003e\n\n   The ROK and RDO commands for a send connection should not be sent\n   until there are no messages in transit over the connection.  The RDO\n\n\n\nThomas                                                          [Page 7]\n\f\nRFC 426                  Reconnection Protocol              January 1973\n\n\n   command is to be interpreted as a CLS.\n\n   The reconnection:\n\n     H2           H3                    H2           H3\n    ___          ___                   ___          ___\n   |   |        |   |                 |  C|--------|D  |\n   |_C_|        |_D_|                 |___|        |___|\n     |            |\n     |            |        ===\u003e\n     |    ____    |                          ____\n      ---|A  B|---                          |    |\n         |____|                             |____|\n           H1                                 H1\n\n    could be accomplished as follows:\n\n         H1-\u003eH2:  RRQ A C\n         H1-\u003eH3:  RRQ B D\n         H2-\u003eH1:  ROK C A\n         H3-\u003eH1:  ROK D B\n         H1-\u003eH2:  RDO A C H3 D\n         H1-\u003eH3:  RDO B D H2 C\n         H2-\u003eH1:  CLS C A\n         H3-\u003eH1:  CLS D B\n         H2-\u003eH3:  STR C D size\n         H3-\u003eH2:  RTS D C link\n\n   Note that it is possible for the STR from H2 to arrive at H3 before\n   the RDO from H1.  H3 must be prepared to queue such an RFC until it\n   gets an RDO or RNO from H1.  Stated differently, transmission of an\n   ROK for a local socket causes the socket to move from an \"open\" state\n   to a \"reconnect pending\" state and indicates willingness to queue\n   subsequent RFC's until receipt of a \"matching\" RDO or RNO.\n\n4. Reconnection in TELNET Protocol\n\n   Independently of whether Host-Host protocol directly supports\n   reconnection, the reconnection mechanism could be included in TELNET\n   with the addition to the TELNET protocol of the five commands:\n\n         RRQ\n         ROK\n         RNO\n         RDO \u003chost\u003e \u003csocket\u003e\n         RWT \u003chost\u003e \u003csocket\u003e\n\n\n\n\n\nThomas                                                          [Page 8]\n\f\nRFC 426                  Reconnection Protocol              January 1973\n\n\n   where RRQ, ROK, RNO, RDO, and RWT are appropriately chosen characters\n   in the range 128 to 255.  The first three commands require no\n   parameters since they refer to the connections they are received on.\n   For RDO and RWT, \u003chost\u003e is an 8 bit (= 1 TELNET character) host\n   address and \u003csocket\u003e is a 32 bit (= 4 TELNET characters) number that\n   specifies a TELNET receive socket at the specified host.\n\n   A pending reconnection can be activated with either RDO or RWT.  The\n   response to either is to first break the TELNET connection with the\n   sender and then reopen the TELNET connection to the host and sockets\n   specified.  For RDO, the connection is to be reopened by sending two\n   RFC's; for RWT, by waiting for two RFC's.\n\n   The RWT command is introduced to avoid races such as the one between\n   the STR and CLS (RDO) discussed above.  In Host-Host protocol the\n   race is avoided by putting a connection into \"reconnect pending\"\n   state upon transmission of ROK.  For TELNET the race can be avoided\n   by the initiator of the reconnection by judicious use of RWT and RDO.\n   For example the reconnection:\n\n     H2                           H3          H2           H3\n   +---+                        +---+       +---+   M    +---+\n   |   |----+             +----\u003e|   |       |   |-------\u003e|   |\n   | Y | N  |             |  Q  | Z |   ==\u003e | Y |   N    | Z |\n   |   |\u003c-+ |      H1     | +---|   |       |   |\u003c-------|   |\n   +---+  | | M  +---+  P | |   +---+       +---+        +---+\n          | +---\u003e|   |----+ |\n          |      | X |      |                        H1\n          +------|   |\u003c-----+                      +---+\n                 +---+                             |   |\n                   H1                              | X |\n                                                   |   |\n                                                   +---+\n   could be accomplished as follows:\n\n           X-\u003eY:  RRQ\n           X-\u003eZ:  RRQ\n           Y-\u003eX:  ROK\n           Z-\u003eX:  ROK\n           X-\u003eY:  RWT  H3 P\n           X closes connections to Y\n           Y closes connections to X\n           Y waits for STR and RTS from H3\n           X-\u003eZ: RDO H2 N\n           X closes connections to Z\n           Z closes connections to X\n           Z sends STR and RTS to H2 which Y answers with\n             matching RTS and STR to complete reconnection\n\n\n\nThomas                                                          [Page 9]\n\f\nRFC 426                  Reconnection Protocol              January 1973\n\n\n   The reconnection mechanism for TELNET can be made to fit nicely into\n   the command format suggested by Cosell and Walden in RFC #435.\n   Consider the addition of three new commands to TELNET:\n\n        Prepare for Reconnect:                 RCP\n        Begin Reconnect by sending RFC's:      RCS\n        Begin Reconnect by waiting for RFC's:  RCW\n\n   Using these three command and the DO, DON'T, WILL, WON'T commands of\n   RFC #435, the commands proposed earlier become:\n\n        RRQ =\u003e DO RCP\n        ROK =\u003e WILL RCP\n        RNO =\u003e WON'T RCP  ;for responses to DO RCP\n               DON'T RCP  ;for responses to WILL RCP\n                          ;i.e. used to cancel an RCP.\n        RDO \u003chost\u003e \u003csocket\u003e =\u003e DO RCS \u003chost\u003e \u003csocket\u003e\n        RWT \u003chost\u003e \u003csocket\u003e =\u003e DO RCW \u003chost\u003e \u003csocket\u003e\n\n   As RFC #435 notes the nice thing about this structure is that a host\n   choosing not to implement reconnection does not even have to know\n   what RCP means.  All that it need do in response to DO RCP is to\n   transmit WON'T RCP.\n\n5. Recommendation\n\n   I feel that reconnection is a basic notion and that its proper place\n   within the protocol hierarchy is at the Host-Host level where it\n   would be available for use in all higher level protocols.  The\n   difficulty is that placing it there would, of course, require NCP\n   rewrites.  Reluctance to make NCP modifications would probably be\n   sufficient to kill interest in the proposal.\n\n   Therefore, for pragmatic reasons, I recommend that the reconnection\n   mechanism be included in TELNET as an \"option\" in the spirit of RFC\n   #435.  This can be accomplished with the addition to the TELNET\n   protocol of the RCP, RCS, RCW commands as described in Section 4.\n   Modification of user- and server-TELNET programs to handle these new\n   commands should be straightforward.  If a reconnection option is made\n   part of TELNET protocol the TENEX hosts will support it.  In\n   addition, the TIP guys (Walden and Cosell) have said that they like\n   the reconnection mechanism and have agreed, in principle, to\n   implement it for TIPs if it is accepted as part of TELNET protocol.\n\n\n\n\n\n\n\n\nThomas                                                         [Page 10]\n\f\nRFC 426                  Reconnection Protocol              January 1973\n\n\n   Addition of reconnection at the TELNET level rather than the Host-\n   Host level is admittedly a compromise.  However, with it, activity of\n   the sort described in Examples A and B of Section 1 will be possible.\n\n6. Additional Remarks\n\nA. Reconnection is not a new notion.  An early proposal for Host-Host\n   protocol (RFC #36) included facilities to support reconnection.  The\n   reconnection mechanism in RFC #36 supposes a configuration in which\n   entities are \"daisy-chained\" together by connections:\n\n          __      __      __      __      __\n      ___|  |____|  |____|  |____|  |____|  |___\n         |__|    |__|    |__|    |__|    |__|\n\n   and specifies how one or more entities can break out of the chain.\n   As suggested above (Figure 5) the mechanism proposed in this note\n   supports that kind of reconnection.\n\nB. In practice one would expect simultaneous initiation of reconnects by\n   adjacent entities to be relatively rare.\n\nC. The approach taken in RFC  #36 to handle simultaneous reconnection\n   attempts by entities adjacent in the chain is to accomplish the\n   reconnect as a single, carefully coordinated, global reconnect.  I\n   feel that the sequence of locally coordinated reconnects as proposed\n   above is preferable.  When N adjacent entities simultaneously attempt\n   reconnection the single, globally coordinated reconnect as outlined\n   in RFC #36 requires ~N^2 control messages whereas the sequential\n   locally coordinated reconnect requires ~N.\n\nD. A word about security is in order.  It should be clear that the\n   decision to accept or reject a particular reconnection request is the\n   responsibility of the entity (person at a terminal or process) using\n   the connection. In many cases the entity may choose to delegate that\n   responsibility to its NCP or TELNET (e.g., Example A, Section 1).\n   However, the interface a Host provides to the reconnection mechanism\n   should include means for local entities to exercise control over\n   response to remotely initiated reconnection requests.  For example, a\n   user-TELNET might support several modes of operation with respect to\n   remotely initiated reconnections:\n\n   1. transparent: all requested reconnections are to be performed in a\n      way that is invisible to the user;\n\n   2. visible: all requested reconnections are to be performed and the\n      user is to be informed whenever a reconnection occurs;\n\n\n\n\nThomas                                                         [Page 11]\n\f\nRFC 426                  Reconnection Protocol              January 1973\n\n\n   3. confirmation: the user is to be informed of each reconnection\n      request which he may accept or reject;\n\n   4. rejection: all requested reconnects are to be rejected.\n\nE. Reconnection can be achieved almost trivially within the Message\n   Switched Protocol (MSP) proposed by Bressler, Murphy and Walden in\n   RFC #333  (within MSP, \"reconnection\" is probably not the correct\n   term).  For example use of the following conventions with that MSP\n   (expressed in the terminology of RFC #333) support reconnection:\n\n   1. unless a reconnection is in progress, rendezvous is to occur at\n      the sending site;\n\n   2. the receiving end of a communication path can be moved by passing\n      the names of the rendezvous site and the ports to the new\n      receiver;\n\n   3. receipt of an OUT message for which the source site differs from\n      the rendezvous site signals that the sending end is being moved;\n      the source site should be used as the rendezvous site for\n      subsequent IN messages;\n\n   4. the sending end of a communication path can be moved by passing\n      the names of the ports to the new sender; to complete the move the\n      new sender uses the previous sender's site as rendezvous site for\n      its first OUT message and its own site as rendezvous for\n      subsequent OUT messages.\n\n   As simple and appealing as this procedure seems, I doubt that it\n   would be used in practice if MSP were to be implemented as a\n   replacement for or alternative to existing Host-Host protocol.  The\n   reason is that the ability to pass ports from Host to Host\n   (needlessly) complicates port name allocation by requiring\n   cooperation among Hosts to manage the allocation (e.g., before a Host\n   can safely allocate a port name for use by a local process it must\n   not only insure that the port is not in use locally but also that no\n   process out in the network is using it.)  The inter-Host cooperation\n   required to support the passage of ports among Hosts can probably not\n   be reliably achieved in practice.  Therefore port passage of the sort\n   described in RFC #333 should not be supported at the Host-Host\n   protocol level.  For this reason, I feel that within an MSP\n   \"reconnection\" would be best handled by a mechanism such as the one\n   proposed in this note.\n\n        [ This RFC was put into machine readable form for entry  ]\n        [ into the online RFC archives by Anthony Anderberg 4/99 ]\n\n\n\n\nThomas                                                         [Page 12]\n\f\n"
}