{
  "series": "Request for Comments",
  "number": "199",
  "howpublished": "RFC 199",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0199",
  "url": "https://www.rfc-editor.org/info/rfc199",
  "title": "Suggestions for a Network Data-Tablet Graphics Protocol",
  "pagetotal": "10",
  "year": "1971",
  "month": "jul",
  "body": "\n\n\n\n\n\nNetwork Working Group                                        T. Williams\nRequest for Comments: 199                                            SDC\nNIC: 7151                                                   15 July 1971\n\n\n        SUGGESTIONS FOR A NETWORK DATA-TABLET GRAPHICS PROTOCOL\n\nDisclaimer\n\n   The work reported herein was supported by the Advanced Research\n   Projects Agency of the Department of Defense under Contract DAHC15-\n   67-C-0149, ARPA Order No. 1327, Amendment No. 3, Program Code No.\n   1D30, and 1P10.\n\n   The views and conclusions contained in this document are those of the\n   author and should not be interpreted as necessarily representing the\n   official policies, either expressed or implied, of the Advanced\n   Research Projects Agency or the U. S. Government.\n\nINTRODUCTION\n\n   The purpose of this document is to add SDC's comments to the\n   discussion of a protocol for network graphics within the ARPA Network\n   community.  In general, we are concerned with the development of the\n   graphics protocol in two areas: non-interactive graphics and data-\n   tablet graphics, as opposed to fully interactive graphics.  By non-\n   interactive graphics we mean situations in which there is little or\n   no requirement for interaction with displays.  Such displays are\n   used, for instance, in data retrieval systems using graphics to\n   display retrieved information in the form of charts, X-Y graphs,\n   histograms, scatter plots, tabular displays, etc.  In these systems,\n   each interaction with the system produces an entirely new display.\n   The displays themselves have little, if any, structure.  There is no\n   necessity to interact with the picture itself other than, perhaps, by\n   the use of light buttons.  It is important that non-interactive\n   graphics be simple to implement and use on the network.  Therefore,\n   we suggest that the graphics protocol design be based upon non-\n   interactive graphics systems and that capabilities needed for\n   interactive graphics be added as a super-set.  This will ensure that\n   the protocol complexities associated with interactive graphics do not\n   impose problems for the user of non-interactive graphics, as they\n   would if a non-interactive subset were developed from a protocol\n   based initially on interactive graphics.  The section of Request for\n   Comment (RFC) 177 describing actual display instructions contains a\n   good basis for the development of a non-interactive graphics\n   protocol.  With it as a starting point, a protocol for the generation\n   of a picture can be developed, and the organizational and structural\n   information useful for interactive graphics can be developed later.\n\n\n\nWilliams                                                        [Page 1]\n\f\nRFC 199          SUGGESTIONS FOR A NETWORK DATA-TABLET      15 July 1971\n\n\nDATA-TABLET GRAPHIC INPUTS\n\n   Our primary topic of concern is data-tablet graphics.  Though there\n   are a variety of data-tablet implementation, their functional\n   characteristics are similar enough that they can be treated as a\n   single class.\n\n   Data-tablet input consists of a triple of information--X, Y, Z--where\n   X is the distance along the abscissa, Y is the distance along the\n   ordinate (the two quantities are usually measured to a precision of 1\n   in 1024), and Z is the distance above the writing plane.  There are a\n   variety of encodings for Z, from a simple binary quantity, on or off,\n   to three or more values giving various distances, from on the surface\n   to several inches above; for our purposes here, we will consider Z as\n   a binary entity.\n\n   Input timing may also vary, depending on the tablet implementation\n   and installation interface.  Timing varies from a single shot, where\n   only one coordinate point is input for each new time that Z indicates\n   that the stylus is on the writing surface; to asynchronous, where the\n   tablet input is sampled on demand from the driving program or\n   interface logic when certain conditions are met, such as that the pen\n   has moved a certain amount from the previous sample or that the\n   program is ready for another data sample after a variable amount of\n   processing; to clocked synchronous, where a timing pulse provides the\n   sampling demand.  Clock rates vary from a few (one or two) samples\n   per second to nearly 5000 samples per second.  Some clocks are fixed,\n   while others are controlled either by program or external switches.\n\n   Relative to the amount of picture information contained in the data\n   stream, in general, the data-tablet input is far more voluminous than\n   a similar computer generated image.  Additionally, the data-tablet\n   input stream contains temporal information that, in certain cases, is\n   vital to the proper processing of the input.  Therefore, ways must be\n   found to implement a data-tablet graphics protocol that is flexible\n   enough to accommodate a broad spectrum of data volume and that is\n   compatible with the protocol for non-interactive display images.\n\nPROPOSED DATA-TABLET INPUT PROTOCOLS\n\n   Data tablet input can consist of anything from a single point (as\n   would occur when something was being pointed at) to literally\n   thousands of bytes representing a hand-drawn rendering of a picture\n   or a line of text.  In many instances, the raw data-tablet input is\n   preprocessed before it is passed to the principal processing program.\n   This preprocessing can consist of such things as a variety of\n   smoothing algorithms, filtering for thinning and or redundancy\n   removal, detection of certain operator actions such as uniquely\n\n\n\nWilliams                                                        [Page 2]\n\f\nRFC 199          SUGGESTIONS FOR A NETWORK DATA-TABLET      15 July 1971\n\n\n   marking each occurrence of placing the pen on the writing surface and\n   raising it, and possibly other, more exotic processes such as corner\n   detection, fitting straight-line segments, and the like.  Most of\n   these latter processes will not be considered for inclusion in the\n   protocol, since they are usually unique to a particular investigator\n   and his research.\n\n   Therefore, a data-tablet graphic protocol should permit the sender to\n   specify, and the receiver to discriminate among, at least four types\n   of data-tablet input:\n\n      1)  Single-shot data\n\n      2)  Unpreprocessed (raw) asynchronous data\n\n      3)  Unpreprocessed (raw) synchronous data\n\n      4)  Preprocessed data\n\n   We will define formats for the first three, then discuss the fourth\n   in some detail before defining its format.\n\n   To reduce the number of bits transmitted, data-tablet information\n   should be transmitted in incremental form:  a first point, followed\n   by the difference between each point and its predecessor.  To\n   eliminate the trailing zeros that may be required for compatibility\n   with the standard network graphics screen, we have included provision\n   for a scale factor by which all increments should be multiplied\n   before use.\n\n      Single-Shot Data Input Format:\n\n      Byte 0:   Data tablet input op code\n\n      Byte 1:   Type, 0 = single shot\n\n      Byte 2-3: X - Coordinate\n\n      Byte 4-5: Y - Coordinate\n\n            8          8            16             16\n      +----------+----------+---------------+---------------+\n      | Op code  |     0    |   X - coord.  |    Y coord.   |\n      +----------+----------+---------------+---------------+\n            0          1         2     3         4     5\n\n\n\n\n\n\nWilliams                                                        [Page 3]\n\f\nRFC 199          SUGGESTIONS FOR A NETWORK DATA-TABLET      15 July 1971\n\n\n   In the following proposal for other protocols, it is assumed that\n   each \"stroke\" of the pen is sent as one entity, a stroke being the\n   data generated (and processed) between the time that Z indicates that\n   the stylus or pen is on the writing surface and the time it is lifted\n   from the surface.\n\n      Unpreprocessed (Raw) Asynchronous Data Input Format:\n\n      Byte 0:     Data tablet input op code\n\n      Byte 1:     Type, 1 = raw asynchronous\n\n      Byte 2:     Flags\n\n      Byte 3:     Scale of deltas\n\n      Byte 4-5:   Number of points\n\n      Byte 6-7:   1st X-coordinate\n\n      Byte 8-9:   1st Y-coordinate\n\n      Byte 10:    delta X1\n\n      Byte 11:    delta Y1\n\n          .\n          .\n          .\n\n      Byte 2n+10: delta Xn\n\n      Byte 2n+11: delta Yn\n\n\n 8   8    8     8      16      16      16     8     8        8     8\n+--+---+-----+-----+---.---+---.---+---.---+-----+-----+  +-----+-----+\n|Op| 1 |Flags|Scale|  N.o  |   .   |   .   |delta|delta|..|delta|delta|\n|  |   |     |     |poi.nts| X0.   | Y0.   | X1  | Y2  |  | Xn  | Yn  |\n+--+---+-----+-----+-------+-------+-------+-----+-----+  +-----+-----+\n 0   1    2     3    4   5   6   7   8   9   10     11     2n+10 2n+11\n\n\n\n\n\n\n\n\n\n\nWilliams                                                        [Page 4]\n\f\nRFC 199          SUGGESTIONS FOR A NETWORK DATA-TABLET      15 July 1971\n\n\n      Unpreprocessed (Raw) Synchronous Data Input Format:\n\n      Byte 0:     Data tablet input op code\n\n      Byte 1:     Type, 2 = raw synchronous\n\n      Byte 2:     Flags\n\n      Byte 3:     Scale of deltas\n\n      Byte 4:     Sampling rate to the nearest 100 usec\n\n      Byte 5-6:   Number of points\n\n      Byte 7-8:   1st X-coordinate\n\n      Byte 9-10:  1st Y-coordinate\n\n      Byte 11:    delta X1\n                          (sign magnitude code)\n      Byte 12:    delta Y1\n          .\n          .\n          .\n\n      Byte 2n+11: delta Xn\n\n      Byte 2n+12: delta Yn\n\n 8  8   8     8    8     16      16    16    8     8        8     8\n+--+-+-----+-----+----+---.---+---.-+---.-+-----+-----+  +-----+-----+\n|Op|2|Flags|Scale|Rate|  N.o  | X0. | Y0. |delta|delta|..|delta|delta|\n|  | |     |     |    |poi.nts|   . |   . | X1  | Y1  |  | Xn  | Yn  |\n+--+-+-----+-----+----+----------+--+-----+-----+-----+  +-----+-----+\n 0  1   2     3    4    5   6  7  8  9  10   11   12      2n+11 2n+12\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWilliams                                                        [Page 5]\n\f\nRFC 199          SUGGESTIONS FOR A NETWORK DATA-TABLET      15 July 1971\n\n\nPREPROCESSED-DATA INPUT FORMAT\n\n   There are a variety of processes that can be applied to raw tablet\n   data before it is transmitted to the requesting program.  For\n   instance, when the tablet is \"noisy\" or jittery, various smoothing\n   algorithms may be applied.  The most common of these is some form of\n   weighted, clumped or moving average.  At SDC, we have settled on an\n   8-point moving average when smoothing is desirable.  Another fairly\n   common form of preprocessing is \"thinning\" or filtering to remove\n   unnecessary or redundant data points.  Depending on the end use of\n   the data, filter \"windows\" can have a variety of geometries,\n   including square, rectangular, diamond, and circular, and the filter\n   may be single or double windowed.  SDC currently uses a single square\n   window filter on all tablet input.  The window size is a variable and\n   may be set to zero, thus, eliminating the filter.\n\n   Logically, the filter may be described as:\n\n      Take (X,Y) if |Xp - X| \u003e= w or |Yp - Y| \u003e= w is true\n\n   where: (X,Y) is the current data point, (Xp,Yp) is the previously\n   accepted data point that either passed the filter or was the first\n   point of the stroke, and w is the window size.\n\n      Pictorially, this can be represented as:\n\n         ---- +-------------+-----\n          ^   |             |  ^\n          |   |             |  |\n              |             |  W\n          2W  |  Xp, Yp   __|__v__\n              |             |\n          |   |             |\n          v   |             |\n         -----+-------------+\n              | \u003c-- 2W --\u003e  |\n\n   Any point inside the square will be rejected, any point on the\n   boundary or beyond is accepted and becomes (Xp,Yp).  In addition to\n   smoothing and filtering, we have found it necessary that our\n   character recognition algorithms be able to estimate the velocity\n   along the path of the stroke.  Therefore in addition to saving the X,\n   Y coordinates that pass the filter (smoothing, if done, precedes\n   filtering and is done on the raw points), we count and store the\n   number of rejected points between the saved ones.  Since the data-\n   tablet input is synchronous, the count times the sampling rate\n   divided into the distance between adjacent points is a sufficient\n   approximation for our purposes.  Our character-generator also\n\n\n\nWilliams                                                        [Page 6]\n\f\nRFC 199          SUGGESTIONS FOR A NETWORK DATA-TABLET      15 July 1971\n\n\n   requires the rectangle surrounding a stroke (defined by the minimum\n   and maximum values of X and Y in the stroke); this information is\n   very easy to generate during preprocessing.\n\n   Assuming that other Network nodes wanted to use SDC's tablet graphic\n   software--the character recognizer in particular--we would have to\n   know what, if any, preprocessing was done to the input data before it\n   was sent.  Our suggested format for this from of tablet data, then,\n   is:\n\n      Byte 0:     Data tablet op code\n\n      Byte 1:     Type, 3 = preprocessed\n\n      Byte 2:     Flags\n\n      Byte 3:     Scale of deltas\n\n      Byte 4:     Sampling rate if synchronous (as indicated by flag)\n\n      Byte 5:     Window Size\n\n      Byte 6-7:   Number of Points\n\n      Byte 8-9:   1st X-coordinate\n\n      Byte 10-11: 1st Y-coordinate\n\n      Byte 12-13: Minimum value of X in the stroke\n\n      Byte 14-15: Minimum value of Y in the stroke\n\n      Byte 16-17: Minimum value of X in the stroke\n\n      Byte 18-19: Minimum value of Y in the stroke\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWilliams                                                        [Page 7]\n\f\nRFC 199          SUGGESTIONS FOR A NETWORK DATA-TABLET      15 July 1971\n\n\n   Two forms follow from here, depending upon another flag:\n\n        Counts included         and       Counts deleted\n\n        Byte 20:       delta X1           Byte 20:         delta X1\n\n        Byte 21:       delta Y1           Byte 21:         delta Y1\n\n        Byte 22:       rejected point count1\n\n        Byte 3n+20:    delta Xn           Byte 2n+20:      delta Xn\n\n        Byte 3n+21:    delta Xn           Byte 2n+21:      delta Yn\n\n        Byte 3n+22:    RPCn\n\n8  8   8     8     8     8      16    16   16   16    16    16    16\n--+-+-----+-----+-----+------+------+----+----+-----+-----+-----+-----+\n  |3|Flags|Scale|Rate |Window|  #   | X0  | Y0 |Xmin|Ymin |Xmax |Ymax |\n  | |     |     |     | Size |points|     |    |    |     |     |     |\n--+-+-----+-----+-----+------+------+----+----+-----+-----+-----+-----+\n 0 1   2     3     4     5     6  7  8 9 10 11 12 13 14 15 16 17 18 19\n\n\n  8     8     8        8     8     8\n-----+-----+-----+-//-----+-----+-----+\ndelta|delta| RCP1| //delta|delta| RCPn|\nX1   |Y1   |     |    Xn  | Yn  |     |\n-----+-----+-----+-//-----+-----+-----+\n 20    21    22       20     21    22\n\n                       Counts Included\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWilliams                                                        [Page 8]\n\f\nRFC 199          SUGGESTIONS FOR A NETWORK DATA-TABLET      15 July 1971\n\n\n8  8   8     8     8     8      16    16   16   16    16    16    16\n--+-+-----+-----+-----+------+------+----+----+-----+-----+-----+-----+\nOp|3|Flags|Scale|Rate |Window|  #   | X0 | Y0 |Xmin |Ymin |Xmax |Ymax |\n  | |     |     |     | Size |points|    |    |     |     |     |     |\n--+-+-----+-----+-----+------+------+----+----+-----+-----+-----+-----+\n 0 1   2     3     4     5     6  7  8 9 10 11 12 13 14 15 16 17 18 19\n\n\n  8     8     8        8     8\n-----+-----+-----+   +-----+-----+\ndelta|delta|delta|...|delta|delta|\nX1   |Y1   |  X2 |   |Xn   |Yn   |\n-----+-----+-----+   +-----+-----+\n 20    21    22       2n+20 2n+21\n\n                       Counts deleted\n\n\n   The flags in this format not only indicated whether or not the data\n   is synchronous and whether the counts are present, but may also be\n   used to indicate whether or not the data was smoothed and the type of\n   filtering.\n\nCHARACTER SETS AND CHARACTER GENERATION\n\n   Our work in character recognition impacts the proposed protocols in\n   one other area, that of character sets and character generation.\n   Figure 1 shows the displayable characters presently available.  We\n   have planned extensions that will bring the set to 192 characters.\n   The availability and use of our and others' extended character sets\n   must be provided for in the protocol.\n\n   The character-set problem, though, is the easy one.  We have found\n   that when dealing with hand-printed input, the computer-generated\n   output must be flexible enough to retain the geometry of the user's\n   input--at least temporarily.  This requires that we be able to\n   generate characters in a large variety of sizes, with variable aspect\n   ratios (independently specified sizes for X and Y).  Since this is\n   not an available hardware function, all of our characters are program\n   generated.  We currently specify character size and ratios in terms\n   of X and Y multipliers applied to a character prototype.  The\n   character prototype is constructed on a 5\" x 7\" grid (extended, if\n   necessary to handle the long tails on p's, q's, etc.), where the\n   grid-line spacing is 2^-10 times the screen size.  The important\n   point is that network transmission must be capable of specifying\n   those types of characteristics when needed.\n\n\n\n\n\nWilliams                                                        [Page 9]\n\f\nRFC 199          SUGGESTIONS FOR A NETWORK DATA-TABLET      15 July 1971\n\n\n   We propose, then, that a message format that specifies:\n\n   o Character code\n   o Character position\n   o Character height and width\n\n   As an inside, we would rather that the character origin be the left-\n   hand baseline point rather than the center--primarily because the\n   center is ill-defined unless the character space is specified to\n   include vertical extensions in both directions but also because it is\n   difficult to take advantage of variable spacing to justify characters\n   that are of unequal width (an aesthetic consideration of relevance in\n   some displays).\n\n   Figure 1: SDC EXTENDED CHARACTER SET (see PDF file)\n\nEndnote\n\n   Subscript notation is inline.  See the PDF file for a complete view\n   of this document.\n\n\n         [This RFC was put into machine readable form for entry]\n         [into the online RFC archives by Lorrie Shiota, 10/01]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWilliams                                                       [Page 10]\n\f\n"
}