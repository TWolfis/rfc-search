{
  "series": "Request for Comments",
  "number": "94",
  "howpublished": "RFC 94",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0094",
  "url": "https://www.rfc-editor.org/info/rfc94",
  "title": "Some thoughts on Network Graphics",
  "pagetotal": "6",
  "year": "1971",
  "month": "feb",
  "body": "\n\n\n\n\n\nNetwork Working Group                                         E. Harslem\nRequest for Comments: 94                                      J. Heafner\nNIC: 5725                                                3 February 1971\n\n\n                   Some Thoughts on Network Graphics\n\nPurpose\n\n   This note states some of our initial reactions to NWG/RFC #86, whose\n   purpose was to provide a basis for discussion and development of\n   Network graphics.\n\n   The method of operation described in Note 86 was to interpret data\n   structures to produce graphic order codes for display.  This method\n   has proven satisfactory in the past and we favor this approach.  The\n   Note 86 proposal is directed toward a particular concept of operation\n   (i.e., minimal graphics terminal connected to computational\n   facilities at remote sites); our remarks embrace extended operations\n   that include smart programs at each end of the connection as well as\n   the minimal terminal.\n\n   The proposal in Note 86 should be broadened to include the\n   description of more complex entities and it should be raised to a\n   level of describing more general things.  In this note, we first\n   criticize the limitations imposed by the details of Note 86; then\n   suggest some supplementary ingredients to extend its scope; and\n   lastly, we suggest an alternate approach that reduces Network\n   conversations (where possible) to symbol manipulation rather than\n   gross detail.\n\nComments on the Detailed Restrictions of Note 86\n\n   The detailed constraints enumerated in Note 86 restrict many\n   interesting features of the Rand display hardware that we consider\n   necessary (from a human factors standpoint) to some current\n   applications.  They likewise restrict other nodes whose ARPA-\n   sponsored research is dependent upon the use of sophisticated\n   hardware.  For example, the point, vector, and character capability\n   of Note 86 excludes line type mode, intensity control, and many other\n   attractive control operations; the maximum symbol sizes are too small\n   for our large character size; the origin of all of our symbols is\n   specified as the \"centroid\" of the symbol rather than the lower left\n   corner of a virtual rectangle encompassing the symbol; under mode\n   control for plotting purposes, the beam may not be advanced to the\n   next character position; a 7-bit ASCII is insufficient; etc.  In\n   short, the five list items of Note 86 are not expressive enough; for\n   example, there is nothing to allow one to position and open a graphic\n\n\n\nHarslem, et. al.                                                [Page 1]\n\f\nRFC 94             Some Thoughts on Network Graphics       February 1971\n\n\n   compare \"window\".  The problem was not treated of supplying\n   parameters identifying structure for match, etc. that are not actual\n   display commands.\n\n   Perhaps some necessary information gathering (i.e., the display\n   hardware descriptions and the characteristics of every node) is\n   preliminary to the generation of a detailed specification.  It is\n   important that, without delay, a mechanism be defined for gathering\n   and collating this information in such a way that it doesn't deter\n   progress on Network graphics development.\n\nSome General Extensions to the Note 86 Proposal\n\n   1. DISPLAY LANGUAGE CAPABILITIES SHOULD ENCOMPASS THE UNION OF\n      CURRENT AND ANTICIPATED NETWORK GRAPHICS HARDWARE.  Our experience\n      in exploring interactive graphics communication techniques for use\n      by researchers and non-programmers indicates that this is not just\n      a \"motherhood\".  The utility of such applications programs depends\n      highly upon incorporating sophisticated graphics hardware.  In\n      absence of those features, some programs simply won't be used.\n\n   2. THE DATA STRUCTURE SHOULD ALLOW LOGICAL AS WELL AS PICTORIAL\n      REPRESENTATION OF THE USER'S PROBLEM.  This close coupling of the\n      meaning of a picture with the actual picture is desirable from a\n      processing program's point of view, especially if a user is to\n      interact with the picture.  We have found this an efficient way to\n      operate with the GRAIL Project and its derivatives here at Rand.\n      This technique is included in a recently proposed graphics\n      language generated by Bob Anderson (Rand) and Ben Wegbreit\n      (Harvard).\n\n   3. TRANSMIT DEFINITIONS OF GRAPHICS AND THEN INSTANCES OF THEIR USE.\n      The attempt here is to raise the level of \"conversation\" between\n      programs (where possible) and to reduce processing overhead.  For\n      example, if one wishes to draw lots of resistors, why not\n      graphically define a resistor once and then transmit instances by\n      giving the definition name accompanied by attributes? A typical\n      form of an instance is shown below.\n\n         Item Name (position, size, intensity, scaling, labeling,\n                    rotation, etc.)\n\n      There are many examples of this approach such as the recent work\n      by William Newman (Utah) and many earlier studies at MIT.\n\n   4. PARTITION THE DISPLAY STRUCTURE FOR 1) STATIC VS. DYNAMIC\n      INFORMATION, AND 2) CONTEXT.  As opposed to refreshing an entire\n      picture whose domain is the entire screen, we have found it useful\n\n\n\nHarslem, et. al.                                                [Page 2]\n\f\nRFC 94             Some Thoughts on Network Graphics       February 1971\n\n\n      to give the processing routine (that wishes to draw a picture)\n      knowledge of only of a named rectangular portion of the CRT and an\n      accompanying display structure.  With our particular hardware we\n      can then update only the dynamic part of a picture rather than\n      regenerating the entire display structure.  Just as important, we\n      can logically assign areas of the CRT to different concurrent\n      processing routines.  Coupled with the logical/pictorial\n      representation noted in 2) above, this is a powerful technique.\n      Named partitions also naturally accommodate those applications\n      requiring multiple CRTs.\n\n   5. THE INTERPRETER COULD BE CONTEXT-DRIVEN THUS NOT RESTRICTING ITS\n      OUTPUT TO A SINGLE SET OF CRT ORDER CODES.  By providing cataloged\n      descriptions such as the \"forms\" discussed in Note #83, the\n      interpreter could reconfigure data destined for files, etc., as\n      well as a display.  The gain here in terms of adapting to a users'\n      Network needs is large; the price paid in terms of implementing\n      this increment of the interpreter is probably small.\n\nAn Alternate Proposal\n\n   Note 86 mentions the case of a terminal at a node with a minimal HOST\n   connected to a remote computationally-oriented node.  The data\n   standard, which Note 86 suggests transmitting over the Network is\n   rather gross detail.  Also, the standard language is rather\n   inexpressive -- encompassing only a few simple notions.\n\n   An alternative approach is to consider the situation of communication\n   between non-minimal nodes (nodes with substantial memory and\n   computing power).  Here the Network standard data should be a high-\n   level macro form representing the instances of gross detail with the\n   power to deal with sophisticated graphics devices.  That is, the\n   standard language would be rich enough to express all the special\n   features of Network display devices.\n\n   This suggestion presents two problems.  First, how can a terminal\n   handle commands from a remote program of which its hardware is\n   incapable? The answer is that the remote program to which it is\n   connected is too sophisticated for the terminal -- the connection is\n   invalid.  A terminal should NORMALLY only connect to a program that\n   addresses no more than its hardware capabilities.  This concept\n   allows a standard under which a simple terminal and a simple program\n   can communicate (exactly the proposal of Note 86), yet a\n   sophisticated terminal can talk to a sophisticated program in a\n   high-level language, or it can talk to a simple program, all within\n   the same Network standard.\n\n\n\n\n\nHarslem, et. al.                                                [Page 3]\n\f\nRFC 94             Some Thoughts on Network Graphics       February 1971\n\n\n   The second problem is that a minimal host might not have sufficient\n   facilities to translate from a powerful Network standard language\n   into the simple, detailed order codes of its terminals.\n\n   When required, the needs of a minimal site would be handled by\n   another Network node providing data reconfiguration services, AN\n   ESSENTIAL PART OF THIS PROPOSAL.  The reconfiguration would be done\n   on the basis of \"forms\" specifying translation form the Network\n   standard to the specific non-standard data format required by the\n   minimal node (i.e., tailored specifically to its hardware).  Whether\n   it would be graphic order codes or some intermediate form would\n   depend on the processing power and requirements of the minimal node.\n\n   Fig. 1 shows a schematic diagram of the key elements of such a\n   reconfiguration facility.  Fig. 2 shows the use of that facility by a\n   local display handler and its use as an intermediary by two remote\n   nodes requiring different degrees of external data reconfiguration.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHarslem, et. al.                                                [Page 4]\n\f\nRFC 94             Some Thoughts on Network Graphics       February 1971\n\n\n              Network\n                | ^\n                | |\n                | |\n                v |\n          +--------------+\n          | A Network    |     Local\n          | Process      |---\u003e Files, Programs,\n          | Invoking the |\u003c--- CRTs, etc.\n          | Interpreter  |\n          +--------------+\n                | ^\n                | |\n                | |\n                v |\n          +--------------+      +--------------+ (A user can access\n          |              |      |  User's      | the logical\n      |--\u003e| Interpreter  |      |  Semantic    | representation of\n      |   |              |      |  Routines    | his problem.)\n      |   +--------------+      +--------------+\n      |             | ^           | ^\n      |             | |           | |\n      |             | |           | |\n      |             v |           v |\n      |           +-------------------+\n      |           |                   |\n      |           |   Primitive       |\n      |           |   Data Structure  |\n      |           |   Operators       |\n      |           |                   |\n      |           +-------------------+\n      |                           | ^\n      |                           | |\n   +--------------+               | |\n   | Data Base of |               v |\n   | \"Forms\" for  |         +------------------+\n   | Reconfigu-   |         |  Data Structure  |\n   | ration       |         |  Base:           |\n   +--------------+         |  1 - Pictorial   |\n                            |  2 - Logical     |\n                            +------------------+\n\n                   Fig. 1. Data Reconfiguration Service\n\n\n\n\n\n\n\n\nHarslem, et. al.                                                [Page 5]\n\f\nRFC 94             Some Thoughts on Network Graphics       February 1971\n\n\n       Host Providing                        Host Providing\n   Computational Facility                Reconfiguration Service\n   +--------------------+  STANDARD  +-----------------------------+\n   |                    |   FORMAT   |  +----------+ +-----------+ |\n   |                    |------------|--|  Inter-  |-|  Display  | |\n   |                    | (of Macro  | /|  preter  | |  Handler  | |\n   |                    | Form Data) |//+----------+ +-----------+ |\n   +--------------------+            //--------------------|-------+\n                                    //                     |\n                                   /(                +-----------+\n                                  /  \\               | Terminal  |\n                                 /    \\              +-----------+\n                                /      \\\n                               /        \\\n                              /          \\\n                   NON-STD.  /            \\  NON-STD.\n     (Terminal Order Codes) /              \\ (Detailed Data)\n                           /                \\\n                          /                  \\\n                         /                    \\\n                        /                      \\\n                       /                        \\\n                      /                          \\\n                     |                            |\n             +-------|-------+            +-------|-------+\n             |       |       |            | +-----------+ |\n     Minimum |       |       |            | |  Display  | | Minimum\n      Host   |       |       |            | |  Handler  | |  Host\n             |       |       |            | +-----------+ |\n             +-------|-------+            +-------|-------+\n                     |                            |\n               +-----------+                +-----------+\n               | Terminal  |                | Terminal  |\n               +-----------+                +-----------+\n\n                Fig. 2. Use of Data Reconfiguration Service\n\n\n         [ This RFC was put into machine readable form for entry ]\n             [ into the online RFC archives by Sergio Kleiman]\n\n\n\n\n\n\n\n\n\n\n\nHarslem, et. al.                                                [Page 6]\n\f\n"
}