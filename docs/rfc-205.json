{
  "series": "Request for Comments",
  "number": "205",
  "howpublished": "RFC 205",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0205",
  "url": "https://www.rfc-editor.org/info/rfc205",
  "title": "NETCRT - a character display protocol",
  "pagetotal": "13",
  "year": "1971",
  "month": "aug",
  "body": "\n\n\n\n\n\nNetwork Working Group                                          R. Braden\nRequest for Comments: 205                                       UCLA/CCN\nNIC: 7172                                                  6 August 1971\n\n\n                 NETCRT - A CHARACTER DISPLAY PROTOCOL\n\n   At the May NWG, meeting, CCN circulated dittoed copies of a proposed\n   character-display protocol NETCRT.  Since that time, NETCRT has been\n   revised significantly; the current version is now being published as\n   an RFC, as promised last May.\n\n   NETCRT was developed because a particular site (RAND) requested\n   Network access to URSA, CCN's display-based crje system.  The primary\n   use of URSA at UCLA is conversational remote job entry from a display\n   terminal: entering and editing program text, submitting programs for\n   batch execution, and examining job output; URSA is not a general-\n   purpose time-sharing system.\n\n   URSA's text editor is designed for a fast updating character display\n   and cannot be used in any reasonable way from a typewriter-like\n   console.  Therefore, a simple TELNET protocol is not adequate for\n   using the crje function of URSA.  Furthermore, we have assumed that\n   other ARPA sites will have their own text editors, well matched to\n   their own terminals and systems.  Therefore, CCN has implemented\n   NETRJS (see RFC #189), to provide remote job submission and retrieval\n   services, before implementing NETCRT.\n\n   There are a number of other functions in URSA besides crje; some of\n   these would probably be useful to remote users.  URSA contains a\n   comprehensive STATus service, whose constantly-updating displays are\n   \"windows\" into the operation of the machine and the operating system,\n   allowing a user to watch the progress of his jobs through the system.\n   URSA also includes on-line data set (file) utilities, convenient for\n   a user with files stored at CCN.  To obtain access to these\n   facilities, a few sites which use CCN heavily may want to implement\n   NETCRT.  The schedule for implementation of NETCRT at CCN to allow\n   Network access to URSA will depend upon the existence of a user site\n   that wants the service and that will write a suitable NETCRT user\n   process.  Interested sites are urged to contact the CCN Technical\n   Liaison, Bob Braden.\n\n   Even though the implementation schedule for NETCRT is nebulous, we\n   are publishing the specs now for several reasons.  First, we would\n   like comments and criticisms.  Furthermore, NETCRT contains some\n   features which may be useful in the protocol(s) now being developed\n   for full graphical displays.\n\n\n\n\nBraden                                                          [Page 1]\n\f\nRFC 205          NETCRT - A CHARACTER DISPLAY PROTOCOL     6 August 1971\n\n\nNETCRT PROTOCOL - VERSION 3\n\nA. INTRODUCTION\n\n   The UCLA Campus Computing Network (CCN) node intends to provide\n   Network access to its conversational remote job entry system URSA.\n   The URSA system is display-oriented, supporting only character\n   displays with local buffers (originally IBM 2260 displays, now CCI\n   301 TV display consoles).  This document defines a third-level\n   protocol called NETCRT which allows a Network user in a remote Host\n   to look like a CCI console to URSA.  NETCRT is defined in terms of a\n   virtual character display (\"VCD\") terminal, simulated by a process in\n   the user host.\n\n   URSA, like many on-line console systems, attempts to provide a good\n   man/machine interaction by keeping tight control over the state of\n   the terminal.  On the other hand, the Network Working Group has\n   deliberately built some \"squishiness\" into the standard Network\n   protocols.  We believe this squishiness is a conceptual mistake when\n   dealing with remote man/machine interaction, and we would support\n   protocol revisions to allow control over the effective communication\n   compliance between processes in different hosts.  However, this\n   NETCRT protocol attempts to cope with the present squishiness, which\n   is apparently built into a number of host's NCPs.  In fact, we have\n   arranged things so a host can improve response time and reduce\n   Network traffic with NETCRT by using the message buffering inherent\n   in his NCP.\n\nB. THE VIRTUAL CHARACTER DISPLAY\n\n   A VCD consists of the following virtual hardware (see Figure 1):\n\n   1. A rectangular _display screen_ capable of displaying N lines of M\n      characters.\n\n   2. A _local buffer_ of M x N characters used to refresh the display.\n\n   3. A _cursor register_ which addresses the characters in the buffer\n      (and hence on the screen).  This register controls the writing of\n      text into the local buffer from either the keyboard or the server,\n      and the reading of the local buffer by the server.\n\n   4. A _keyboard_ containing text keys and control keys.  Each text key\n      enters a character into local buffer at the current cursor address\n      and steps the cursor register by 1.\n\n\n\n\n\n\nBraden                                                          [Page 2]\n\f\nRFC 205          NETCRT - A CHARACTER DISPLAY PROTOCOL     6 August 1971\n\n\n   5. A _communication interface_ through which the server CPU can send\n      a stream of _command_ segments to the VCD and receive a stream of\n      _response_ segments from the VCD.  The command segments include\n      control commands to the VCD and text to be written into the local\n      buffer.  Response segments contain status indicators and text read\n      from the buffer.  In addition, both VCD and server may send break\n      signals.\n\n   The current address in the cursor register, an integer between 0 and\n   M x N-1, is displayed as a blitch, underscore, or other visual\n   indication at the corresponding point on the screen; this indication\n   is called the _cursor_.  Position 0 is the upper left corner of the\n   screen.\n\n   The screen is addressed in line (\"row\") order, and read and write\n   operations by the server overflow automatically from one line to the\n   next.  The cursor register is not assumed to operate modulo M x Nxsy.\n   It is possible for a server command to set the cursor register to M x\n   N, one position beyond the last screen position; however, the server\n   should never set the register to an address beyond M x N, and it\n   should not leave the cursor at M x N when the keyboard is unlocked.\n\n   The application program or conversational system using the VCD may\n   format each display screen in a variety of ways, and may use a number\n   of styles of interaction.  One consequence is that the application\n   program might have to look anywhere on the screen (i.e., in the local\n   buffer) to find the input information it requires.  We may consider\n   three alternative mechanisms for transmitting information from the\n   VCD to the serving CPU:\n\n   Mechanism 1    Whenever the user presses a \"Transmit\" control key,\n                  the entire M x N characters in the buffer are\n                  transmitted to the server CPU.\n\n   Mechanism 2    When the user presses \"Transmit\", the string of text\n                  between a \"start\" control character and the cursor is\n                  transmitted to the server.\n\n   Mechanism 3    The server must send a read command segment to the VCD\n                  before the \"Transmit\" key will have an effect.  The\n                  read command segment determines which parts of the\n                  buffer are to be transmitted to the server.\n\n   Mechanism 1 may be faulted as too costly in transmission time and\n   channel capacity, while Mechanism 2 is too restrictive.  The scheme\n   which we propose here is based on Mechanism 3, which subsumes the\n   other two.\n\n\n\n\nBraden                                                          [Page 3]\n\f\nRFC 205          NETCRT - A CHARACTER DISPLAY PROTOCOL     6 August 1971\n\n\n   The VCD is assumed to include the following control keys:\n\n   Erase          Clears the display buffer to all blanks and resets the\n                  cursor to position 0 (the upper left corner of the\n                  screen).\n\n   Transmit       Locks the keyboard and places the VCD under control of\n                  the server CPU.  Typically, the server will read\n                  specified areas of the screen and perhaps write out\n                  new data before unlocking the keyboard again.\n\n   Break          Has the same effect as _Transmit_, and in addition\n                  sends an interrupt message to the server CPU.  The\n                  _Break_ key always sends the interrupt, regardless of\n                  the state of the VCD.\n\n   Reset          May be used to unlock the VCD keyboard in case the\n                  server CPU fails to respond immediately and the user\n                  wishes to enter new or different information.\n\n   These may be called pure control keys, since they do not correspond\n   to any text characters.  The following control key does store a\n   character into the display buffer:\n\n   Newline        Enter a Newline (NL) character into the display buffer\n                  and reset the cursor to the beginning of the next\n                  line.  If this character is encountered during a read\n                  or write operation, it is executed (i.e., the cursor\n                  is moved to the beginning of the next line) and the NL\n                  is counted as _one_ character.\n\n   Finally, there are assumed to be keys for manually positioning the\n   cursor to any address on the screen.  Cursor positioning keys may\n   include: cursor right, cursor up, cursor left (BS), cursor down (LF),\n   and cursor return (CR).  A tab (HT) mechanism could also be defined,\n   although none is included here.\n\nC. VCD STATES\n\n   The VCD has two internal states, _Local_ and _Control_ (see Figure\n   2).\n\n   Local State:   The keyboard is unlocked and all keys are active.  The\n                  VCD does not accept or recognize any commands from\n                  server except (reverse) Break.\n\n\n\n\n\n\nBraden                                                          [Page 4]\n\f\nRFC 205          NETCRT - A CHARACTER DISPLAY PROTOCOL     6 August 1971\n\n\n   Control State: The keyboard is locked, and only the _Break_ and\n                  _Reset_ keys are active.  The VCD accepts and executes\n                  command segments from the server, and returns response\n                  segments as the result of read commands.\n\n   The VCD changes from Local to Control state if either:\n\n      (1) The user presses the _Transmit_ key; or\n\n      (2) the user presses the _Break_ key; or\n\n      (3) the server sends a reverse Break request.\n\n   _Transmit's_ only effect is to enter Control State; _Break_ enters\n   Control State and also sends a break request (INS and X'80') to the\n   server.\n\n   The VCD returns to Local State when either:\n\n   1. The user presses the _Reset_ key; or\n\n   2. the VCD encounters a LOCAL command from the server and is not in\n      the process of synchronizing a reverse break (see section E\n      below).\n\n   We should note that CCI and IBM 2260 character display consoles\n   actually have only one control key (\"Interrupt\" on CCI, \"Enter\" on\n   2260) to perform the functions of both _Break_ and _Transmit_; this\n   one key in fact has the function of the _Break_ key of the VCD.  We\n   have included both _Break_ and _Transmit_ keys in the VCD for\n   generality, but the URSA-NETCRT interface will be programmed to allow\n   a Network user of URSA to either (1) employ the _Break_ key\n   exclusively, or (2) use either _Break_ or _Transmit_ as appropriate.\n   This will be achieved by URSA simply by ignoring those break requests\n   (INS messages) which occur while there are outstanding read commands.\n\nD. VCD COMMANDS\n\n   The server sends the VCD a string of command segments.  These are of\n   varying length, consisting of an op code and none or more parameters.\n   The commands recognized by the VCD are as follows:\n\n\n\n\n\n\n\n\n\n\nBraden                                                          [Page 5]\n\f\nRFC 205          NETCRT - A CHARACTER DISPLAY PROTOCOL     6 August 1971\n\n\n1. Display \u0026 Keyboard Control Commands:\n\n   Command      Parameter(s)               Function\n   -------      ------------       -----------------------------------\n\n   ERASE           none            Erase display and reset cursor to 0.\n                                   i.e, clear the local buffer.\n\n   BLANK           none            Disable display refresh (i.e., blank\n                                   the screen but do not clear the local\n                                   buffer).\n\n   UNBLANK         none            Enable display refresh.\n\n   LOCAL           none            Put VCD in _local_ state.  The result\n                                   is to suspend command interpretation\n                                   and unlock the keyboard.\n\n   SYNC            none            Used to synchronize reverse Break\n                                   from server.  SYNC (X'80) is placed\n                                   in stream by server at same time that\n                                   it sends an INS.  VCD enters Control\n                                   State, synchronizes INS with BREAK\n                                   command (see next section), and\n                                   continues command interpretation.\n\n2. Cursor Control Commands:\n\n   CURSOR  16 bit integer P        Set cursor register to P, where\n                                   0 \u003c= P \u003c= M x N.\n\n   FIND    X'0001' followed        Move the cursor to point to an\n           by one character        occurrence of the character c.\n           c                       Specifically, search backwards\n                                   toward lower addresses) from the\n                                   current cursor position and take\n                                   the first occurrences of c (i.e.,\n                                   the one with the largest address).\n                                   If no occurrence is found, leave\n                                   cursor at position 0.\n\n   SAVE            none            Save a copy of the current cursor\n                                   address in local register S.\n\n   RESTORE         none            Replace cursor register contents by\n                                   value S.\n\n\n\n\n\nBraden                                                          [Page 6]\n\f\nRFC 205          NETCRT - A CHARACTER DISPLAY PROTOCOL     6 August 1971\n\n\nI/O Commands:\n\n   WRITE n,text    16 bit integer  Write n bytes of text into display\n                   n, followed by  buffer starting at current cursor\n                   n text bytes.   position and advancing cursor by 1\n                                   for each byte (except NL character\n                                   advances to beginning of next line).\n                                   Here [sigma] + n \u003c= M x N.\n\n   READ n          16 bit integer  Read n bytes starting at the cursor\n                   n.              [sigma] and advancing cursor by one\n                                   for each byte (except NL advances\n                                   cursor to beginning of next line).\n                                   NL counts as one character.  Send the\n                                   text to the server as a response\n                                   segment.  Must have n + [sigma]\n                                   \u003c= M x N.\n\n   SREAD           none            Read S - [sigma] bytes starting from\n                                   the current cursor position [sigma]\n                                   up to (but not including) the cursor\n                                   address stored in register S.  The\n                                   cursor is left in position S as a\n                                   result.  Send the text to the server\n                                   as a response segment.\n\n   AWRITE n,text   16 bit integer  Same as WRITE n, except characters\n                   n, followed by  are not stored in buffer if they\n                   n text bytes.   have a lower cursor address than\n                                   the value in S.\n\n   Here are some applications of these commands in URSA:\n\n   1. One elementary URSA terminal operation reads the screen from\n      position x up to (but not including) the current cursor position.\n      This could be done with the sequence of VCD command segments:\n\n                        SAVE\n                        CURSOR x\n                        SREAD\n\n   2. Another common operation in URSA is to remember the cursor, update\n      specific information on the screen, and replace the cursor.  This\n      can be done by the following 8 + n byte sequence of command\n      segments:\n\n\n\n\n\n\nBraden                                                          [Page 7]\n\f\nRFC 205          NETCRT - A CHARACTER DISPLAY PROTOCOL     6 August 1971\n\n\n                        SAVE\n                        CURSOR x\n                        WRITE n, text\n                        RESTORE\n\n   3. In URSA, the area in which a user is to type his response is\n      usually delimited on the left by a \"Start Symbol\" (graphic '[1]').\n      This is a historical remnant of the IBM 2260, which has only two\n      hardware read operators: read the full screen, and read from the\n      Start Manual Input Symbol (\"SMI\") to the cursor.  The SMI read\n      operation can be simulated easily on the VCD as follows:\n\n                        SAVE\n                        FIND '[1]'\n                        SREAD\n\n   4. The _Break_ (or _Transmit_) key on the VCD may serve the function\n      of the INTerrupt key on a CCI console (or ENTer on an IBM 2260).\n      URSA will often attempt to minimize Network traffic by sending a\n      sequence of commands (one message if allocation allows) like the\n      following:\n\n                                              -+\n            CURSOR m                           |\n            WRITE n, text                       - URSA writes a request\n            LOCAL                              |\n                                              -+\n                                              -+\n                       +-          +-+         |_ User types response\n                       |   _BREAK_   |         |\n      - -User Presses  | _TRANSMIT_  |key - - -+\n                       +-           -+        -+\n              SAVE                             |\n              CURSOR p                          - URSA reads response\n              SREAD                            |\n                                              -+\n\n      At other times, URSA might send the sequence:\n\n                CURSOR m\n                WRITE n,TEXT\n                LOCAL\n                READ  0\n\n      and wait for the INS from the user pressing _Break_ (or the\n      response segment triggered by the zero-length read if he presses\n      _Transmit_); then URSA will send the appropriate read command\n      sequence.\n\n\n\nBraden                                                          [Page 8]\n\f\nRFC 205          NETCRT - A CHARACTER DISPLAY PROTOCOL     6 August 1971\n\n\nF. NETWORK MESSAGE FORMATS\n\n   The VCD connects the server through ICP to a standard socket,\n   establishing thereby a pair of connections between the VCD and the\n   server.  Command segments (server-to-VCD) and response segments\n   (VCD-to-server) are sent over these connections, without regard to\n   physical message boundaries, using byte size 8.  The VCD is defined\n   to operate in a segment-at-a-time mode (rather than character-at-a-\n   time), with local echo.  Therefore, the server never echoes under\n   NETCRT.\n\n   In many cases URSA will send a sequence of command segments (as in\n   the examples of the preceding section) at once; if there is\n   sufficient allcocation they will be sent in the same message.\n   Response time may be improved, therefore, if the user site is able to\n   buffer ahead on command segments.  This buffering does raise break\n   synchronization problems, which are solved in the following manner\n   for reverse (server-to-user) break:\n\n      The server sends an INS on the control link and also a SYNC\n      command (X'80) on the data link to the VCD.  On receiving either,\n      the VCD enters Control State and then achieves synchronization\n      between the INS and BREAK; if the INS arrives first, the VCD\n      executes normally all commands buffered in his host, _except_ it\n      ignores LOCAL commands, until the SYNC appears.  Having achieved\n      synchronization, the VCD continues normal command interpretation\n      (without ignoring ensuring LOCAL commands).\n\n   By this means the server can regain control of the VCD to write new\n   information at any time.  For example, when URSA is used under\n   NETCRT, most WRITE or AWRITE sequences will be preceded by a BREAK\n   from the server, since URSA will not know the current state of the\n   VCD.  Even if URSA left the VCD in Control State, the user might have\n   manually returned his VCD to Local State by pressing _Reset_.\n\n   After receiving an INS, the VCD executes rather than ignores buffered\n   commands so that pending writes will not be lost in case that\n   processing at the user side has been held up temporarily.  The read\n   commands executed after the server sent an INS might be irrelevant to\n   a server, which can ignore the corresponding response segments.  In\n   order to do so, the server simply keeps matching counts of read\n   commands sent and corresponding response segments received.\n\n   Command segments will use the following formats:\n\n   Form 1 (No parameters)  q:OPCODE(8)\n\n      where q = X'80' means SYNC\n\n\n\nBraden                                                          [Page 9]\n\f\nRFC 205          NETCRT - A CHARACTER DISPLAY PROTOCOL     6 August 1971\n\n\n\n                X'91'   \"   LOCAL\n\n                X'92'   \"   ERASE\n\n                X'93'   \"   BLANK\n\n                X'94'   \"   UNBLANK\n\n                X'95'   \"   SAVE\n\n                X'96'   \"   RESTORE\n\n                X'97'   \"   SREAD\n\n   Form 2 (16 bit integer)  q:OPCODE(8) + n:INTEGER(16)\n\n      where q = X'9E' means READ n\n\n            q = X'9C'   \"   CURSOR n\n\n      In both cases, 0 \u003c= n \u003c= M x N\n\n   Form 3 (count and text) q:OPCODE(8) + n:LENGTH(16) + (TEXT(8) = n)\n\n      where q = X'9D' means WRITE\n\n            q = X'9A' means AWRITE\n\n            q = X'9F' and n=1 means FIND\n\n   A response segment, caused by a READ or SREAD command, has the\n   following format:\n\n      RESPONSE \u003c-----X'A1' + CURSOR(16) + n:LENGTH(16) + (TEXT(8) = n)\n\n   where n \u003e 0 is the number of characters actually read.  CURSOR(16) is\n   an integer giving the final cursor position after the corresponding\n   read command.  Note that the command READ 0 is permissible and may be\n   used by the server to find the current cursor position, or to find\n   out when the user presses _Transmit_.\n\n\n\n\n\n\n\n\n\n\nBraden                                                         [Page 10]\n\f\nRFC 205          NETCRT - A CHARACTER DISPLAY PROTOCOL     6 August 1971\n\n\nE.  SCREEN SIZE\n\n   For simplicity and consistency with URSA, we have chosen to treat the\n   cursor as a single integer.  This in turn means that VCD and server\n   must agree upon the number of columns M; it is also desirable for the\n   server to know N.\n\n   The agreement on M and N takes place through a one-sided negotiation.\n   The server is assumed to know what M and N values he can handle and\n   these are published for user sites.  When the VCD is first connected\n   to the server, the VCD must send an Open response segment with the\n   values M and N:\n\n      Open segment \u003c---- X'B1' + M(8) + N(8) + X'0000'\n\n   If the VCD fails to send this segment or the server does not like the\n   values, the server closes the connections and the user is considered\n   logged off.\n\nEndnotes\n\n   [1] Graphic representation of start symbol: shaded triangle on its\n   side.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBraden                                                         [Page 11]\n\f\nRFC 205          NETCRT - A CHARACTER DISPLAY PROTOCOL     6 August 1971\n\n\n                        +---------------+\n                        |               |\n                        | D I S P L A Y |\n                        +---------------+\n                                ^\n                                |\n                                | Refresh\n                                |\n                        +---------------+\n                        |     LOCAL     |    Address\n                        |     BUFFER    |\u003c------------+\n                        +---------------+             |\n                         ^  ^       |                 |\n     +-----------+  text |  |       |                 |\n    /            |_______|  |       |                 |\n   |  KEYBOARD   |          |WRITE  |READ             |\n   +-------------+          |AWRITE |SREAD            |\n                            |       |                 |\n            control         |       v                 |\n                        +---------------+     +---------------+\n                        |      VCD      |     | CURSOR ADDRESS|\n                        |    CONTROL    |\u003c---\u003e|    REGISTER   |\n                        +---------------+     +---------------+\n                            ^       |                 ^\n                            |       |                 |\n                            |       |                 |\n                            |       |                 |\n                            |       |                 |\n                            |       |                 v\n                            |       |         +---------------+\n                            |       |         |       S       |\n                            |       |         |   REGISTER    |\n                            |       |         +---------------+\n                            |       v\n                        +---------------+\n                        |     COMM      |\n                        |   INTERFACE   |\n                        +---------------+\n                            ^       |\n                            |       |\n                            |       v\n                   COMMANDS           RESPONSES\n\n                       Network Connections\n\n              FIGURE 1.  VIRTUAL CHARACTER DISPLAY\n              ------------------------------------\n\n\n\n\nBraden                                                         [Page 12]\n\f\nRFC 205          NETCRT - A CHARACTER DISPLAY PROTOCOL     6 August 1971\n\n\n                      Keyboard Unlocked\n                    No Commands Executed\n\n                   +--------------------+\n                   |                    |\n           +------\u003e|       LOCAL        |------+\n           |  +---\u003e|       State        |      |\n           |  |    +--------------------+      |\n           |  |        |              |        |\n           |  |        |              |        |\n           |  |        |Break         |        |\n           |  |        |              |        |   INS received\n   LOCAL   |  |        | key          |        |\n           |  |        |  [send INS   |        |\n   Command |  |        |   and X'80'] |        |\n   Executed|  |        |              |Transmit|\n           |  | Reset  |              |        |\n           |  |        |              |  key   |\n           |  |  key   |              |        |\n           |  |        v              v        |\n           |  |   +--------------------+       |\n           |  +---|       Control      |\u003c------+\n           |      |        State       |\n           +------|                    |\n            |     +--------------------+\n            |      ^\n            |      |  Keyboard locked,\n            |      |  Execute Commands\n            +------+\n   After INS is\n   received, LOCAL\n   command is ignored\n   until SYNC (X'80')\n   is encountered\n\n                    FIGURE 2.  VCD STATES\n                    ---------------------\n\n\n\n\n\n          [This RFC was put into machine readable form for entry]\n           [into the online RFC archives by Lorrie Shiota, 2/02]\n\n\n\n\n\n\n\nBraden                                                         [Page 13]\n\f\n"
}