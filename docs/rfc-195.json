{
  "series": "Request for Comments",
  "number": "195",
  "howpublished": "RFC 195",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0195",
  "url": "https://www.rfc-editor.org/info/rfc195",
  "title": "Data computers-data descriptions and access language",
  "pagetotal": "4",
  "year": "1971",
  "month": "jul",
  "body": "\n\n\n\n\n\nNetwork Working Group                                        G. H. Mealy\nRequest for Comments: 195                                           HARV\nNIC 7140                                                   16 July, 1971\nCategories:     D.4, D.7\n\n\n        Data Computers -- Data Descriptions and Access Language\n\n   According to the minutes of the NWG meeting in May (RFC 164), it\n   appears that a unified approach to Network data management is being\n   proposed to CCA.  The purpose of this paper is to discuss some of the\n   problems involved and to suggest possible avenues of approach toward\n   their resolution.  Parenthetically, I believe that a non-unified\n   approach leads to even worse problems.\n\n   My main remarks are predicated on a few assumptions and their\n   consequences.  Since some or all may turn out to be wrong, it seems\n   appropriate to state them explicitly.  The steps in the arguments\n   leading from the assumptions to their consequences may appear to be\n   (and in fact may be) less than obvious.  They are all of a piece,\n   however, and revolve around the necessity for doing business with a\n   number of dissimilar HOST systems while attempting to make it\n   unnecessary for an individual user or user program to know the\n   details of data file organization and representation.  Given this as\n   an objective, I believe that the arguments are quite direct.\n\n   Assumptions\n   ------------\n\n      1. We face the usual set of naming, cataloging, protection,\n         backup, etc. problems.\n\n         (I say this only to dismiss the subject as far as the following\n         is concerned.  In my estimation, these problems and feasible\n         solutions are reasonably well understood; our real problem in\n         this area is in reaching agreement on specifics while leaving\n         sufficient ratholes for future expansion).\n\n      2. Files stored will contain arbitrarily complex data objects.\n\n      3. The organization of any file (that is, the way its structure is\n         mapped into physical storage by the data computer) will\n         normally be unknown by the user.\n\n\n\n\n\n\n\n\nHealy                                                           [Page 1]\n\f\nRFC 195                      Data Computers                    July 1971\n\n\n      4. Data items in files may be stored in arbitrary representations\n         (e.g., those of the originating user's HOST rather than that of\n         the data computer or other \"standard\" representation).\n\n      5. Access to a file will normally be to some subset of it. (I.e.,\n         the unit for transmission will usually be part of a file rather\n         than the whole file, and access will not necessarily be\n         sequential).\n\n   Consequences\n   ------------\n\n      1. A method of data description significantly more powerful than\n         now commonly available (as with COBOL or PL/I) is required.\n         The descriptions must be stored with the files.  Data item\n         representations and storage organizations must be describable.\n\n      2. The data computer must offer a \"data reconfiguration service\",\n         based on use of the data descriptions.\n\n      3. A representation and organization-independent level of\n         discourse must be made available for controlling access.\n\n   Data Description\n   -----------------\n\n   As it happens, the descriptive facilities in ELl (References 1 and 2)\n   are almost adequate as they stand.  ELl is an extensible language --\n   the compiler and interpreter for ELl are principal components of a\n   system implemented on the PDP-lO at Harvard -- which allows the\n   definition of arbitrary data structures in terms of a few primitive\n   data types (BOOL, CHAR, INT, REAL, SYMBOL, MODE, FORM, and ROUTINE).\n   These data types are of the sort I called \"generic\" in Reference 3.\n   To the EL1 implementation on the PDP-10, say, we would have to add\n   methods to describe a specific representation of INT, etc. and\n   primitive routines to convert between specific representations.\n\n   In the ECL system (in which EL1 is embedded), there is no rigid\n   distinction between compile time and run time.  In particular, if the\n   arguments and free variables of a routine are evaluable at compile\n   time, then the routine is evaluated and the value replaces the call.\n   More generally, arbitrarily large amounts of a routine being compiled\n   may collapse into values.  As far as the data computer is concerned,\n   this offers the possibility of producing tailor-made data\n   reconfiguration programs, taking maximum advantage of the data\n   descriptions at compile time rather than using a strictly\n   interpretative mode of operation.\n\n\n\n\nHealy                                                           [Page 2]\n\f\nRFC 195                      Data Computers                    July 1971\n\n\n   Access Language\n   ---------------\n\n   Here, I am on less firm ground.  I will suggest, however, that some\n   of the ideas of Sattley, et al (Reference 4) deserve consideration.\n   I will quote from the Reference:\n\n   \"... Our proposal is a language for describing the transferable\n   features of files, in which conventional programming languages (e.g.,\n   FORTRAN, ALGOL, etc.,) can be embedded, and from which the\n   information necessary to optimize the use of secondary storage can be\n   easily abstracted.  This language defines our abstract model of\n   secondary storage in the same way that FORTRAN defined an abstract\n   machine.  This language should have (at least) the following\n   features:\n\n      1. File declarations name the file and the elements in the file,\n         and specify the range of forms that the elements can take.\n         Each file has precisely one named element.  Each file includes\n         the (maximum) size (in number of elements) of the file.\n\n      2. Subsets of files can be created by means of grouping\n         declarations.  Such subsets can be nested.\n\n      3. Subsets of files can be named by means of naming declarations.\n         Such declarations can also name individual elements of the\n         file.  Some form of implicit naming, allowing language\n         constructs such as GET ANOTHER TRIPLE, is included.\n\n      4. Members of a set (i.e., elements in a subset or file, subsets\n         in a containing subset or file) can be ordered by order\n         declarations.  Some form of arbitrary but fixed ordering,\n         allowing language constructs such as GET NEXT TRIPLE, is\n         included.\n\n      5. The portions of a file transacted with at a point of access is\n         declared.  The size of this portion can be expressed in\n         absolute or relative terms.\n\n      6. At each point of access to secondary storage, an environment is\n         described (or referenced) which contains those declarations of\n         types (l)-(5) necessary to define the transaction with\n         secondary.\n\n\n\n\n\n\n\n\nHealy                                                           [Page 3]\n\f\nRFC 195                      Data Computers                    July 1971\n\n\n   A language with the above features makes no mention of hardware\n   devices, but it provides the programmer with the means of defining\n   the algorithm-dependent features of his files so that those files\n   might be transferred efficiently from machine to machine\".\n\n   In the Sattley, et al study, the notion was that a compiler would\n   take the source program and actually compile the hardware-dependent\n   file accessing code.  In our environment, we are concerned with\n   control commands to the data computer (e.g., GET NEXT WALDO) and\n   supplying the data computer with enough information to define a\n   WALDO.  The basic functions would seem to be the same, in either\n   case, albeit implemented rather differently.\n\nReferences\n\n   1.  Wegbreit, B. The Treatment of Data Types in EL1.  Technical\n       Report, Division of Engineering and Applied Physics, Harvard\n       University, Cambridge, Massachusetts, May 1971.\n\n   2.  Wegbreit, B. The ECL Programming System.  Technical Report,\n       Division of Engineering and Applied Physics, Harvard University,\n       Cambridge, Massachusetts, April 1971.\n\n   3.  Mealy, G. H. Another Look at Data.  AFIPS Conference Proceedings,\n       vol. 31, 1967 Fall Joint Computer Conference\n\n   4.  Sattley, K., Millstein, R. and Warshall, S. On Program\n       Transferability.  Report CA-7011-2411, Massachusetts Computer\n       Associates, Wakefield, Massachusetts, Movember 1970.\n\n\n       [ This RFC was put into machine readable form for entry ]\n       [ into the online RFC archives by Larry Masinter 10/99 ]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHealy                                                           [Page 4]\n\f\n"
}