{
  "series": "Request for Comments",
  "number": "42",
  "howpublished": "RFC 42",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0042",
  "url": "https://www.rfc-editor.org/info/rfc42",
  "title": "Message Data Types",
  "pagetotal": "3",
  "year": "1970",
  "month": "mar",
  "body": "\n\n\n\n\n\nNetwork Working Group                                        E.I. Ancona\nRequest for Comments: 42                       M.I.T. Lincoln Laboratory\n                                                           31 March 1970\n\n\n                            Message Data Types\n\n\n   Proposal:\n\n   We propose that the first eight bits of a normal message be reserved\n   for a message data type.  Adoption of this convention does not in any\n   way signify agreement as to the actual data types to be used.  It\n   merely establishes the convention that the first eight bits of every\n   normal message are not available for user data.\n\n   Discussion:\n\n                     Socket    Port\n                     |    |      |    ____________\n                     |    V      V   /            \\\n                     V              /              \\\n                         |=|    /==|                |\n             -------(+)-\u003e|Y|--\u003e\u003c   |                |\n                         |=|    \\==|                |\n                                   |    PROCESS     |\n                                   |                |\n                         |=|    /==|                |\n             -------(-)-\u003e|X|\u003c--\u003c   |                |\n                         |=|    \\==|                |\n                                    \\              /\n                                     \\____________/\n\n   It is important that conventions regarding the contents of messages\n   be set up early so that there will not be a large proliferation of\n   such conventions between every pair of programs running on the\n   network.\n\n   As network usage grows, network languages may develop for specifying\n   both the syntax and semantics of messages.  However, even before such\n   conventions are developed, a simple way of describing such a\n   specification is by means of a message type which both sender and\n   receiver know how to interpret.\n\n   It is important that currently running programs still run with this\n   convention; thus, we propose that two system programs be written\n   which initially put in and test and remove the type information from\n   the message.  Let us call these two programs X and Y, for lack of\n\n\n\nAncona                                                          [Page 1]\n\f\nRFC 42                     Message Data Types                 March 1970\n\n\n   better names.  In general, X and Y will perform transformations on\n   the data, e.g., change character sets or number formats.  As network\n   usage grows, X and Y might become table driven with the table\n   specified by the user.\n\n   Standard Types and Local Types:\n\n   We propose to distinguish between two kinds of message data types:\n   standard and local.\n\n   Since our two transformation programs cannot be expected to perform a\n   transformation between every possible data representation and the\n   data representation of the machine they are running on, and also\n   since the addition of a data representation should not necessarily\n   involve a change to X or Y, we propose that only a fixed number of\n   message types have meaning throughout the network.  These are\n   standard types.\n\n   There are two classes of local types: MYLOCAL and YOURLOCAL. A\n   message type MYLOCAL n implies: this is type n of the set of types of\n   the sending host.  YOURLOCAL n implies: this is type n of the set of\n   types of the receiving host.\n\n   Conventions:\n\n   A possible implementation of standard and local types is to define\n   standard type 0 to be YOURLOCAL and standard type 1 to be MYLOCAL. In\n   these cases, the second byte would be the local type number.\n\n   Local type 0 would mean user-specified, i.e., the message contents\n   are unchanged and unchecked.  Installations would define their own\n   local type numbers and these would normally be available from the\n   Network Information Center.\n\n   Thus initially, all messages sent to currently running programs will\n   be type 0, n and all messages received from currently running\n   programs will be type 1, n where n is the local type number of the\n   character set of the installation.\n\n   Examples of Possible Standard Types:\n\n        0.     YOURLOCAL\n        1.     MYLOCAL\n        2.     U.S. Ascii\n        3.     EBCDIC\n        4.     Mod 33 TTY Ascii\n\n\n\n\n\nAncona                                                          [Page 2]\n\f\nRFC 42                     Message Data Types                 March 1970\n\n\n        5.     Load table driven translator table #n.  If, in the\n               future, the X and Y transformation boxes are table\n               driven, this gives the table.  The table number n is\n               stored in the second byte of the message.\n        6.     Use table driven translator table #n.\n        7.     Network standard graphics message.\n\n   Examples of Local Types:\n\n        1.     Local Character sets, e.g., Lincoln writer, DEC Ascii,\n               etc.\n        2.     Graphics local messages, e.g., TX-2 Apex display\n               executive calls, GSAM.\n\n\n\n         [ This RFC was put into machine readable form for entry ]\n         [ into the online RFC archives by Robbie Bennet 11/98   ]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAncona                                                          [Page 3]\n\f\n"
}