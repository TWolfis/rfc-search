{
  "series": "Request for Comments",
  "number": "49",
  "howpublished": "RFC 49",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0049",
  "url": "https://www.rfc-editor.org/info/rfc49",
  "title": "Conversations with S. Crocker (UCLA)",
  "pagetotal": "5",
  "year": "1970",
  "month": "apr",
  "day": "1",
  "body": "\n\n\n\n\n\nNWG/RFC 49      Conversations with Steve Crocker (UCLA)\n\n                          Edwin W. Meyer, Jr.\n                            MIT Project MAC\n                             April 25, 1970\n\n\n   (Both my personal opinions and those that I believe represent a\n   consensus of the Network Working Group at Project MAC are presented\n   here.  The pronouns \"I\" and \"we\" are used to distinguish between\n   these.)\n\n\nOn April 21 and 23 Thomas P. Skinner and I had telephone conversations\nwith Steve Crocker at UCLA relating to the network protocol,\nspecifically regarding our proposal in NWG/RFC 46.  The following items\nwere discussed.  (I hope that Steve will pardon me if I happen to\nmisparaphrase him.)\n\n1) Steve stated that he felt that a need for dynamic reconnection would\nlater be recognized by the network participants.  However, because of a\nlack of consensus, it will not be included in the initial\nimplementation.  (We at Project MAC favor this approach of not including\nit initially.)\n\n\n2) Steve supported the implementation of the INT network command\ndescribed in NWG/RFC 46.\n\nThis command allows a process that has agreed to accept interrupts over\na socket connection to be reliably interrupted by the process at the\nother end.  The interrupt causes a process to abey its current execution\nand execute a procedure that it has specified as the INT handler.  (The\nNCP does not specify the INT handler.  That is the function of higher\nlevel protocols.)\n\nThe INT command is designed specifically for use by a third level User\nControl and Communication (UCC) protocol to implement a \"quit\" signal.\nUnder such a protocol, both the requestor and the created process agree\nthat an INT related to a specific socket connection and transmitted over\nthe NCP control link to the created process is the standard \"quit\"\nsignal.  The created process provides an INT handler that implements\nthis \"quit\" function.  (This does not preclude a different\ninterpretation of INT by other third level protocols.)\n\nAlthough many systems implement the \"quit\" as a control character in the\nTeletype input stream, systems such as CTSS, Multics, and others\nimplement it as a 200 ms spacing on the line.  We at MAC think that the\n\n\n\n                                                                [Page 1]\n\f\nNWG/RFC 49      Conversations with Steve Crocker (UCLA)\n\n\nfirst method is an undesirable implementation within the network (while\nthe second is impossible).  I put forth several reasons why (and I think\nSteve agreed).\n\n(a) The link over which the quit character is to be transmitted may be\nblocked.\n\n(b) While the interrupt is most effectively implemented within the NCP,\nit is undesirable for the NCP to place any particular structure on the\ndata being transmitted.  (See discussion below.)  This would be required\nif the NCP were to scan a data stream for a control character.\n\n(c) Scanning the input stream greatly reduces NCP efficiency in a\nsubsystem where speed is critical to effective operation.\n\nSteve pointed out that the implementation of INT as a \"quit\" should not\nnecessarily preclude a HOST's interpretation of a control character in\nthe input stream from also acting as a \"quit\".\n\n\n3) Steve is opposed both to including the instance tag in the socket\nidentifier and reserving a null field in the identifier for future\ndefinition.  He cited several reasons:\n\n(a) Multiple processes of a single user should be indistinguishable to a\nforeign process.  (I agree with this in certain cases when processes are\nco-ordinated in joint action.  But what about the case where two\nprocesses of the same user both want to independently use the network?)\n\n(b) A process wishing to connect to one of a foreign user's processes\ndoes not know the instance tag of the particular process that he wants,\nand he can't easily find out.\n\n(c) If an instance tag should later prove desirable it could be added\nwith some difficulty.  (I claim that something as fundamental as the\nlength of a socket identifier will prove very resistant to change.)\n\nTom stated that perhaps the low order three bits of the user code could\nbe reserved for later interpretation as an instance tag.  He doesn't\nthink that a separate field is of great importance.\n\nSteve's arguments seem to have merit.  Perhaps Tom's suggestion is the\nway to go.  I am currently undecided on this matter.\n\n\n4) We all (Steve and MAC) seem to agree that at the NCP level there\nshould be no special structure imposed on the data transmitted.  To an\nNCP all data to be transmitted are bit strings of arbitrary length.  One\n\n\n\n                                                                [Page 2]\n\f\nNWG/RFC 49      Conversations with Steve Crocker (UCLA)\n\n\nhappy result is that the difficult question of character sets does not\nhave to be resolved at this protocol level.  To include a character set\nspecification at the NCP level would delay agreement on the protocol and\nmake this character set more resistant to change.  (If there is to be a\nstandard character set, we prefer ASCII.  After all, it is the prefered\nstandard of our sponsoring organization.)\n\nWe also agree with Steve that there should be no optional echoing of\nmessages at the NCP protocol level.  (This is also the position of the\nSDC people in RFC 44.)\n\n\n5) Shoshani, Long, and Landsberg also state (RFC 33) that they prefer to\nalign messages to end on a word boundary as opposed to double padding.\nSteve agrees with us in not liking double padding.\n\n\n6) In our proposal (RFC 46) we suggest that RFCs be queued only for open\nsockets, that RFCs to inactive or connected sockets are to be\nautomatically rejected via the CLS command.  Steve proposes that RFCs to\nthese sockets be briefly queued.  If the socket remains in an\nunacceptable state for a specific interval after the RFC comes in, it is\nrejected.  This scheme allows certain types of network command\ninteraction involving critical races to be implementable.  Such a scheme\nof limited queueing does not seem unreasonable to me.\n\n\n7) Steve, Tom, and I discussed strategies for a User Control and\nCommunication (UCC) Protocol.  Steve said that he disliked our UCC\nstrategy (RFC 46) because it requires maintaining two full-duplex\nconnections to the requestor process and switching between them.\n\nSteve put forth an alternate proposal: a process wishing to create a\nuser process at a foreign HOST issues RFCs to sockets 0 and 1 belonging\nto the user whose process he wishes to create.  If these sockets are\ninactive, the NCP automatically directs these requests to the foreign\nHOST's logger process.  The logger accepts connection and performs the\nlogin ritual.  If successful, the logger creates a user process and lets\ngo of the usurped sockets so that the created process may use them to\ncommunicate with the requestor process.  (I note that this does not use\nreconnection at a network level, since the logger uses sockets belonging\nto the ultimate user.  However, it does involve internal reconnection.)\n\nTom and I objected to this because it introduces UCC protocol into the\nNCP level.  (The NCP must direct all RFCs to inactive sockets 0 and 1 to\na logger process.)  I made a quick suggestion that perhaps our two\nproposals could be combined such that the requestor issues a\n\"signalling\" RFC to a \"signal\" socket of the UCC process.  The UCC\n\n\n\n                                                                [Page 3]\n\f\nNWG/RFC 49      Conversations with Steve Crocker (UCLA)\n\n\nrejects the RFC but remembers who is calling.  It then tries to connect\ntwo sockets of the process to be created to the requestor's sockets, and\nconducts the login ritual through these.  Steve liked this and suggested\nthat I write it up.\n\nFollowing the conversation, I thought of several disadvantages to this\nUCC strategy:\n\n(a) If the control sockets at a created process are limited to 0 and 1,\nthere is the possibility that a rightful user may not be able to\ncommunicate with a foreign UCC because the UCC already is using those\nsockets to communicate with an imposter.  The logger will discover this\nand turn off the imposter, but this is an aggravating security breach.\nA malicious process could issue simultaneous multiple requests to tie up\nthe sockets and prevent access to a rightful user.  A better solution is\nto allow any socket pair of the potential user process to act as the\ncontrol path.  This permits the UCC to conduct simultaneous\ninterrogations of competing requestors.\n\n(b) A disadvantage of both Crocker's and the combined UCC is that the\nuser to be logged in is specified by supplying a socket belonging to a\nparticular user.  The logger must now make the additional check that the\nuser it is logging in actually belongs to the socket pair it is talking\nover.  This seems the reverse of the prefered process: to identify a\nuser and then determine the user code for his socket identifiers.\n\n(c) The user may not know the socket user code of the user he wishes to\nlog in at the foreign HOST.  (After all, there is no basic reason why\nthe requestor and created processes should have the same user code so\nlong as the requestor satisfies the foreign logger.)\n\n(d) In the combined strategy, there is no way for the requestor to\nspecify which socket user code it wants.  The only assumption that the\nUCC can make is that the requestor process wishes to log in a process\nhaving the same socket user code as itself.  (This may not seem very\nimportant, but I envision a scheme in which a local process exists to\nallow consoles attached to the local HOST to login at a foreign HOST\nwithout being logged in locally.)\n\n(e) The idea of allowing a process to masquerade within the network as\nanother process (even with the best of intentions) by using its socket\nuser code introduces a potentially dangerous security breach.  I think\nthat it should be a basic protocol law that NO PROCESS WHATSOEVER may\nrequest or accept connections or transmit or receive data over a socket\nhaving a user code not its own.  This does not apply to an NCP process\nwhich has responsibility for such transmission, nor does it prevent a\npriviliged process from closing or rejecting connections between a\nforeign process and another local process.\n\n\n\n                                                                [Page 4]\n\f\nNWG/RFC 49      Conversations with Steve Crocker (UCLA)\n\n\nI still think that the UCC proposal we advanced in RFC 46 is a good\nworkable scheme.  It does not require socket reconnection (either\nexpressly throughout the network or implicitly within an NCP), nor do\nany of the objections raised above apply.  The only particular\ndisadvantage I see is that it requires the requestor process to maintain\nand switch between two full-duplex connections.  I don't see this as a\nserious hindrance.  I would like the comments of the network\nparticipants on this point in particular.\n\nFortunately the UCC is a third level protocol.  The second level NCP can\nbe specified before we reach final agreement on a UCC, provided that the\nNCP allows implementation of a workable UCC.\n\nSteve expressed the thought that there need not be an initial standard\nUCC, that there might be several UCCs.  We at MAC disagree.  If we are\nall to talk to each other, and not between limited subsets of HOSTs\nwithin the network, there must be an initial standard UCC which\nEVERYBODY implements.  (Steve is of course correct that there can be\nother experimental UCCs also implemented.)\n\nIt is theoretically possible for each HOST to provide multiple sets of\nsoftware to allow a requestor process to communicate with the loggers at\nHOSTs implementing different UCCs.  I don't think that it will work this\nway in practice.  Each HOST will implement the UCC protocol that is most\nagreeable to it, and will provide one set of software so that a\nrequestor process can communicate only with those HOSTs which implement\nsimilar UCCs.\n\nI don't think that there is much enthusiasm at Project MAC for\nimplementing a non-standard UCC just so we can talk to ourselves.  We\nwant to implement a single UCC supported at all installations, so that\nwe can log in to all HOSTs using this protocol, and that users at all\nforeign HOSTs can log in to us.\n\n       [ This RFC was put into machine readable form for entry ]\n       [ into the online RFC archives by Altair Petrofsky 7/97 ]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                                [Page 5]\n\f\n"
}