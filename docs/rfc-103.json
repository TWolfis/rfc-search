{
  "series": "Request for Comments",
  "number": "103",
  "howpublished": "RFC 103",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0103",
  "url": "https://www.rfc-editor.org/info/rfc103",
  "title": "Implementation of Interrupt Keys",
  "pagetotal": "4",
  "year": "1971",
  "month": "feb",
  "body": "\n\n\n\n\n\n                                                NWG RFC 103\n                                                NIC 5764\n\n\nIMPLEMENTATION OF INTERRUPT KEYS\n\n\nR B Kalin\nMIT Lincoln Laboratory\n24 Feb 1971\n\n\n    The current protocol specifications contain a serious logical\nerror in the implementation of the program interrupt function.  This\npaper discusses the problem and offers a solution that is simple to\nimplement.\n\nTHE PROBLEM\n\n    As found on most time-sharing systems the program interrupt key,\nelsewhere known as the break key, or help request button, has two\nfunctions.  It suspends temporarily the user process being run, and it\nswitches the keyboard input stream to a dormant supervisory process.\nUnaccepted input typed prior to the interrupt request remains buffered\nfor the suspended user process.  Subsequent typing is sent to a\nsupervisory routine.\n\n    The current NCP protocol implements only half this function.  It\npprovides, through use of INS and INR control messages, for the\nsuspension of a remote process, but it offers no mechanism for\nnotifying the remote host at what time the data stream should be\nswitched.  INR and INS messages are sent via the control link and\nbecause messages on this link travel concurrently with those on the\nuser's keyboard input link, the receiving host can not rely on\nrelative arrival times as a source of synchronizing information.\nWithout such information the remote NCP can not know which input\ncharacters are meant for the user process and which are meant for the\nsupervisory routine.\n\n    A solution found on some systems to this problem is that of\nmapping the interrupt signal into some code from the character set --\ntypically an ASCII control-C.  Unfortunately, this is not general\nenough to be used within the ARPA network.  Some systems, eg. MULTICS,\nmake use of all available ASCII codes for other purposes, none are\navailable for such an assignment.  Even if such an assignment could be\nmade, there is the problem of getting the interrupt character to be\nrecognized by the remote host.  Buffers on that user link may be full\nand the sending host may be unable to transmit the message containing\n\n\n\nCrocker                                                         [Page 1]\n\f\nRFC 103            Implementation of Interrupt Keys             February 1971\n\n\nthe interrupt code.  If the remote user process loops without\naccepting data, there is the possibility that its input buffers will\nnever become free and that the message will never get through.\n\n    A partial answer is that of providing at the serving end a\nteletype scanner process that is always hungry for input.  Because all\ninput messages are immediately consumed, buffers remain available and\ninterrupt codes can get through.  Unfortunately, this implies that at\ntimes characters must be thrown away.  After being scanned there may\nbe no buffer space available for them.  While not critical during\nconsole interactions -- users can type only when the program demands\ninput -- this defect prevents the scanner from being driven from a\ntext file.\n\n\nA SOLUTION\n\n    The following defines a solution to this problem for the case of\nASCII data streams.\n\n1) Character messages should use eight bit fields for each character\ncode.\n\n2) For all of the defined ASCII character codes the left most bit in\nthe eight bit field shall be zero.\n\n3) An interrupt sync character ( arbitrarilly given the code octal 200\n) should be placed in the data stream at the correct point in the\ntyping sequence.\n\n4) All codes from octal 201 to octal 377 are officially to be ignored\nby a receiving host.  Their use is reserved for additional control\ninformation, should it become necessary.  Attempts to use them as\nadditional character codes will meet with resistance from PDP-10\nsystems that internally pack characters into seven bit fields.  Note\nthat this objection can not be made against the interrupt sync\ncharacter because it is filtered out by the system and never appears\nin a user's input buffer.\n\n5) Because of the possibility that there may be an insufficient\nallocation to allow the user message containing the interrupt sync\ncharacter to be sent, the INR/INS mechanism currently defined must be\nkept.  An INS control message should be sent at the time an interrupt\nsync character is entered into a text stream. Upon its reception by\nthe foreign host, the attached process should be immediately suspended\nand the associated input stream should be scanned.  If possible, all\ninput up to the interrupt sync character should be buffered for the\nsuspended process.  Once the sync character is found, the stream\n\n\n\nCrocker                                                         [Page 2]\n\f\nRFC 103            Implementation of Interrupt Keys             February 1971\n\n\nshould be switched to the newly activated supervisory process.  If it\nis not possible to buffer all of the user process's input, it can be\nthrown away, and a error message returned to the user by the\nsupervisory process.  In either event it must be guaranteed that\noutstanding input will be consumed and message buffers will be freed\nso that pending character messages can be sent.\n\n6) In the event that an interrupt sync character is received before\nthe matching INS, the user process should be suspended and the NCP\nshould wait for the INS before proceeding.\n\n7) The function of the NCP is the above discussion can, of course, be\ndelegated a separate modulo, eg. a TELNET process.  If this is done,\nthe NCP can be transparent to message content.\n\n\nCOMMENTARY\n\n    The proposed change to the second level protocol described herein\nis not meant as a general solution, but rather as a specific patch to\nthe current NCP design with the intent of correcting a critical error.\nIts more obvious deficiencies are...\n\n1) It only works with seven bit code character streams.  No extensions\nare allowed for EBCDIC, ASCII-8, or other large character sets.  No\nprovision is made for interrupting a process to which there is no\ncharacter stream, although the author knows of no case in which the\nconcept means more than closing the connection.\n\n2) It requires the system to scan all data coming over an\ninterruptable connection.  Presumably this means that at the time the\nconnection is created, the receiving host must be told that this scan\nis to be done.  Various techniques, both implicit and explicit, could\nbe used.\n\n3) The technique is not immune to loss character boundaries within a\nmessage nor can it tolerate INS control messages that do not have\nmatching sync characters, or vis versa.\n\n4) It may not possible to get either the INS or the text message\ncontaining the interrupt sync character to a remote host.  Possible\nreasons include user console failure, local host failure, network\nfailure, blocked control link, insufficient allocation etc.  Under\nsuch circumstances the remote process may loop indefinitely.\n\n\n    The only comprehensive solution known to the interrupt\nsynchronization problem, those that avoid the above difficulties,\n\n\n\nCrocker                                                         [Page 3]\n\f\nRFC 103            Implementation of Interrupt Keys             February 1971\n\n\nrequire more than minor changes to the current NCP protocol.  Unless\nsimpler answers are suggested, their implementation must be postponed\nuntil the next major design revision.\n\n       [ This RFC was put into machine readable form for entry ]\n         [ into the online RFC archives by Gert Doering 4/97 ]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCrocker                                                         [Page 4]\n\f\n"
}