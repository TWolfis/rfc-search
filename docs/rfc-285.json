{
  "series": "Request for Comments",
  "number": "285",
  "howpublished": "RFC 285",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0285",
  "url": "https://www.rfc-editor.org/info/rfc285",
  "title": "Network graphics",
  "pagetotal": "8",
  "year": "1971",
  "month": "dec",
  "body": "\n\n\n\n\n\nNetwork Working Group                                            D. Huff\nRequest for Comments: 285                                    CWRU (Case)\nNIC: 8271                                              December 15, 1971\nUpdates:        None\nObsoletes:      None\n\n\n                            Network Graphics\n\n\n        Not much has been written about graphics on the ARPANET when the\nvolume of the NIC collection is considered. Presently it contains some\n8000 entries of which only about 20 are on the subject of graphics. The\nreason is probably similar to that given by L. G. Roberts in A FORWARD\nLOOK (NIC 7542) as the reason that data base sharing or software sharing\nwill not be important topics for several more years: the NET hasn't been\nup long enough for interested people to have enough of the facts to know\nif it is feasible and to think creatively.\n\n        This paper is therefore aimed at bringing together the present\nstate of graphics on the NET for the newcomer and attempting to add a\nlittle more distance to the ground covered so far. I will start with an\noverview, then proceed to briefly describe past work, and finally add\nsome of my own thoughts.\n\n        Since the NET represents a wealth of data processors, any or all\nof which may be used at one time, we are not restricted to the\nconfigurations most generally found in private installations where there\nis a main processor and a somewhat less capable machine or perhaps none\nat all doing the honors as display processor. Indeed when using the NET\nit might occur that one has a more powerful machine as the display\nprocessor than the machine which is running the main job. Graphics on\nthe NET need not be anything like what we know it as now.\n\n        There is of course a greater more diversified mix of graphics\nequipment that must be considered when designing a standard graphics\nlanguage and its processor. If we wish to drive an aribitrary display\nfrom a program such an output language must be quite general, but the\nprocessor which constructs the actual display list for the target\ndisplay need not and in fact will not be general, rather its only job\nwill be to translate a well defined general language to meet the\nrequirements of one specific graphics terminal.\n\n        Attention handling, a lately discussed and much worried about\ntopic, presents an entirely different problem. This time the NET may\ncause more harm than good for the simple reason that now there may be\nseveral, instead of one (in some cases none at all), mappings defined to\nget from the initial display list that the main job process is creating\n\n\n\n                                   1\n\n\n\n\n\nRFC 285  NIC 8271\n\n\nto the final display list which interactive devices such as the light\npen actually refer to. This is a problem which has to be faced and has\nbeen solved at many different sites in as many different ways. It is\nlikely to give as much trouble as the final concept.\n\n        Local processing is in many cases a very simple thing to\naccomplish when the display terminal is \"intelligent\" or even has its\nown medium or large scale processor which has little or nothing else to\ndo aside from refreshing the display. Such processing can be simple\nadditions or deletions to the picture which certainly do not require the\nmain job process to accomplish. The local processor need only notify the\nmain process of what changes have been made to the display list so that\nthe main copy may be updated. The allocation of abilities poses the last\nproblem. The lower limit is reached when the local processor is unable\nto do anything beyond keeping the picture displayed, and the upper limit\napplies to the case when the local processor is more powerful than the\nmain processor and handles all attentions itself. Now such questions as,\njust which copy of the display list is the master copy, who is\nresponsible for seeing that all copies of the list contain the same\ninformation, and what kind of mappings between display lists are\nrequired, become the important ones we all seek to answer.\n\n        Proposals for Network Standard Graphics started with the idea of\na simple interpretable language containing only commands to erase the\nscreen, display a string of text, move the beam or draw a line or point\nwithin a virtual rectangle which is the generalized display screen,\nexecute a previously defined subroutine, and replace the contents of a\nsubroutine with what follows in the command stream. Movements within the\nscreen area were defined in terms of fractions of the screen dimensions\ninstead of absolute lengths. This proposal was responded to with the\nsuggestion that a graphics standard could not be so restrictive and find\nwide acceptance. The proposal was not expressive enough to handle\nsophisticated picture manipulations. It was recognized that a standard\nmust be able to make use of all graphics hardware, present and within\nthe forseeable future. The data structure should represent both logical\nand pictorial structure, allow for the definition and manipulation of\nsubpictures, and division of the display screen into logical units. The\nproposed standard has now become a general high-level language rather\nthan a low-level language. It was pointed out that all sites need not be\nable to handle the interpretation of this graphic language, but because\nof the existence of the rest of the NET, one of the other machines could\nrun the interpreter, this is equivalent to a data reconfiguration\nservice. Such drawing modes as intensity, blinking, dashed, color, or\nstereo should also be expressable by means of a command to set the mode.\nThe canonical definition of a character string should be defined since\neveryone has their own way of displaying text and most of them are\n\n\n\n\n\n                                   2\n\n\n\n\n\nRFC 285  NIC 8271\n\n\ndifferent. It is suggested that the Multics convention be used as\ndescribed by Osanna, J., Sahzer, J., Remote Terminal Character Stream\nProcessing of Multics, Proceedings SJCC, 1970,  p. 671.\n\n        If in addition to simply displaying graphic information, if one\nwishes to to interact with the picture directly, the protocol must\ninclude a standard for feedback, attention handling as it is being\ncalled. Attentions may not always refer directly to the picture however,\nas in the case of keyboard input which can be handled as any other\nstandard message on the NET. Some graphics processors may also have the\ncapability of handling attentions locally and only need to report the\nend result to the main process. This is the problem of which data\nstructure is most up to date, which is considered the master copy, and\nhow can the processes be kept in sync? The observation is also made that\nas long as the graphics application program, the main process,\ncommunicates with a pair of graphic device handling routines in a\nnetwork standard language, the system configuration can be arbitrary and\nany terminal may be attached to any main process. The same is of course\ntrue of attention handling, a set of standards for the transmission of\nan attention generated by a particular device when developed will allow\nany graphics terminal to be understood by any other main process. A\nsummary of input devices has been given along with typical outputs and\nthe suggestion that each attention message identify the device causing\nthe attention, the data which is being supplied, and of course, the data\nitself.\n\n        The proposed graphic protocol has become much richer in display\ntypes. The following list was suggested as basic: points, lines,\nvectors, character strings, viewport and window, transformations of\ninstances, hardware-dependent byte streams, attention commands. The\npoint was also made that special considerations for grey-scale devices\nare needed and four alternate display modes are discussed (NIC 7128).\n\n        An example of hardware sharing is described in NIC 7130. It is a\nprotocol for the use of the LDS-1 processor at M.I.T. by anyone on the\nnet who has a program for the LDS-1. This Graphics Loader, as it is\ncalled, provides for the execution of programs that have been sent to\nthe PDP-10 at M.I.T. and the return of the data generated when the\nprogram is executed. The picture is not drawn on a display, but since\nthe LDS-1 processor can be instructed as to what to do with the\ncoordinates that it generates, the Graphics Loader sets up the processor\nto write back into core the computed display coordinates. These\ncoordinates may now be sent back to the originating site for display or\nas a debugging aid.\n\n\n\n\n\n\n\n                                   3\n\n\n\n\n\nRFC 285  NIC 8271\n\n\n        In NIC 7137 many of these previously discussed points are again\nbrought up, but this time under the supposition that a graphics terminal\nshould be just another terminal with minimal special privileges.\nSuggestions were also made pertaining to the design of a graphics\nprotocol with particular emphasis on display structure, attention\nhandling, coordinate systems, and the difference between storage tube\nand refreshed display requirements.\n\n        A specific solution for the handling of tablet input data has\nbeen presented, (NIC 7151), along with the expression that the graphics\nprotocol should be designed so that non-interactive graphics should not\nbe complicated with the requirements imposed by the interactive aspects\nof the protocol. It is pointed out that there are several types of\ntablet data that can be sent as input to a graphics process. Four types\nof data are described. They are single-shot, raw asynchronous, raw\nsynchronous, and preprocessed data. Preprocessed data can be smoothed or\nfiltered or thinned using various techniques to make the data more\nuniform and workable. Velocities can also be calculated for each point\nto aid in the interpretation of the data.\n\n        The description of NETCRT (NIC 7172) is the first encounter with\nlocal processing, or lack of it. NETCRT is a protocol between a central\nprocessor and a character display. The character display is completely\nslaved to the central processor and can do no local processing, however\nit can interrupt the processor thus signalling that the user is done\ntyping or wishes to begin typing. NETCRT tries to maintain good man-\nmachine interaction by controlling the state of the terminal.\n\n        I have refrained from commenting on the various proposals as I\nsummarized them because I don't think that it would have been in line\nwith what I am trying to do in this paper. I think that there is a need\nto consider an overall model of the graphic system we are trying to\ndesign. Previous proposals have dealt with some set of details without\nidentifying with a general model, producing good ideas for\nimplementation of details but not considering how the whole will fit\ntogether. Thus I would like to propose a model for our graphics system.\nIt will contain many protocols and leave many areas to be discussed\nfurther, but it will provide a starting point from which work can be\ndone along simple lines, and yet not exclude the later inclusion of more\nsophisticated abilities.\n\n        Figure 1 shows a block diagram of information flow. The PROCESS\nindicates a graphics application program which is running on a computer\nin the net. Its associated INPUT and OUTPUT routines can be thought of\nas being a set of subroutines loaded with the main PROCESS or as\nseparate and running elsewhere serving many users. At the other end of\nthe loop are a set of INPUT and OUTPUT drivers for the DISPLAY which is\nbeing used to display the graphics information. The information flowing\n\n\n\n                                   4\n\n\n\n\n\nRFC 285  NIC 8271\n\n\nfrom the PROCESS to the DISPLAY is drawing information for the building\nand manipulation of pictures. The information flowing from the DISPLAY\nto the PROCESS is attention information. The Graphic Data Base\nassociated with the main PROCESS is that which is constructed when the\npicture is being drawn by the PROCESS or when the picture is being drawn\nby local processing and attention messages tell the PROCESS what has\nbeen done to the picture. This data base need not contain more\ninformation that the PROCESS is willing to work with, and in fact need\nnot contain anything if no picture interaction is to be done. The\nGraphic Data Base associated with the DISPLAY drivers is built by\nthemselves so that the OUTPUT driver can handle attentions from the\nDISPLAY without requiring the main PROCESS to be able to do this and for\nthe INPUT driver to use when modifying the picture based on what is\nactually being displayed. The information flowing to and from the main\nPROCESS is the sort which is passed or received as parameters to\nprocedures. The INPUT and OUTPUT routines translate to and from\nrespectively a network standard graphics protocol which is sent out over\nthe net to the INPUT and OUTPUT display drivers whose responsibility it\nis to translate the standard message into the appropriate byte stream to\ndrive the DISPLAY or translate the attention from the DISPLAY into a\nnetwork standard message. The DISPLAY is assumed to handle its own\nrefreshing if it requires any, so that there will be as little apparent\ndifference between refreshed and non-refreshed displays as is possible.\n\n        This model provides for both simplicity of use for those doing\nsimple things and power which is needed for those doing sophisticated\ninteractive graphics. It can be used with a minimum of effort and\noverhead by setting runtime conditions to indicate that no interactive\ngraphics will be done and all associated processing should be skipped,\nwhile still enabling other PROCESSes to do high powered graphics without\ngoing to a completely different set of routines and rules.\n\n        Due to the existence of two separate data bases, which must be\nkept up-to-date with each other there are two modes of operating this\nmodel. For lack of better names let us call them PROGRAM graphics and\nLOCAL graphics. The former indicates that the picture being displayed is\nconstructed by the main PROCESS and all input from the user at the\ndisplay is solicited, thus the DISPLAY data base is only updated after\nand as a result of action by the main PROCESS. The latter indicates that\nthe user at the display is directing the construction of a picture by\nmeans of function buttons and drawing tools, the DISPLAY data base is\nupdated immediately and the main PROCESS is notified of the change so\nthat it may keep up, but it does not perform manipulations of the\npicture unless requested to do so by the DISPLAY OUTPUT driver; this can\nbe as a result of a request to perform some function that the DISPLAY\nINPUT/OUTPUT drivers can do by themselves or a request by the user to\nhave the main PROCESS perform a non-standard function on the picture.\n\n\n\n\n                                   5\n\n\n\n\n\nRFC 285  NIC 8271\n\n\n        The main purpose of this design is to allow greatest generality\nof graphic configurations rather than minimum response time. The design\nfor an optimum requires more exact specification of the hardware\nconfiguration and the proposed usage. Since neither of these variables\ncan be known, and in fact our attempt at generality keeps us from even\nguessing very closely at them, we must provide intelligent INPUT/OUTPUT\ndrivers that will know how to split the processing load between\nthemselves and the main PROCESS as a function of what kind of DISPLAY\nthey are driving, rather than attempting to design in an optimum\nbreakpoint.\n\n        The Graphics Protocol should specify the format of the messages\nwhich are transmitted between the INPUT and OUTPUT routines and drivers.\nThese messages can be divided as previously mentioned according to their\ndirection and content, i.e. drawing messages and attention messages.\nSince it is often desired to intermix graphics and text there should be\na distinguishing message header for all graphics messages. Then a byte\nto specify the type of information contained in the body of the message,\na count of the bytes in the body, and finally the body itself. Virtually\nall of the necessary message types have been indicated in the previous\nRFCs and I will not list them here, except to note that attentions now\ninclude requests for processing that the drivers could not do.\n\n        To summarize, I believe that a simple model is enough to enable\nthe design of both sophisticated interactive graphics and low effort\nnon-interactive graphics. The primary reason for this is that our major\ninterest is not minimum response, but rather maximum configuration\nmixes. There are opportunities to use software sharing and data\nreconfiguration services when building INPUT/OUTPUT routines and\ndrivers. Much detailed work remains to be done, but with a basic model\nin sight providing a framework to hang proposed ideas on for evaluation,\nwork should be able to proceed more smoothly.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                   6\n\n\n\n\n\nRFC 285  NIC 8271\n\n\n         +---------+                  +--------+\n         ! INPUT   !                  ! OUTPUT !\n      +--! routine !\u003c------||---------! driver !\u003c--+\n      !  +---------+                  +--------+   !\n      !                                   ^        !\n      V                                   !        !\n +---------+---------+      +---------+   !   +---------+\n !         ! Graphic !      ! Graphic !   !   !         !\n ! PROCESS ! Data    !      ! Data    !\u003c-\u003e!   ! DISPLAY !\n !         ! Base    !      ! Base    !   !   !         !\n +---------+---------+      +---------+   !   +---------+\n      !                                   !        ^\n      !                                   V        !\n      !  +---------+                  +--------+   !\n      !  ! OUTPUT  !                  ! INPUT  !   !\n      +-\u003e! routine !-------||--------\u003e! driver !---+\n         +---------+                  +--------+\n\n                         Figure 1\n\n\n\n\n\n\n\n       [ This RFC was put into machine readable form for entry ]\n          [ into the online RFC archives by Ian Redfern 4/99 ]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                   7\n\n\n"
}