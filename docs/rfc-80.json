{
  "series": "Request for Comments",
  "number": "80",
  "howpublished": "RFC 80",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0080",
  "url": "https://www.rfc-editor.org/info/rfc80",
  "title": "Protocols and Data Formats",
  "pagetotal": "9",
  "year": "1970",
  "month": "dec",
  "body": "\n\n\n\n\n\nNetwork Working Group                                         E. Harslem\nRequest for Comments: 80                                      J. Heafner\nNIC: 5608                                                           RAND\n                                                         1 December 1970\n\n\n                       PROTOCOLS AND DATA FORMATS\n\n   Because of recent discussions of protocols and data formats we issue\n   this note to highlight our current attitudes and investigations in\n   those regards.  We first discuss some specific sequences, and then\n   offer some thoughts on two general implementation approaches that\n   will handle these and other specifics.  We wish to place emphasis on\n   the _general solutions_ and not on the specifics.\n\nINITIAL CONNECTION PROTOCOLS\n\n   We wish to make two points concerning specific Initial Connection\n   Protocols (IPCs).  Firstly, the IPC described in NEW/RFC #66--its\n   generality and a restatement of that ICP.  Secondly, a proposal for a\n   variant ICP using basically the same logic as NWG/RFC #66.\n\nI. NWG/RFC #66\n\n   The only technical error in this IPC is that as diagrammed both the\n   Server and User send ALL messages before the connections are\n   established which is inconsistent with Network Document No. 1.  This\n   can easily be remedied as will be shown in the restatement below.\n\n   In terms of generality, any ICP that is adopted as a standard should\n   apply to more situations than a process calling a logger.  That is,\n   some Network service processes that hook directly to a user process,\n   independent of logger action, could perhaps use a standard ICP.\n   Thus, as is shown below, the process name field of the server socket\n   should be a parameter with a value of zero being a special case for\n   loggers.\n\n   Restatement of NWG/RFC #66 (using the same wording where appropriate)\n\n      1. To initiate contact, the using process attaches a receive\n         socket (US) and requests connection to process SERV socket #1\n         in the serving HOST.  (SERV = 0 for ICP to the logger.)  As a\n         result the using NCP sends:\n\n\n\n\n\n\n\n\nHarslem, et. al.                                                [Page 1]\n\f\nRFC 80                 Protocols and Data Formats        1 December 1970\n\n\n            1              4                 3          1     1\n         +-----+---------------------+---------------+-----+-----+\n         | RTS |          US         |      SERV     |  1  |  P  |\n         +-----+---------------------+---------------+-----+-----+\n\n         over link 1, where P is the receive link.\n\n      2. The serving process (SERV) may decide to refuse to the call, in\n         which case it closes the connection.  If it accepts the call,\n         the serving process completes the connection (via an INIT\n         system call, hence an STR).\n\n            1           3          1            4\n         +-----+----------------+-----+--------------------+\n         | STR |      SERV      |  1  |         US         |\n         +-----+----------------+-----+--------------------+\n\n      3. When the connection is completed, the user process allocates a\n         nominal amount of space to the connection, resulting in the NCP\n         sending:\n\n            1     1            4\n         +-----+-----+--------------------+\n         | ALL |  P  |       SPACE        |\n         +-----+-----+--------------------+\n\n         where SPACE is the amount.\n\n      4. The serving process then selects the socket pair it wishes to\n         assign this user.  It sends exactly an even 32 bit number over\n         the connection.  This even 32 bit number (SS) is the receive\n         socket in the serving HOST.  This socket and the next higher\n         numbered socket are reserved for the using process.\n\n      5. It then closes the connection.  The serving NCP sends (step 4):\n\n                    4\n         +---------------------+\n         |         SS          |\n         +---------------------+\n\n         on link P, and (step 5):\n\n\n\n\n\n\n\n\n\nHarslem, et. al.                                                [Page 2]\n\f\nRFC 80                 Protocols and Data Formats        1 December 1970\n\n\n            1            3         1             4\n         +-----+----------------+-----+--------------------+\n         | CLS |       SERV     |  1  |         US         |\n         +-----+----------------+-----+--------------------+\n\n         on the control link (which is echoed by the using NCP).\n\n      6. Now that both server and user are aware of the remote socket\n         pair for the duplex connection, \u003cSTR, RTS\u003es can be exchanged.\n\n         _Sever sends User_\n\n            1            4                     4\n         +-----+--------------------+--------------------+\n         | STR |      SS + 1        |          US        |\n         +-----+--------------------+--------------------+---+\n         | RTS |         SS         |        SS + 1      | Q |\n         +-----+--------------------+--------------------+---+\n\n         where Q is the Server's receive link.\n\n         _User sends Server_\n\n            1             4                    4\n         +-----+--------------------+--------------------+\n         | STR |       US + 1       |         SS         |\n         +-----+--------------------+--------------------+---+\n         | RTS |          US        |       SS + 1       | R |\n         +-----+--------------------+--------------------+---+\n\n         where R is the User's receive link.\n\n         ALLocates may then be sent and transmission begun.\n\nII.  A Variation of NWG/RFC #66\n\n   This variation reduces Network messages and eliminates duplication of\n   information transfer.\n\n   Steps 3 and 4 above are deleted.  The user process is not notified\n   directly which of the Server's sockets it will be assigned.  The user\n   process, however, will listen on sockets US and US + 1 for calls from\n   SERV after step 5 above.  It can reject any spurious calls.  In\n   accepting the calls from SERV, the connection is established.\n\n   The following sample sequence illustrates this ICP.  (The notation is\n   as above).\n\n\n\n\nHarslem, et. al.                                                [Page 3]\n\f\nRFC 80                 Protocols and Data Formats        1 December 1970\n\n\n   1. User --\u003e Server\n\n         1            4                    3         1     1\n      +-----+--------------------+----------------+-----+-----+\n      | RTS |         US         |       SERV     |  1  |  P  |\n      +-----+--------------------+----------------+-----+-----+\n\n   2. Server --\u003e User\n\n      If accepted:\n\n         1           3          1             4\n      +-----+----------------+-----+---------------------+\n      | STR |      SERV      |  1  |         US          |\n      +-----+----------------+-----+---------------------+\n      | CLS |      SERV      |  1  |         US          |\n      +-----+----------------+-----+---------------------+\n\n      If rejected:\n\n         1           3          1             4\n      +-----+----------------+-----+---------------------+\n      | CLS |      SERV      |  1  |         US          |\n      +-----+----------------+-----+---------------------+\n\n   3. If accepted, user listens on US and US + 1.\n\n   4. Server --\u003e User\n\n         1             4                     4\n      +-----+--------------------+---------------------+\n      | STR |       SS + 1       |          US         |\n      +-----+--------------------+---------------------+---+\n      | RTS |         SS         |        US + 1       | Q |\n      +-----+--------------------+---------------------+---+\n\n   5. User accepts the calls, hence:\n\n      User --\u003e Sender\n\n         1              4                     4\n      +-----+---------------------+--------------------+\n      | STR |        US + 1       |        SS + 1      |\n      +-----+---------------------+--------------------+---+\n      | RTS |        US + 1       |          SS        | R |\n      +-----+---------------------+--------------------+---+\n\n      and the connection is established.\n\n\n\nHarslem, et. al.                                                [Page 4]\n\f\nRFC 80                 Protocols and Data Formats        1 December 1970\n\n\n   This reduces the number of network messages by two and only passes\n   the information regarding the Server's sockets once via RTS and STR.\n\n   PRE-SPECIFIED DATA FORMATS\n\n   We would like to adopt those suggestions for data formats in NWG/RFC\n   #42 and #63.  We subscribe to multiple standards as solutions to\n   particular problem classes.\n\n   AN ADAPTABLE MECHANISM\n\n      We would like to adapt to Network use, problem programs that were\n      not planned with the Network in mind, and which, no doubt, will\n      not easily succumb to Network standards existing at the time of\n      their inclusion.  This incompatibility problem is just as\n      fundamental a part of the research underlying the Network as is\n      different Host hardware.  To require extensive front-ends on each\n      such program is not a reasonable goal.  We view the Network as an\n      amalgamation of a) Hosts that provide services; b) parasite Hosts\n      that interface terminals to the services, and c) a spectrum of\n      Hosts that behave as both users and providers of services.  To\n      require that each parasite Host handle different protocols and\n      data formats for all services that its users need is not a\n      reasonable goal.  The result is programs and terminals that wish\n      to communicate but do not speak the same language.\n\n      One approach to the protocol and data format problems is to\n      provide an adaptable mechanism that programs and terminals can use\n      to easily access Network resources.  ARPA is sponsoring the\n      Adaptive Communicator Project at Rand which is a research effort\n      to investigate a teachable front-end process to interface man to\n      program.  The variety of terminal devices being explored include\n      voice, tablets, sophisticated graphics terminals, etc.\n\n      The Adaptive Communicator looks very encouraging but it will not\n      be ready for some time.  The Network Project at Rand chose to take\n      the adaptable approach (_not_ adaptive, i.e., no heuristics, no\n      self-learning).  Our problem is to get Rand researchers onto the\n      Network easily, assuming that they have different simultaneous\n      applications calling for different program protocols and data\n      configurations.\n\n      Protocols and data formats will be described separately to\n      illustrate what we mean by adaptation.  Protocols are sequences of\n      \"system calls\" that correspond to (and result in NCP's issuance\n      of) NCP commands.  Data formats are the descriptions of regular\n      message contents and are not meaningful to an NCP.\n\n\n\n\nHarslem, et. al.                                                [Page 5]\n\f\nRFC 80                 Protocols and Data Formats        1 December 1970\n\n\n   The Form Machine (adapting to data formats)\n\n      To put the reader in context, the Form Machine is of the class of\n      finite state machines that recognize a form of _regular_\n      expressions_ which, in our case, describe data formats.  The\n      notation, however, is aimed at particular descriptions and\n      therefore can be more succinct, for our purposes, than the\n      language of regular expressions.\n\n      The Form Machine is an experimental software package that couples\n      a variety of programs and terminals whose data format requirements\n      are different.  We envision Form Machines located (to reduce\n      Network traffic) at various service providing Hosts.\n\n      To test the Form Machine idea, we are implementing two IBM OS-\n      callable subroutines; a compiler that compiles statements which\n      describe forms of data formats; and an executor that executes a\n      compiled form on a data stream.\n\n      To describe the Form Machine test, it is necessary to mention\n      another program at Rand--the Network Services Program (NSP), which\n      is a multi-access program that interfaces the Network Control\n      Program both to arbitrary programs and to Video Graphics Consoles.\n      (We view a terminal as just another program with a different\n      interface, i.e., # characters/line, # lines/page, unique hardware\n      features, the application to which it is put, etc.)  The Form\n      Machine subroutines are callable from NSP upon consoles or program\n      direction.\n\n      Operationally, a console user names and specifies the data forms\n      that he will use.  The forms are compiled and stored for later\n      use.  At some future time when the user wishes to establish\n      Network connections and transmit data, he dynamically associates\n      named forms with each side of a port--a symbolically named Network\n      full duplex connection.  Data streams incoming or outgoing are\n      executed according to the compiled form and the transformed data\n      stream is then passed along to the console/program or to the\n      Network, respectively.\n\n      The details of the syntax of our Form Machine notation are\n      unimportant to the collective Network community.  However, the\n      provisions of the notation are of interest.  It will eventually\n      encompass the description of high performance CRT displays, TTY,\n      and arbitrary file structures.  To test its viability, a subset of\n      such features is being implemented.\n\n\n\n\n\n\nHarslem, et. al.                                                [Page 6]\n\f\nRFC 80                 Protocols and Data Formats        1 December 1970\n\n\n      The current version is characterized by the following features:\n\n         1)    Character code translation (viz., decimal, octal,\n               hexidecimal, 8 bit ASCII, 7 bit ASCII, EBCDIC, and\n               binary).\n\n         2)    Multiple break strings (many terminals have multiple\n               termination signals).\n\n         3)    Insertion of literals (used primarily for display\n               information presentation).\n\n         4)    Skip or delete arbitrary strings (used to remove record\n               sequence numbers, etc., that are not to be displayed).\n\n         5)    Record sequence number generation.\n\n         6)    String-length computation and insertion.\n\n         7)    _Arbitrary_ data string length specifications, e.g., \"a\n               hex literal string followed by an _arbitrary_ number of\n               EBCDIC characters, followed by a break string, .....\".\n\n         8)    Concatenation of Network messages, i.e., the execution of\n               compiled forms on incomplete data strings.\n\n         9)    Data field transposition.\n\n         10)   Both explicit and indefinite multiplicative factors for\n               both single and multi-line messages.\n\n      Features that are not being implemented but will be added, if\n      successful, include:\n\n         1)    Graphics oriented descriptions.\n\n         2)    General number translations.\n\n         3)    Conditional statements.\n\n         4)    A pointer capability.\n\n   The Protocol Manager (adapting to NCP command sequences)\n\n      The NSP allows terminal users and programs to work at the NCP\n      protocol level; i.e., LISTEN, INIT, et al.  It also allows them to\n      transmit and massage information meaningful only to themselves.\n      This \"hands-on\" approach is desirable from the systems\n\n\n\nHarslem, et. al.                                                [Page 7]\n\f\nRFC 80                 Protocols and Data Formats        1 December 1970\n\n\n      programmer's, or exploratory point of view.  However, it is\n      desirable to eliminate the laborious \"handshaking\" for the\n      researcher who repeatedly uses a given remote program by allowing\n      him to define, store, retrieve, and execute \"canned\" protocol\n      sequences.\n\n      We are currently specifying a Protocol Manager as a module of NSP\n      that will allow the above operations on NCP command sequences.\n      Features of the module are:\n\n         1) The sequences may contain \"break points\" to permit the\n            console user to dynamically inject any contextually needed\n            information.\n\n         2) The parameters of a command may contain tokens whose values\n            are supplied by the remote party during the protocol dialog.\n            For example, in Note #66 the socket number provided by the\n            server is to be used by the user in subsequent RTS, STR\n            commands.\n\n   REQUEST\n\n      We would like to hear from anyone concerning the notion of\n      adaptation to data formats and protocol.  Is this a reasonable\n      approach?  What should it encompass?\n\n      JFH:EFH:hs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHarslem, et. al.                                                [Page 8]\n\f\nRFC 80                 Protocols and Data Formats        1 December 1970\n\n\n   Distribution\n\n      Albert Vezza, MIT\n      Alfred Cocanower, MERIT\n      Gerry Cole, SDC\n      Bill English, SRI\n      Bob Flegel, Utah\n      James Forgie, LL\n      Peggy Karp, MITRE\n      Nico Haberman, Carnegie-Mellon\n      John Heafner, RAND\n      Bob Kahn, BB\u0026N\n      Margie Lannon, Harvard\n      James Madden, Univ. of Ill.\n      Thomas O'Sullivan, Raytheon\n      Larry Roberts, ARPA\n      Robert Sproull, Stanford\n      Ron Stoughton, UCSB\n      Chuck Rose, Case University\n      Benita Kirstel, UCLA\n\n\n           [This RFC was put into machine readable form for entry]\n            [into the online RFC archives by Lorrie Shiota, 10/01]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHarslem, et. al.                                                [Page 9]\n\f\n"
}