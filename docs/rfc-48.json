{
  "series": "Request for Comments",
  "number": "48",
  "howpublished": "RFC 48",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0048",
  "url": "https://www.rfc-editor.org/info/rfc48",
  "title": "Possible protocol plateau",
  "pagetotal": "18",
  "year": "1970",
  "month": "apr",
  "day": "1",
  "body": "\n\n\n\n\n\nNetwork Working Group                                          J. Postel\nRequest for Comments: 48                                      S. Crocker\n                                                                    UCLA\n                                                          April 21, 1970\n\n\n                      A Possible Protocol Plateau\n\nI. Introduction\n\n   We have been engaged in two activities since the network meeting of\n   March 17, 1970 and, as promised, are reporting our results.\n\n   First, we have considered the various modifications suggested from\n   all quarters and have formed preferences about each of these.  In\n   Section II we give our preferences on each issue, together with our\n   reasoning.\n\n   Second, we have tried to formalize the protocol and algorithms for\n   the NCP, we attempted to do this with very little specification of a\n   particular implementation.  Our attempts to date have been seriously\n   incomplete but have led to a better understanding.  We include here,\n   only a brief sketch of the structure of the NCP.  Section III gives\n   our assumptions about the environment of the NCP and in Section IV\n   the components of the NCP are described.\n\nII. Issues and Preferences\n\n   In this section we try to present each of the several questions which\n   have been raised in recent NWG/RFC's and in private conversations,\n   and for each issue, we suggest an answer or policy.  In many cases,\n   good ideas are rejected because in our estimation they should be\n   incorporated at a different level.\n\n      A. Double Padding\n\n         As BBN report #1822 explains, the Imp side of the Host-to-Imp\n         interface concatenates a 1 followed by zero or more 0's to fill\n         out a message to an Imp word boundary and yet preserve the\n         message length.  Furthermore, the Host side of the Imp-to-Host\n         interface extends a message with 0's to fill out the message to\n         a Host word boundary.\n\n         BBN's mechanism works fine if the sending Host wants to send an\n         integral number of words, or if the sending Host's hardware is\n         capable of sending partial words.  However, in the event that\n\n\n\n\n\nPostel \u0026 Crocker                                                [Page 1]\n\f\nRFC 48                A Possible Protocol Plateau             April 1970\n\n\n         the sending Host wants to send an irregular length message and\n         its hardware is only capable of sending word-multiple messages,\n         some additional convention is needed.\n\n         One of the simplest solutions is to modify the Imp side of the\n         Host-to-Imp interface so that it appends only 0's.  This would\n         mean that the Host software would have to supply the trailing\n         1.  BBN rejected the change because of an understandably strong\n         bias against hardware changes.  It was also suggested that a\n         five instruction patch to the Imp program would remove the\n         interface supplied 1, but this was also rejected on the new\n         grounds that it seemed more secure to depend only upon the Host\n         hardware to signal message end, and not to depend upon the Host\n         software at all.\n\n         Two other solutions are also available.  One is to have \"double\n         padding\", whereby the sending Host supplies 10* and the network\n         also supplies 10*.  Upon input, a receiving Host then strips\n         the trailing 10* 10*.  The other solution is to make use of the\n         marking.  Marking is a string of the form 0*1 inserted between\n         the leader and the text of a message.  The original intent of\n         marking was to extend the leader so that the sending Host could\n         _begin_ its text on a word boundary.  It is also possible to\n         use the marking to expand a message so that it _ends_ on a word\n         boundary.\n\n         Notice that double padding could replace marking altogether by\n         abutting the text beginning against the leader.  For 32 bit\n         machines, this is convenient and marking is not, while for\n         other lengths, particularly 36 bit machines, marking is much\n         more convenient than double padding.\n\n         We have no strong preference, partially because we can send\n         word fragments.  Shoshani, et al in NWG/RFC #44 claim that\n         adjusting the marking does not cause them any problems, and\n         they have a 32 bit machine.  Since the idea of marking has been\n         accepted for some time, we suggest that double padding not be\n         used and that marking be used to adjust the length of a\n         message.  We note that if BBN ever does remove the 1 from the\n         hardware padding, only minimal change to Host software is\n         needed on the send side.\n\n         A much prettier (and more expensive) arrangement was suggested\n         by W. Sutherland.  He suggested that the Host/Imp interfaces be\n         smart enough to strip padding or marking and might even parse\n         the message upon input.\n\n\n\n\n\nPostel \u0026 Crocker                                                [Page 2]\n\f\nRFC 48                A Possible Protocol Plateau             April 1970\n\n\n      B. Reconnection\n\n         A very large population of networkers has beat upon us for\n         including dynamic reconnection in the protocol.  We felt it\n         might be of interest to relate how it came to be included.\n\n         After considering connections and their uses for a while, we\n         wondered how the mechanism of connections compared to existing\n         forms of intra-Host interprocess communication.  Two aspects\n         are of interest, what formalisms have been presented in the\n         literature, and what mechanisms are in use.  The formalisms are\n         interesting because they lead to uniform implementations and\n         parsimonious design.  The existing mechanisms are interesting\n         because they point out which problems need solving and\n         sometimes indicate what an appropriate formalism might be.  In\n         particular, we have noticed that the mechanisms for connecting\n         a console to the logger upon dial in, the mechanisms for\n         creating a job, and the mechanisms for passing a console around\n         to various processes within a job tend to be highly\n         idiosyncratic and distinct from all other structures and\n         mechanisms within an operating system.\n\n         With respect to the literature, it appears there is only one\n         idea with several variations, viz processes should share a\n         portion of their address spaces and cooperatively wake up each\n         other.  Semaphores and event channels are handy extensions of\n         wake up signals, but the intent is basically the same.  (Event\n         channels could probably function as connections, but it seems\n         not to be within their intended use.  In small systems, the\n         efficiency and capacity of event channels are inversely\n         related.)\n\n         With respect to existing implementations, we note that several\n         systems allow a process to appear to be a file to another\n         process.  Some systems, e.g. the SDS-940 at SRI impose a\n         master/slave relationship between two processes so connected,\n         but other systems provide for a coequal relationship e.g. the\n         AI group's PDP-6 system at MAC.  The PDP-6 system also has a\n         feature whereby a superior process can \"surround\" an inferior\n         process with a mapping from device and file names to other\n         device and file names.  Consoles have nearly the same semantics\n         as files, so it is quite reasonable for an inferior process to\n         believe it is communicating with the console but in fact be\n         communicating with another process.\n\n         The similarity between network connections and existing\n         sequential interprocess connections supports our belief that\n         network connections are probably the correct structure for\n\n\n\nPostel \u0026 Crocker                                                [Page 3]\n\f\nRFC 48                A Possible Protocol Plateau             April 1970\n\n\n         using the network.  Moreover, the structure is clean enough and\n         compatible with enough machines to pass as a formalism or\n         theory, at least to the extent of the other forms of\n         interprocess communication presented in the literature.\n\n         Any new formalism, we believe, must meet at least the following\n         two tests:\n\n            1. What outstanding problems does it solve?\n            2. Is it closed under all operations?\n\n         In the case of network connections, the candidates for the\n         first are the ones given above, i.e. all operations involving\n         connecting a console to a job or a process.  Also of interest\n         are the modelling of sequential devices such as tape drives,\n         printers and card readers, and the modeling of their buffering\n         (spooling, symbiont) systems.\n\n         The second question mentions closure.  In applying the\n         connection formalism to the dial-in and login procedures, we\n         felt the need to include some sort of switching or\n         reconnection, and an extremely mild form is presented in an\n         SJCC paper, which is also NWG/RFC #33.  This mild form permits\n         only the substitution of AEN's, and even then only at the time\n         of connection establishment. However, it is a common experience\n         that if an operation has a natural definition on an extended\n         domain, it eventually becomes necessary or at least desirable\n         to extend its definition.  Therefore, we considered the\n         following extensions:\n\n            1. Switching to any other socket, possibly in another Host.\n            2. Switching even after data flow has started.\n\n         There is even some precedent for feeling these extensions might\n         be useful.  In one view of an operating system, we see all\n         available phone lines as belonging to a live process known as\n         the logger.  The logger answers calls, screens users, and\n         creates jobs and processes.  One of the features of most\n         telephone answering equipment is that many phone lines may\n         serve the same phone number by using a block of sequential\n         numbers and a rotary answering system.  In our quest for\n         accurate models of practical systems, we wanted to be able to\n         provide equivalent service to network users, i.e. they should\n         be able to call a single advertised number and get connected to\n         the logger.  Thus a prima facie case for switching is\n         established.\n\n\n\n\n\nPostel \u0026 Crocker                                                [Page 4]\n\f\nRFC 48                A Possible Protocol Plateau             April 1970\n\n\n         Next we see that after the logger interrogates a prospective\n         user, it must connect the user to a newly created job.  Data\n         flow between the user and the logger has already commenced, so\n         flow control has to be meshed with switching if it is desired\n         not to lose or garble data in transit.\n\n         With respect to inter-Host switching, we find it easy to\n         imagine a utility service which is distributed throughout the\n         network and which passes connections from one socket to another\n         without the knowledge of the user.  Also, it is similar to the\n         more sophisticated telephone systems, to standard facilities of\n         telephone company operators, and to distributed private\n         systems.\n\n         These considerations led us to investigate the possibility of\n         finding one type of reconnection which provided a basis for all\n         known models.  The algorithm did not come easily, probably\n         because of inexperience with finite state automata theory, but\n         eventually we produced the algorithm presented in NWG/RFC #36.\n         A short time later, Bill Crowther produced an equivalent\n         algorithm which takes an alternate approach to race conditions.\n\n         Networkers seem to have one of two reactions.  Either it was\n         pretty and (perhaps ipso facto) useful, or it was complex and\n         (again perhaps ipso facto) unnecessary.  The latter group was\n         far more evident to us, and we were put into the defensive\n         position of admitting that dynamic reconnection was only\n\n            1. pretty\n            2. useful for login and console passing\n\n         In response to persistent criticism, we have made the following\n         change in the protocol.  Instead of calling socket \u003cO,H,O\u003e to\n         login, sockets of the form \u003cU,H,O\u003e and \u003cU,H,1\u003e are the input\n         and output sockets respectively of a copy of the logger or, if\n         a job has been stared with user id U, these sockets are the\n         console sockets.  The protocol for login is thus to initiate a\n         connection to \u003cU,H,O\u003e and \u003cU,H,1\u003e.  If user U is not in use, a\n         copy of the logger will respond and interrogate the caller.  If\n         user id U is in use, the call will be refused.  This\n         modification was suggested by Barry Wessler recently.  (Others\n         also suggested this change much earlier; but we rejected it\n         then.)\n\n         The logger may demand that the caller be from the same virtual\n         net, i.e. the caller may have user id U in some other Host, or\n         it may demand that the user supply a password matched to user\n\n\n\n\nPostel \u0026 Crocker                                                [Page 5]\n\f\nRFC 48                A Possible Protocol Plateau             April 1970\n\n\n         id U, or it may demand both.  Some systems may even choose to\n         permit anybody to login to any user id.\n\n         After login, AEN's 0 and 1 remain the console AEN's.  Each\n         system presumably has mechanisms for passing the console, and\n         these would be extended to know about AEN's 0 and 1 for network\n         users.  Passing the console is thus a matter of reconnecting\n         sockets to ports, and happens within the Host and without the\n         network.\n\n         In conversations with Meyer and Skinner after NWG/RFC #46 was\n         received, they suggested a login scheme different from both\n         Meyer's and ours in section above.  Their new scheme seemed a\n         little better and we look forward to their next note.\n\n         It is generally agreed that login should be \"third-level\", that\n         is, above the NCP level.  We are beginning to be indifferent\n         about particular logins schemes; all seem ok and none impress\n         us greatly.  We suggest that several be tried.  It is some\n         burden, of course, to modify the local login procedure, but we\n         believe it imposes no extra hardship to deal with diverse login\n         procedures.  This is because the text sequences and interrupt\n         conventions are so heterogenous that the additional burden of\n         following, say, our scheme on our system and Meyer's on Multics\n         is minimal.\n\n         We are agreed that reconnection should not be required in the\n         initial protocol, and we will offer it later as an optional and\n         experimental tool.  In addition, we would like to be on record\n         as predicting that general reconnection facilities will become\n         useful and will provide a unifying framework for currently ad\n         hoc operating system structures.\n\n      C. Decoupling Connections and Links\n\n         Bill Crowther (BBN) and Steve Wolfe (UCLA) independently have\n         suggested that links not be assigned to particular connections.\n         Instead, they suggest, include the destination socket as part\n         of the text of the message and then send messages over any\n         unblocked link.\n\n         We discussed this question a little in NWG/RFC #37, and feel\n         there is yet an argument for either case.  With the current\n         emphasis on simplicity, speed and small core requirements, it\n         seems more efficient to leave links and connections coupled.\n         We, therefore, recommend this.\n\n\n\n\n\nPostel \u0026 Crocker                                                [Page 6]\n\f\nRFC 48                A Possible Protocol Plateau             April 1970\n\n\n      D. Error Reporting\n\n         As mentioned by J. Heafner and E. Harslem of RAND, it is\n         important to treat errors which might occur.  A good philosophy\n         is to guard against any input which destroys the consistency of\n         the NCP's data base.\n\n         The specific formulation of the error command given by Heafner\n         and Harslem in NWG/RFC #40 and by Meyer in NWG/RFC #46 seems\n         reasonable and we recommend its adoption.  Some comments are in\n         order, however.\n\n         A distinction should be made between resource errors and other\n         types of errors.  Resource errors are just the detection of\n         overload conditions.  Overload conditions are well-defined and\n         valid, although perhaps undesirable.  Other types of errors\n         reflect errant software or hardware.  We feel that resource\n         errors should not be handled with error mechanisms, but with\n         mechanisms specific to the problem.  Thus the \u003cCLS\u003e command may\n         be issued when there is no more room to save waiting \u003cRFC\u003e's.\n         Flow control protocol is designed solely to handle buffering\n         overload.\n\n         With respect to true errors, we are not certain what the value\n         of the \u003cERR\u003e command is to the recipient.  Presumably his NCP\n         is broken, and it may only aggravate the problem to bombard it\n         with error commands.  We therefore, recommend that error\n         generation be optional, that all errors be logged locally in a\n         chronological file and that \u003cERR\u003e commands received likewise be\n         logged in a chronological file.  No corrective action is\n         specified at this time.\n\n         In the short time the network has been up at UCLA, we have\n         become convinced that the network itself will generate very few\n         errors.  We have watched the BBN staff debug and test the IMP\n         program, and it seemed that most of the errors affected timing\n         and throughput rather than validity.  Hence most errors will\n         probably arise from broken Hosts and/or buggy NCP's.\n\n      E. Status Testing and Reporting\n\n         A valuable debugging aid is to be able to get information about\n         what a foreign NCP thinks is happening.  A convenient way to do\n         this is to permit NCP's to send status whenever they wish, but\n         to always have them do it whenever they receive a request.\n\n\n\n\n\n\nPostel \u0026 Crocker                                                [Page 7]\n\f\nRFC 48                A Possible Protocol Plateau             April 1970\n\n\n         Since we view this feature as primarily a debugging tool, we\n         suggest that a distinct link, like 255, be used.  The intent is\n         that processing of status requests and generating of status\n         messages should use as little of the normal machinery as\n         possible.  Thus we suggest that link 255 be used to send\n         \"request status\" and \"status is\" commands.  The form follows\n         the suggestion on page 2 of NWG/RFC #40.\n\n         Meyer's \u003cECO\u003e command is easily implemented and serves the more\n         basic function of testing whether a foreign NCP is alive.  We\n         suggest that the length of the \u003cECO\u003e command be variable, as\n         there seems to be no significance in this context to 48 bits.\n         Also, the value of a (presumably) 8 bit binary switch is\n         unclear, so we recommend a pair of commands:\n\n                   \u003cECO\u003e   \u003clength\u003e   \u003ctext\u003e\n         and\n                   \u003cERP\u003e   \u003clength\u003e   \u003ctext\u003e\n         where\n                   \u003clength\u003e is 8 bits.\n\n         Upon receipt of an \u003cECO\u003e command the NCP would echo with the\n         \u003cERP\u003e command.\n\n      F. Expansion and Experimentation\n\n         As Meyer correctly points out in NWG/RFC #46, network protocol\n         is a layered affair.  Three levels are apparent so far.\n\n            1. IMP Network Protocol\n            2. Network Control Program Protocol\n            3. Special user level or Subsystem Level Protocol\n\n         This last level should remain idiosyncratic to each Host (or\n         even each user).  The first level is well-specified by BBN, and\n         our focus here is on level 2.  We would like to keep level 2 as\n         neutral and simple as possible, and in particular we agree that\n         login protocol should be as much on level 3 as possible.\n\n         Simplicity and foresight notwithstanding, there will arise\n         occasions when the level 2 protocol should change or be\n         experimented with.  In order to provide for experimentation and\n         change, we recommend that only link numbers 2 through 31 be\n         assigned to regular connections, with the remaining link\n         numbers, 32 to 255, used experimentally.  We have already\n         suggested that link 255 be used for status requests and\n         replies, and this is in consonance with our view of the\n         experimental aspects of that feature.\n\n\n\nPostel \u0026 Crocker                                                [Page 8]\n\f\nRFC 48                A Possible Protocol Plateau             April 1970\n\n\n         We also recommend that control command prefixes from 255\n         downward be used for experimentation.\n\n         These two conventions are sufficient, we feel to permit\n         convenient experimentation with new protocol among any subset\n         of the sites. We thus do not favor inclusion of Ancona's\n         suggestion in NWG/RFC #42 for a message data type code as the\n         first eight bits of the text of a message.\n\n      G. Multiplexing Ports to Sockets\n\n         Wolfe in NWG/RFC #38 and Shoshani et al in NWG/RFC #44 suggest\n         that it should be possible to attach more than one port to a\n         socket.  While all of our diagrams and prototypical system\n         calls have shown a one-to-one correspondence between sockets\n         and ports, it is strictly a matter of local implementation.  We\n         note that sockets form a network-wide name space whose sole\n         purpose is to interface between the idiosyncratic structures\n         peculiar to each operating system.  Our references to ports are\n         intended to be suggestive only, and should be ignored if no\n         internal structures corresponds to them.  Most systems do have\n         such structures, however, so we shall continue to use them for\n         illustration.\n\n      H. Echoing, Interrupts and Code Conversion\n\n         1. Interrupts\n\n            We had been under the impression that all operating systems\n            scanned for a reserved character from the keyboard to\n            interpret it as an interrupt signal.  Tom Skinner and Ed\n            Meyer of MIT inform us that model 37 TTY's and IBM 2741\n            generate a \"long space\" of 200-500 milliseconds which is\n            detected by the I/O channel hardware and passed to the\n            operating system as an interrupt.  The \"long space\" is not a\n            character -- it has no ASCII code and cannot be program\n            generated.\n\n            Well over a year ago, we considered the problem of\n            simulating console interrupts and rejected the \u003cINT\u003e type\n            command because it didn't correctly model any system we\n            knew.  We now reverse our position and recommend the\n            implementation of an INTERRUPT system call and an \u003cINT\u003e\n            control command as suggested by Meyer in NWG/RFC #46.\n\n\n\n\n\n\n\nPostel \u0026 Crocker                                                [Page 9]\n\f\nRFC 48                A Possible Protocol Plateau             April 1970\n\n\n            Two restrictions of the interrupt facility should be\n            observed.  First, when communicating with systems which scan\n            for interrupt characters, this feature should not be used.\n            Second, non-console-like connections probably should not\n            have interrupts. We recommend that systems follow their own\n            conventions, and if an \u003cINT\u003e arrives for a connection on\n            which it shouldn't the \u003cINT\u003e should be discarded and\n            optionally returned as an error.\n\n         2. Echoing and Code Conversion\n\n            We believe that each site should continue its current\n            echoing policy and that code conversion should be done by\n            the using process.  Standardization in this area should\n            await further development.\n\n            Ancona's suggestion of a table-driven front-end transducer\n            seems like the right thing, but we believe that such\n            techniques are part of a larger discussion involving\n            higher-level languages for the network.\n\n      I. Broadcast Facilities\n\n         Heafner and Harslem suggest in NWG/RFC #39 a broadcast\n         facility, i.e. \u003cTER\u003e and \u003cBDC\u003e.  We do not fully understand the\n         value of this facility and are thus disposed against it.  We\n         suspect that we would understand its value better if we had\n         more experience with OS/360.  It is probably true in general\n         that sites running OS/360 or similar systems will find less\n         relevance in our suggestions for network protocol than sites\n         running time-sharing systems.  We would appreciate any cogent\n         statement on the relationship between OS/360 and the concepts\n         and assumptions underlying the network protocol.\n\n      J. Instance Numbers\n\n         Meyer in NWG/RFC #46 suggests extending a socket to include an\n         _instance_ code which identifies the process attached to the\n         socket.  We carefully arranged matters so that processes would\n         be indistinguishable.  We did this with the belief that both as\n         a formal and as a practical matter it is of concern only within\n         a Host whether a computation is performed by one or many\n         processes.  Thus we believe that all processes within a job\n         should cooperate in allocating AEN's.  If an operating system\n         has facilities for passing a console from process to process\n         within a job, these facilities mesh nicely with the current\n         network protocol, even within reconnection protocol; but\n         instance numbers interfere with such a procedure.\n\n\n\nPostel \u0026 Crocker                                               [Page 10]\n\f\nRFC 48                A Possible Protocol Plateau             April 1970\n\n\n         We suggest this matter be discussed fully because it relates to\n         the basic philosophy of sockets and connections.  Presently we\n         recommend 40 bit socket numbers without instance codes.\n\n      K. AEN's\n\n         Nobody, including us, is particularly happy with our name AEN\n         for the low order 8 bits of the socket.  We rejected _socket_\n         number_, and are similarly unhappy with Meyer's _socket_code_.\n         The word socket should not be used as part of the field name,\n         and we solicit suggestions.\n\nIII. Environment\n\n   We assume that the typical host will have a time-sharing operating\n   system in which the cpu is shared by processes.\n\n   Processes\n\n   We envision that each process is tagged with a _user_number_. There\n   may be more than one process with the same user number, and if so,\n   they should all be cooperating with respect to using the network.\n\n   We envision that each process contains a set of _ports_ which are\n   unique to the process.  These ports are used for input to or output\n   from the process, from or to files, devices or other processes.\n\n   We also envision that each process has an event channel over which it\n   can receive very short messages (several bits).  We will use this\n   mechanism to notify a process that some action external to the\n   process has occurred.\n\n   To engage in network activity, a process _attaches_ a _local_socket_\n   to one of its ports.  Sockets are identified by user number, host and\n   AEN, and a socket is local to a process if their user numbers match\n   and they are in the same host.  A process need only specify an AEN\n   when it is referring to a local socket.\n\n   Each port has a status which is modified by system calls and by\n   concurrent events outside the process.  Whenever the status of a port\n   is changed, the process is sent an event over its event channel which\n   specifies which port's status has changed.  The process may then look\n   at a port's status.\n\n   These assumptions are used descriptive material which follows.\n   However, these assumptions are not imposed by the network protocol\n   and the implementation suggested by section IV is in no way binding.\n\n\n\n\nPostel \u0026 Crocker                                               [Page 11]\n\f\nRFC 48                A Possible Protocol Plateau             April 1970\n\n\n   We wish to make very clear that this material is offered only to\n   provide clues as to what the implementation difficulties might be and\n   not to impose any particular discipline.\n\n   For example, we treat \u003cRFC\u003e's which arrive for unattached local\n   sockets as valid and queue them.  If desired, an NCP may reject them,\n   as Meyer suggests, or it might hold them for awhile and reject them\n   if they're not soon satisfied.  The offered protocol supports all\n   these options.\n\n   Another local option is the one mentioned before of attaching\n   multiple ports to a socket.  We have shown one-one correspondence but\n   this may be ignored.  Similarly, the system calls are merely\n   suggestive.\n\n   System Calls\n\n   These are typical system calls which a user process might execute.\n   We show these only for completeness; each site will undoubtedly\n   implement whatever equivalent set is convenient.\n\n        We use the notation\n\n        Syscall ( arg , arg ...; val ... )\n                     1     2        1\n   where\n        Syscall is the system call\n        arg  etc. are the parameters supplied with the call, and\n           1\n        val etc. are any values returned by the system call.\n           1\n\n   Init (P,AEN,FS,Bsiz;C)\n\n        P      Specifies a port of the process.\n        AEN    Specifies a local socket.  The user number of this\n               process and host number of this host are implicit.\n        FS     Specifies a socket with any user number in any host,\n               with any AEN.\n        Bsiz   Specified the amount of storage in bits the user wants\n               to devote to buffering messages.\n        C      The condition code returned.\n\n   Init attempts to attach the local socket specified by AEN to the port\n   P and to initiate a connection with socket FS.  Possible returned\n   values of C are\n\n\n\n\n\nPostel \u0026 Crocker                                               [Page 12]\n\f\nRFC 48                A Possible Protocol Plateau             April 1970\n\n\n        C = ok      The Init was legal and the socket FS is being\n                    contacted.  When the connection is established or\n                    when FS refuses, the process will receive an event.\n\n        C = busy    The local socket was in use by a port on this or\n                    some other process with the same user number.  No\n                    action was taken.\n\n        C = homosex The AEN and FS were either both send or both receive\n                    sockets.\n\n        C = nohost  The host designated within FS isn't known.\n\n        C = bufbig  Bsiz is too large.\n\n   Listen (P,AEN,Bsize;C)\n\n        P     Specifies a port of the process.\n        AEN   Specifies a local socket.\n        Bsiz  Specified a buffer size.\n        C     The returned legality code.\n\n   Codes for C are\n\n        C = ok\n        C = busy\n        C = bufbig\n\n   The local socket specifies by AEN is attached to P.  If there is a\n   waiting call, it is processed; otherwise no action is taken.  When a\n   call comes in, a connection will be established and the process\n   notified via an event.\n\n   Close (P)\n\n        P Specifies a port of the process.\n\n   Any activity is stopped, and the port becomes free for other use.\n\n   Transmit (P,M,L1;L2,C)\n\n        P     Specifies port with an open connection.\n        M     The text to be transmitted.\n        L1    Specifies the length of the text.\n        L2    The length actually transmitted.\n        C     The error code.\n\n\n\n\n\nPostel \u0026 Crocker                                               [Page 13]\n\f\nRFC 48                A Possible Protocol Plateau             April 1970\n\n\n   Transmission between the processes on either side of the port takes\n   place.\n\n   Codes for C are\n\n        C = ok\n   or\n        C = not open     if no connection is currently open and\n                         otherwise uninhibited\n   Status (P;C)\n\n   The status of port P is returned as C.\n\nIV. The NCP\n\n   We view the NCP as having five component programs, three associative\n   tables, some queues and buffers, and a link assignment table.  Each\n   site will of course, vary this design to meet its needs, so our\n   design is only illustrative.\n\n   The Component Programs\n\n      1. The Input Handler\n\n         This is an interrupt driven input routine.  It initiates Imp-\n         to-Host transmission into a resident buffer and wakes up the\n         Input Interpreter when transmission is complete.\n\n      2. The Output Handler\n\n         This is an interrupt driven output routine.  It initiates\n         Host-to-Imp transmission out of a resident buffer and wakes up\n         the Output Scheduler when transmission is complete.\n\n      3. The Input Interpreter\n\n         This program decides whether the input is a regular message\n         intended for a user, a control message, an Imp-to-Host message,\n         or an error.  For each class of message, this program takes the\n         appropriate action.\n\n      4. The Output Scheduler\n\n         Three classes of message are sent to the Imp\n\n            (a) Host-to-Imp messages\n            (b) Control messages\n            (c) Regular messages\n\n\n\nPostel \u0026 Crocker                                               [Page 14]\n\f\nRFC 48                A Possible Protocol Plateau             April 1970\n\n\n         We believe that a priority should be imposed among these\n         classes.  The priority we suggest is the ordering above. The\n         Output Scheduler selects the highest priority message and\n         gives it to the Output Handler.\n\n      5. The System Call Interpreter\n\n         This program interprets requests from the user.\n\n   The two interesting components are the Input Interpreter and the\n   System Call Interpreter.  These are similar in that the Input\n   Interpreter services foreign requests and the System Call Interpreter\n   services local requests.\n\n   Associative Tables\n\n   We envision that the bulk of the NCP's data base is in three\n   associative tables.  By \"associative\", we mean that there is some\n   lookup routine which is presented with a key and either returns\n   successfully with a pointer to the corresponding entry, or fails if\n   no entry corresponds to the key.\n\n      1. The Rendezvous Table\n\n         \"Requests-for-connection\" and other attributes of a\n         connection are held in this table.  This table is accessed by\n         local socket, but other tables have pointers to existing\n         entries.\n\n            The components of an entry are:\n\n            (a) local socket   (key)\n            (b) foreign socket\n            (c) link\n            (d) queue of callers\n            (e) text queue\n            (f) connection state\n            (g) flow state\n            (h) pointer to attached port\n\n            An entry is created when a user executes either an Init or a\n            Listen system call or when a \u003cRFC\u003e is received.  Some fields\n            are unused until the connection is established, e.g. the\n            foreign socket is not known until a \u003cRFC\u003e arrives if the\n            user did a Listen.\n\n\n\n\n\n\nPostel \u0026 Crocker                                               [Page 15]\n\f\nRFC 48                A Possible Protocol Plateau             April 1970\n\n\n      2. The Input Link Table\n\n            The Input Interpreter uses the foreign host and link as a\n            key to get a pointer to the entry in the rendezvous table\n            for the connection using the incoming link.\n\n      3. The Output Link Table\n\n            In order to interpret RFNM's, the Input Interpreter needs a\n            table in the same form as the Input Link Table but using\n            outgoing links.\n\n   Link Assignment Table\n\n   This is a very simple structure which keeps track of which links are\n   in use for each host.  One word per host probably suffices.\n\n   The following diagram is our conception of the Network Control\n   Program.  Boxes represent tables and Buffers, boxes with angled\n   corners and a double bottom represent Queues, and jagged boxes\n   represent component programs, the arrows represent data paths.\n\n   The abbreviated names have the following meanings.\n\n   ILT   - Input Link Table\n\n   OLT   - Output Link Table\n\n   LAT   - Link Assignment Table\n\n   RT    - Rendezvous Table\n\n   HIQ   - Host to Imp Queue\n\n   OCCQ  - Output Control Command Queue\n\n   ORMQ  - Output Regular Message Queue\n\n   IHBuf - Buffer filled by the Input Handler from the IMP and\n           emptied by the Input Interpreter\n\n   OHBuf - Buffer of outgoing messages filled from the Queues\n           by the Output Scheduler and emptied by the Output\n           Handler.\n\n\n\n\n\n\n\nPostel \u0026 Crocker                                               [Page 16]\n\f\nRFC 48                A Possible Protocol Plateau             April 1970\n\n\n                              +---------+\n                              |  I M P  |\n                              +---------+\n                                v     ^\n                                |     |\n    +---------------------------|-----|------------------------------+\n    |                           |     |                              |\n    |   /\\/\\/\\/\\/\\/\\/\\          |     |     /\\/\\/\\/\\/\\/\\/\\           |\n    |   \\            / \u003c--------+     +---\u003c \\            /           |\n    |   /  Input     \\                      /  Output    \\           |\n    |   \\   Handler  /                      \\   Handler  / \u003c----+    |\n    |   /            \\ \u003e------+             /            \\      |    |\n    |   \\/\\/\\/\\/\\/\\/\\/        |             \\/\\/\\/\\/\\/\\/\\/      ^    |\n    |                         v                              +-----+ |\n    |                      +-----+                           | OH  | |\n    |                      | IM  |                           | Buf | |\n    |                      | Buf |                           +-----+ |\n    |                      +-----+          /\\/\\/\\/\\/\\/\\/\\/\\    ^    |\n    | /\\/\\/\\/\\/\\/\\/\\/\\        v      +----\u003e \\              /    |    |\n    | \\              /        |      |      /  Output      \\ \u003e--+    |\n    | /              \\ \u003c------+      ^      \\              /         |\n    | \\  Input       /           /-----\\    /   Scheduler  \\         |\n    | /              \\ \u003e--------\u003e| HIQ |    \\              /         |\n    | \\  Interpreter /           |_____|    /              \\         |\n    | /              \\ \u003e----+    \\_____/    \\/\\/\\/\\/\\/\\/\\/\\/         |\n    | \\/\\/\\/\\/\\/\\/\\/\\/      |                ^     v    ^            |\n    |   ^   ^    ^   \\      |    /-----\\     |     |    |    /-----\\ |\n    |   |    \\    \\   \\     |    |  O  |     |     |    |    |  O  | |\n    |   |     \\    \\   \\    +---\u003e|  C  |\u003e----+     |    +---\u003c|  R  | |\n    |   v     v     v   \\        |  C  |           |         |  M  | |\n    | +---+ +---+ +---+  \\       |  Q  |           v         |  Q  | |\n    | |   | |   | |   |   \\      |_____|      +---------+    |_____| |\n    | |ILT| |LAT| |OLT|    \\     \\_____/      |         |    \\_____/ |\n    | |   | |   | |   |     \\       ^         |   R T   |       ^    |\n    | +---+ +---+ +---+      +------|--------\u003e|         |       |    |\n    |         v                     |         +---------+       |    |\n    |         |                     ^              ^            |    |\n    |         |            /\\/\\/\\/\\/\\/\\/\\/\\        |            |    |\n    |         |            \\              /        |            |    |\n    |         +-----------\u003e/    System    \\\u003c-------+            |    |\n    |                      \\     Call     /                     |    |\n    |                      /  Interpreter \\\u003e--------------------+    |\n    |                      \\              /                          |\n    |                  +--\u003e/              \\\u003e--+                      |\n    |                  |   \\/\\/\\/\\/\\/\\/\\/\\/   |                      |\n    +------------------|----------------------|----------------------+\n                       |                      |\n                       +---\u003c system calls \u003c---+\n\n\n\nPostel \u0026 Crocker                                               [Page 17]\n\f\nRFC 48                A Possible Protocol Plateau             April 1970\n\n\n       [ This RFC was put into machine readable form for entry ]\n   [ into the online RFC archives by Donald and Jill Eastlake 1999 ]\n\n[Editor's note: The original hand-drawn diagram represented\nQueues by cylinders and component programs by \"squishy ameoba\nlike things\".]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPostel \u0026 Crocker                                               [Page 18]\n\f\n"
}