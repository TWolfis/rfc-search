{
  "series": "Request for Comments",
  "number": "114",
  "howpublished": "RFC 114",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0114",
  "url": "https://www.rfc-editor.org/info/rfc114",
  "title": "File Transfer Protocol",
  "pagetotal": "17",
  "year": "1971",
  "month": "apr",
  "day": "1",
  "body": "\n\n\n\n\n\nNetwork Working Group                                         A. Bhushan\nRequest for Comments: 114                                MIT Project MAC\nNIC: 5823                                                  16 April 1971\n\n\n                        A FILE TRANSFER PROTOCOL\n\n\nI. Introduction\n\n   Computer network usage may be divided into two broad categories --\n   direct and indirect.  Direct usage implies that you, the network\n   user, are \"logged\" into a remote host and use it as a local user.\n   You interact with the remote system via a terminal (teletypewriter,\n   graphics console) or a computer.  Differences in terminal\n   characteristics are handled by host system programs, in accordance\n   with standard protocols (such as TELNET (RFC 97) for teletypewriter\n   communications, NETRJS (RFC 88) for remote job entry).  You, however,\n   have to know the different conventions of remote systems, in order to\n   use them.\n\n   Indirect usage, by contrast, does not require that you explicitly log\n   into a remote system or even know how to \"use\" the remote system.  An\n   intermediate process makes most of the differences in commands and\n   conventions invisible to you.  For example, you need only know a\n   standard set of network file transfer commands for your local system\n   in order to utilize remote file system.  This assumes the existence\n   of a network file transfer process at each host cooperating via a\n   common protocol.\n\n   Indirect use is not limited to file transfers.  It may include\n   execution of programs in remote hosts and the transfer of core\n   images.  The extended file transfer protocol would facilitate the\n   exchange of programs and data between computers, the use of storage\n   and file handling capabilities of other computers (possibly including\n   the trillion-bit store data computer), and have programs in remote\n   hosts operate on your input and return an output.\n\n   The protocol described herein has been developed for immediate\n   implementation on two hosts at MIT, the GE645/Multics and the PDP-\n   10/DM/CG-ITS (and possibly Harvard's PDP-10).  An interim version\n   with limited capabilities is currently in the debugging stage. [1]\n   Since our implementation involves two dissimilar systems (Multics is\n   a \"service\" system, ITS is not) with different file systems (Multics\n   provides elaborate access controls, ITS provides none), we feel that\n   the file transfer mechanisms proposed are generalizable.  In\n   addition, our specification reflects a consideration of other file\n   systems on the network.  We conducted a survey [2] of network host\n\n\n\nBhushan                                                         [Page 1]\n\f\nRFC 114                 A FILE TRANSFER PROTOCOL           16 April 1971\n\n\n   systems to determine the requirements and capabilities.  This paper\n   is a \"first cut\" at a protocol that will allow users at any host on\n   the network to use the file system of every cooperating host.\n\nII.  Discussion\n\n   A few definitions are in order before the discussion of the protocol.\n   A file is an ordered set consisting of computer instructions and/or\n   data.  A file can be of arbitrary length [3].  A named file is\n   uniquely identified in a system by its file name and directory name.\n   The directory name may be the name of a physical directory or it may\n   be the name of a physical device.  An example of physical directory\n   name is owner's project-programmer number and an example of physical\n   device name is tape number.\n\n   A file may or may not have access controls associated with it.  The\n   access controls designate the users' access privileges.  In the\n   absence of access controls, the files cannot be protected from\n   accidental or unauthorized usage.\n\n   A principal objective of the protocol is to promote the indirect use\n   of computers on the network.  Therefore, the user or his program\n   should have a simple and uniform interface to the file systems on the\n   network and be shielded from the variations in file and storage\n   systems of different host computers.  This is achieved by the\n   existence of a standard protocol in each host.\n\n   Criteria by which a user-level protocol may be judged were described\n   by Mealy in RFC 91, as involving the notion of logical records,\n   ability to access files without program modifications, and\n   implementability.  I would add to these efficiency, extendibility,\n   adaptability, and provision of error-recovery mechanisms.\n\n   The attempt in this specification has been to enable the reliable\n   transfer of network ASCII (7-bit ASCII in 8-bit field with leftmost\n   bit zero) as well as \"binary\" data files with relative ease.  The use\n   of other character codes, such as EBCDIC, and variously formatted\n   data (decimal, octal, ASCII characters packed differently) is\n   facilitated by inclusion of data type in descriptor headings.  An\n   alternative mechanism for defining data is also available in the form\n   of attributes in file headings.  The format control characters\n   reserved for the syntax of this protocol have identical code\n   representation in ASCII and EBCDIC.  (These character are SOH, STX,\n   ETX, DC1, DC2, DC3, US, RS, GS, and FS.)\n\n\n\n\n\n\n\nBhushan                                                         [Page 2]\n\f\nRFC 114                 A FILE TRANSFER PROTOCOL           16 April 1971\n\n\n   The notion of messages (the physical blocks of data communicated\n   between NCP's) is suppressed herein and that of \"logical\" records and\n   transactions is emphasized.  The data passed by the NCP is parsed\n   into logical blocks by use of simple descriptors (code and count\n   mechanisms) as described in Section III.  The alternative to count is\n   fixed length blocks or standard end-of-file characters (scan data\n   stream).  Both seem less desirable than count.\n\n   The cooperating processes may be \"daemon\" processes which \"listen\" to\n   agreed-upon sockets, and follow the initial connection protocol much\n   in the same way as a \"logger\" does.  We recommend using a single\n   full-duplex connection for the exchange of both data and control\n   information [4], and using CLS to achieve synchronization when\n   necessary (a CLS is not transmitted until a RFNM is received).\n\n   The user may be identified by having the using process send at the\n   start of the connection the user's name information (either passed on\n   by user or known to the using system) [5].  This user name\n   information (a sequence of standard ASCII characters), along with the\n   host number (known to the NCP), positively identifies the user to the\n   serving process.\n\n   At present, more elaborate access control mechanisms, such as\n   passwords, are not suggested.  The user, however, will have the\n   security and protection provided by the serving system.  The serving\n   host, if it has access controls, can prevent unprivileged access by\n   users from other host sites.  It is up to the using host to prevent\n   its own users from violating access rules.\n\n   The files in a file system are identified by a pathname, similar to\n   the labels described in RFC 76 (Bouknight, Madden, and Grossman).\n   The pathname contains the essential information regarding the storage\n   and retrieval of data.\n\n   In order to facilitate use, default options should be provided.  For\n   example, the main file directory on disk would be the default on the\n   PDP-10/ITS, and a pool directory would be the default on Multics.\n\n   The file to be transferred may be a complete file or may consist of\n   smaller records.  It may or may not have a heading.  A heading should\n   contain ASCII or EBCDIC characters defining file attributes.  The\n   file attributes could be some simple agreed-upon types or they could\n   be described in a data reconfiguration or interpretation language\n   similar to that described in RFC 83 (Anderson, Haslern, and Heffner),\n   or a combination.\n\n\n\n\n\n\nBhushan                                                         [Page 3]\n\f\nRFC 114                 A FILE TRANSFER PROTOCOL           16 April 1971\n\n\n   The protocol does not restrict the nature of data in the file.  For\n   example, a file could contain ASCII text, binary core image, graphics\n   data or any other type of data.  The protocol includes an \"execute\"\n   request for files that are programs.  This is intended to facilitate\n   the execution of programs and subroutines in remote host computers\n   [6].\n\nIII.  SPECIFICATIONS\n\n1. Transactions\n\n   1A.   The protocol is transaction-oriented.  A transaction is defined\n         to be an entity of information communicated between cooperating\n         processes.\n\n   1B.   Syntax\n\n         A transaction has three fields, a 72-bit descriptor field and\n         variable length (including zero) data and filler fields, as\n         shown below.  The total length of a transaction is (72 + data +\n         filler) bits.\n\n   | \u003ccode\u003e\u003cfiller count\u003e\u003cNUL\u003e\u003cdata count\u003e\u003cNUL\u003e |    \u003cdata\u003e\u003cfiller\u003e   |\n   | |____||____________||___||__________||___| |    |____________|   |\n   |   |         |         |        |       |   |          |          |\n   | 24-bits   8-bits    8-bits  24-bits  8-bits|    variable length  |\n   | \u003c-------descriptor field 72-bits---------\u003e |\u003c--data and filler--\u003e|\n   |                                            |                     |\n\n   1C.   Semantics\n\n         The code field has three 8-bit bytes.  The first byte is\n         interpreted as transaction type, the second byte as data type\n         and the third byte as extension of data type.\n\n         The filler count is a binary count of bits used as \"filler\"\n         (i.e., not information) at the end of a transaction [7].  As\n         the length of the filler count field is 8-bits, the number of\n         bits of filler shall not exceed 255 bits.\n\n         The data count is a binary count of the number of data (i.e.,\n         information) bits in the data field, not including filler bits.\n         The number of data bits is limited to (2^24-1), as there are 24\n         bits in the data count field.\n\n\n\n\n\n\n\nBhushan                                                         [Page 4]\n\f\nRFC 114                 A FILE TRANSFER PROTOCOL           16 April 1971\n\n\n         The NUL bytes are inserted primarily as fillers in the\n         descriptor field and allow the count information to appear at\n         convenient word boundaries for different word length machines\n         [8].\n\n2.  Transaction Types\n\n   2A.   A transaction may be of the following four basic types:\n         request, response, transfer and terminate.  Although large\n         number of request and transfer types are defined,\n         implementation of a subset is specifically permitted.  Host\n         computers, on which a particular transaction type is not\n         implemented, may refuse to accept that transaction by\n         responding with an unsuccessful terminate.\n\n         The following transaction type codes are tentatively defined:\n\n         Transaction Type                       Transaction Type Code\n\n                                             ASCII   Octal   Hexidecimal\n\n         Request\n                 Identify                        I       111     49\n                 Retrieve                        R       122     52\n                 Store                           S       123     53\n                 Append                          A       101     41\n                 Delete                          D       104     44\n                 Rename                          N       116     4E\n                 addname (Plus)                  P       120     50\n                 deletename (Minus)              M       115     4D\n                 Lookup                          L       114     4C\n                 Open                            O       117     4F\n                 Close                           C       103     43\n                 Execute [9]                     E       105     45\n\n         Response\n                 ready-to-receive (rr)           \u003c       074     3C\n                 ready-to-send (rs)              \u003e       076     3E\n\n         Transfer\n                 complete_file                   *       052\n                 heading                         #       043     23\n                 part_of_file                    '       054     2C\n                 last_part                       .       056     2E\n\n         Terminate\n                 successful (pos.)               +       053     2B\n                 unsuccessful (neg.)             -       055     2D\n\n\n\nBhushan                                                         [Page 5]\n\f\nRFC 114                 A FILE TRANSFER PROTOCOL           16 April 1971\n\n\n   2B.   Syntax\n\n         In the following discussion US, RS, GS, FS, DC1, DC2, and DC3\n         are the ASCII characters, unit separator (octal 037), record\n         separator (octal 036), group separator (octal 035), file\n         separator (octal 034), device control 1 (octal 021), device\n         control 2 (octal 022), and device control 3 (octal 023),\n         respectively.  These have an identical interpretation in\n         EBCDIC.\n\n   2B.1  Requests\n\n         Identify, retrieve, store, append, delete, open, lookup and\n         execute requests have the following data field:\n\n                       \u003cpath name\u003e\n\n                Rename request has the data field:\n\n                       \u003cpath name\u003e GS \u003cname\u003e\n\n                Addname and deletename requests have the data field:\n\n                       \u003cpath name\u003e GS \u003cfilenames\u003e\n\n         where pathname [10], name and filenames have the following\n         syntax (expressed in BNF, the metalanguage of the ALGOL 60\n         report):\n\n         \u003cpathname\u003e ::= \u003cdevice name\u003e|\u003cname\u003e|\u003cpathname\u003eUS\u003cname\u003e\n         \u003cdevice name\u003e ::= DC1\u003cname\u003e\n\n         \u003cname\u003e ::= \u003cchar\u003e | \u003cname\u003e \u003cchar\u003e\n         \u003cchar\u003e ::= All 8-bit ASCII or EBCDIC characters except\n\n                 US, RS, GS, FS, DC1, DC2, AND DC3.\n\n         \u003cfilenames\u003e ::= \u003cname\u003e|\u003cfilenames\u003e RS \u003cname\u003e\n\n         The data type for the request transaction shall be either A\n         (octal 101 for ASCII, or E (octal 105) for EBCDIC [11].\n\n         Some examples of pathname are:\n\n         DC1 MT08\n         DC1 DSK 1.2 US Net\u003c3\u003e US J.Doe US Foo\n         udd US proj. US h,n/x US user US file\n         filename 1 filename 2\n\n\n\nBhushan                                                         [Page 6]\n\f\nRFC 114                 A FILE TRANSFER PROTOCOL           16 April 1971\n\n\n   2B.2  Responses\n\n         The response transactions shall normally have an empty data\n         field.\n\n   2B.3  Transfers\n\n         The data types defined in section 4 will govern the syntax of\n         the data field in transfer transactions.  No other syntactical\n         restrictions exist.\n\n   2B.4  Terminates\n\n         The successful terminate shall normally have an empty data\n         field.  The unsuccessful terminate may have a data field\n         defined by the data types A (octal 101) for ASCII, E (octal\n         105) for EBCDIC, or S (octal 123) for status.\n\n         A data type code of 'S' would imply byte oriented error return\n         status codes in the data field.  The following error return\n         status codes are defined tentatively:\n\n         Error Code Meaning                        Error Code\n                                             ASCII   Octal  Hexadecimal\n\n         Undefined error                       U       125     55\n         Transaction type error                T       124     54\n         Syntax error                          S       123     53\n         File search failed                    F       106     46\n         Data type error                       D       104     44\n         Access denied                         A       101     41\n         Improper transaction sequence         I       111     49\n         Time-out error                        O       117     4F\n         Error condition by system             E       105     45\n\n   2C.   Semantics\n\n   2C.1  Requests\n\n         Requests are always sent by using host.  In absence of a device\n         name or complete pathname, default options should be provided\n         for all types of requests.\n\n         _Identify_ request identifies the user as indicated by\n         \u003cpathname\u003e from serving to using host.\n\n         _Retrieve_ request achieves the transfer of file specified in\n         \u003cpathname\u003e from serving to using host.\n\n\n\nBhushan                                                         [Page 7]\n\f\nRFC 114                 A FILE TRANSFER PROTOCOL           16 April 1971\n\n\n         _Store_  request achieves the transfer of file specified in\n         \u003cpathname\u003e from using to serving host.\n\n         _Append_ request causes data to be added to file specified in\n         pathname.\n\n         _Rename_ request causes name of file specified in \u003cpathname\u003e to\n         be replaced by name specified in \u003cname\u003e.\n\n         _Delete_ request causes file specified in \u003cpathname\u003e to be\n         deleted.  If an extra level of protection for delete is desired\n         (such as the query 'Do you wish to delete file x?'), it is to\n         be a local implementation option.\n\n         _Addname_ and _deletename_ requests cause names in \u003cfilenames\u003e\n         to be added or deleted to existing names of file specified in\n         \u003cpathname\u003e.  These requests are useful in systems such as\n         Multics which allow multiple names to be associated with a\n         file.\n\n         _Lookup_ request achieves the transfer of attributes (such as\n         date last modified, access list, etc) of file specified in\n         \u003cpathname\u003e, instead of the file itself.\n\n         _Open_ request does not cause a data transfer, instead file\n         specified in \u003cpathname\u003e is \"opened\" for retrieve (read) or\n         store (write).  Subsequent requests are then treated as\n         requests pertaining to the file that is opened till such a time\n         that a close request is received.\n\n         _Execute_ request achieves the execution of file specified in\n         \u003cpathname\u003e, which must be an executable program.  Upon receipt\n         of rr response, using host will transmit the necessary input\n         data (parameters, arguments, etc).  Upon completion of\n         execution serving host will send the results to using host and\n         terminate [12].\n\n   2C.2  Response\n\n         Responses are always sent by serving host.  The rr response\n         indicates that serving host is ready to receive the file\n         indicated in the preceding request.  The rs response indicates\n         that the next transaction from serving host will be the\n         transfer of file indicated in the preceding request.\n\n\n\n\n\n\n\nBhushan                                                         [Page 8]\n\f\nRFC 114                 A FILE TRANSFER PROTOCOL           16 April 1971\n\n\n   2C.3  Transfers\n\n         Transfers may be sent by either host.  Transfer transactions\n         indicate the transfer of file indicated by a request.  Files\n         can be transferred either as complete_file transactions or as\n         part_of_file transactions followed by last_part transactions.\n         The file may also have a heading transaction in the beginning.\n         The syntax of a file, therefore, may be defined as:\n\n         \u003cfile\u003e ::= \u003ctext\u003e | \u003cheading\u003e \u003ctext\u003e\n         \u003ctext\u003e ::= \u003ccomplete_file\u003e | \u003cparts\u003e \u003clast_part\u003e\n         \u003cparts\u003e ::= \u003cpart_of_file\u003e | \u003cparts\u003e \u003cpart_of_file\u003e\n\n         Headings may be used to communicate the attributes of files.\n         The form of headings is not formally specified but is discussed\n         in Section IV as possible extension to this protocol.\n\n   2C.4  Terminates\n\n         The successful terminate is always sent by serving host.  It\n         indicates to using host that serving host has been successful\n         in serving the request and has gone to an initial state.  Using\n         host will then inform user that his request is successfully\n         served, and go to an initial state.\n\n         The unsuccessful terminate may be sent by either host.  It\n         indicates that sender of the terminate is unable to (or does\n         not not wish to) go through with the request.  Both hosts will\n         then go to their initial states.  The using host will inform\n         the user that his request was aborted.  If any reasons for the\n         unsuccessful terminate (either as text or as error return\n         status codes) are received, these shall be communicated to the\n         user.\n\n3.    Transaction Sequence\n\n   3A.   The transaction sequence may be defined as an instance of file\n         transfer, initiated by a request and ended by a terminate [13].\n         The exact sequence in which transactions occur depends on the\n         type of request.  A transaction sequence may be aborted anytime\n         by either host, as explained in Section 3C.\n\n   3B.   Examples\n\n         The identify request doesn't require a response or terminate\n         and constitutes a transaction sequence by itself.\n\n\n\n\n\nBhushan                                                         [Page 9]\n\f\nRFC 114                 A FILE TRANSFER PROTOCOL           16 April 1971\n\n\n         Rename, delete, addname, deletename and open requests involve\n         no data transfer but require terminates.  The user sends the\n         request and the server sends a successful or an unsuccessful\n         terminate depending on whether or not he is successful in\n         complying with the request.\n\n         Retrieve and Lookup requests involve data transfer from the\n         server to the user.  The user sends the request, the server\n         responds with a rs, and transfers the data specified by the\n         request.  Upon completion of the data transfer, the server\n         terminates the transaction sequence with a successful terminate\n         if all goes well, or with an unsuccessful terminate is errors\n         were detected.\n\n         Store and Append requests involve data transfer from the user\n         to server.  The user sends the request and the server responds\n         with a rr.  The user then transfers the data.  Upon receiving\n         the data, the server terminates the sequence.\n\n         Execute request involves transfer of inputs from user to\n         server, and transfer of outputs from server to user.  The user\n         sends the request to which the server responds with rr.  The\n         user then transfers the necessary inputs.  The server\n         \"executes\" the program or subroutine and transfers the outputs\n         to the user.  Upon completion of the output transfer, the\n         server terminates the transaction sequence.\n\n   3C.   Aborts\n\n         Either host may abort the transaction sequence at any time by\n         sending an unsuccessful terminate, or by closing the connection\n         (NCP to transmit a CLS for the connection).  The CLS is a more\n         drastic type of abort and shall be used when there is a\n         catastrophic failure or when an abort is desired in the middle\n         of a long file transfer.  The abort indicates to the receiving\n         host that the other host wishes to terminate the transaction\n         sequence and is now in the initial state.  When CLS is used to\n         abort, the using host will reopen the connection.\n\n4.    Data Types\n\n   4A.   The data type code together with the extension code defines the\n         manner in which the data field is to be parsed and interpreted\n         [14].  Although a large number of data types are defined,\n         specific implementations may handle only a limited subset of\n         data types.  It is recommended that all host sites accept the\n\n\n\n\n\nBhushan                                                        [Page 10]\n\f\nRFC 114                 A FILE TRANSFER PROTOCOL           16 April 1971\n\n\n         \"network ASCII\" and \"binary\" data types.  Host computers which\n         do not \"recognize\" particular data types may abort the\n         transaction sequence and return a data type error status code.\n\n   4B.   The following data types are tentatively defined.  The code in\n         the type and extension field is represented by its ASCII\n         equivalent with 8th bit as zero.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBhushan                                                        [Page 11]\n\f\nRFC 114                 A FILE TRANSFER PROTOCOL           16 April 1971\n\n\n        Data Type                                    Code\n                                     Byte Size       Type     Extension\nASCII character, bit8=0 (network)       8             A          NUL\n\nASCII characters, bit8=1                8             A          1\n\nASCII characters, bit8=even parity      8             A          E\n\nASCII characters, bit8=odd parity       8             A          O\n\nASCII characters, 8th bit info.         8             A          8\n\nASCII characters, 7 bits                7             A          7\n\nASCII characters, in 9-bit field        9             A          9\nASCII formatted files (with SOH,\n        STX, ETX, etc.)                 8             A          F\nDEC-packed ASCII (5 7-bit char.,\n        36th bit 1 or 0)                36            A          D\nEBCDIC characters                       8             E         NUL\nSIXBIT characters                       6             S         NUL\nBinary data                             1             B         NUL\nBinary bytes (size is binary ext.)      1-255         B        (any)\nDecimal numbers, net ASCII              8             D          A\nDecimal numbers, EBCDIC                 8             D          E\nDecimal numbers, sixbit                 6             D          S\nDecimal numbers, BCD (binary coded)     4             D          B\nOctal numbers, net. ASCII               8             O          A\nOctal numbers, EBCDIC                   8             O          E\nOctal numbers, SIXBIT                   6             O          S\nHexadecimal numbers, net. ASCII         8             H          A\nHexadecimal numbers, EBCDIC             8             H          E\nHexadecimal numbers, SIXBIT             6             H          S\nUnsigned integers, binary (ext.\n        field is byte size)             1-225         U        (any)\nSign magnitude integers (field is\n        binary size)                    1-255         I        (any)\n2's complement integers (ext.\n        field is byte size)             1-255         2        (any)\n1's complement integers (ext.\n        field is byte size)             1-255         1        (any)\nFloating point (IBM360)                 32            F          I\nFloating point (PDP-10)                 36            F          D\nStatus codes                            8             S         NUL\n\n\n\n\n\n\n\nBhushan                                                        [Page 12]\n\f\nRFC 114                 A FILE TRANSFER PROTOCOL           16 April 1971\n\n\n   4C.   The data type information is intended to be interpretive.  If a\n         host accepts a data type, it can interpret it to a form suited\n         to its internal representation of characters or numbers [15].\n         Specifically when no conversion is to be performed, the data\n         type used will be binary.  The implicit or explicit byte size\n         is useful as it facilitates storing of data.  For example, if a\n         PDP-10 receives data types A, A1, AE, or A7, it can store the\n         ASCII characters five to a word (DEC-packed ASCII).  If the\n         datatype is A8 or A9, it would store the characters four to a\n         word.  Sixbit characters would be stored six to a word.  If\n         conversion routines are available on a system, the use of\n         system program could convert the data from one form to another\n         (such as EBCDIC to ASCII, IBM floating point to DEC floating\n         point, Decimal ASCII to integers, etc.).\n\n5. Initial Connection, CLS, and Identifying Users\n\n   5A.   There will be a prearranged socket number [16] for the\n         cooperating process on the serving host.  The connection\n         establishment will be in accordance with the initial connection\n         protocol of RFC 66 as modified by RFC 80.  The NCP dialog would\n         be:\n\n              user to server:    RTS\u003cus\u003e\u003c3\u003e\u003cp\u003e\n\n         if accepted, server to user:    STR\u003c3\u003e\u003cus\u003e\u003cCLS\u003e\u003c3\u003e\u003cus\u003e\n              server to user on link p:  \u003css\u003e\n              server to user:    STR\u003css+1\u003e\u003cus\u003eRTS\u003css\u003e\u003cus+1\u003e\u003cq\u003e\n              user to server:    STR\u003cus\u003e\u003css+1\u003eRTS\u003cus+1\u003e\u003css\u003e\u003cr\u003e\n\n         This sets up a full-duplex connection between user and server\n         processes, with server receiving through local socket ss from\n         remote socket us+1 via link q, and sending to remote socket us\n         through local socket ss+1 via link r.\n\n   5B.   The connection will be broken by trading a CLS between the\n         NCP'S for each of the two connections.  Normally the user will\n         initiate the CLS.\n\n         CLS may also be used by either the user or the server to abort\n         a data transmission in the middle.  If a CLS is received in the\n         middle of a transaction sequence, the whole transaction\n         sequence will be aborted.  The using host will then reopen the\n         connection.\n\n   5C.   The first transaction from the user to server will be the\n         identify transaction.  The users will be identified by the\n         pathname in data field of the transaction which should be a\n\n\n\nBhushan                                                        [Page 13]\n\f\nRFC 114                 A FILE TRANSFER PROTOCOL           16 April 1971\n\n\n         form acceptable to the server.  The server is at liberty to\n         truncate pathnames for its own use.  Since the identify\n         transaction does not require a response or terminate, the user\n         can proceed directly with other requests.\n\nIV.  Extensions to Protocol\n\n   The protocol specified above has been designed to be extendable.  The\n   obvious extensions would be in the area of transaction types (new\n   types of requests), error return status words, and data types.  Some\n   of the non-obvious extensions, that I can visualize are provisions of\n   access control mechanisms, developing a uniform way of specifying\n   file attributes in headings of files, increasing the scope of the\n   execute command to include subroutine mediation, and the provision of\n   transaction sequence identification numbers to facilitate handling of\n   multiple requests over the same connection pair.\n\n   Users of protected file systems should be able to have a reasonable\n   degree of confidence in the ability of the serving process to\n   identify remote users correctly.  In the absence of such confidence,\n   some users would not be willing to give access to the serving process\n   (especially write access).  Inclusion of access control mechanisms\n   such as passwords, is likely to enhance the indirect use of network\n   by users who are concerned about privacy and security.  A simple\n   extension to the protocol would be to have the serving host sent a\n   transaction type \"password?\" after it receives user name.  Upon\n   receipt of \"password?\" the using host will transmit the password,\n   which when successfully acknowledged, would indicate to the user that\n   requests may proceed.\n\n   There are a number of file attributes which properly belong in the\n   heading of a file rather than the file itself or the data type in\n   descriptors of transactions.  Such attributes include access control\n   lists, date file was last modified, information about the nature of\n   file, and description of its contents in a data description or data\n   reconfiguration language.  Some uniformity in the way file attributes\n   are specified would be useful.  Until then, the interpretation of the\n   heading would be up to the user or the using process.  For example,\n   the heading of files which are input to a data reconfiguration (form)\n   machine may be the desired transformations expressed in the\n   reconfiguration language.\n\n   The \"execute\" command which achieves the execution of programs\n   resident in remote hosts is a vital part of indirect use of remote\n   hosts.  The present scope of the execute command, as outlined in the\n   specifications, is somewhat limited.  It assumes that the user or\n\n\n\n\n\nBhushan                                                        [Page 14]\n\f\nRFC 114                 A FILE TRANSFER PROTOCOL           16 April 1971\n\n\n   using process is aware of the manner in which the arguments and\n   results should be exchanged.  One could broaden the scope of the\n   execute command by introducing a program mediation protocol [17].\n\n   The present specification of the protocol does not allow the\n   simultaneous transfer and processing of multiple requests over the\n   same pair of connections.  If such a capability is desired, there is\n   an easy way to implement it which only involves a minor change.  A\n   transaction sequence identification number (TSid) could replace a NUL\n   field in the descriptor of transactions.  The TSid would facilitate\n   the coordination of transactions, related to a particular transaction\n   sequence.  The 256 code combinations permitted by the TSid would be\n   used in a round-robin manner (I can't see more than 256 outstanding\n   requests between two user-processes in any practical implementation).\n   An alternate way of simultaneous processing of requests is to open\n   new pairs of connection.  I am not sure as to how useful simultaneous\n   processing of requests is, and which of the two is a more reasonable\n   approach.\n\nV. Conclusions\n\n   I tried to present a user-level protocol that will permit users and\n   using programs to make indirect use of remote host computers.  The\n   protocol facilitates not only file system operations but also program\n   execution in remote hosts.  This is achieved by defining requests\n   which are handled by cooperating processes.  The transaction sequence\n   orientation provides greater assurance and would facilitate error\n   control.  The notion of data types is introduced to facilitate the\n   interpretation, reconfiguration and storage of simple and limited\n   forms of data at individual host sites.  The protocol is readily\n   extendible.\n\nEndnotes\n\n   [1] The interim version of the protocol, limited to transfer of ASCII\n   files, was developed by Chander Ramchandani and Howard Brodie of\n   Project MAC.  The ideas of transactions, descriptors, error recovery,\n   aborts, file headings and attributes, execution of programs, and use\n   of data types, pathnames, and default mechanisms are new here.\n   Howard Brodie and Neal Ryan have coded the interim protocol in the\n   PDP-10 and the 645, respectively.\n\n   [2] The network system survey was conducted last fall by Howard\n   Brodie of Project MAC, primarily by telephone.\n\n   [3] PDP-10 Reference Handbook, page 306.\n\n\n\n\n\nBhushan                                                        [Page 15]\n\f\nRFC 114                 A FILE TRANSFER PROTOCOL           16 April 1971\n\n\n   [4] We considered using two full-duplex links, one for control\n   information, the other for data.  The use of a separate control link\n   between the cooperating processes would simplify aborts, error\n   recoveries and synchronization.  The synchronization function may\n   alternatively be performed by closing the connection (in the middle\n   of a transaction sequence) and reopening it with an abort message.\n   (The use of INR and INS transmitted via the NCP control link has\n   problems as mentioned by Kalin in RFC 103.)  We prefer the latter\n   approach.\n\n   [5] Identifying users through use of socket numbers is not practical,\n   as unique user identification numbers have not been implemented, and\n   file systems identify users by name, not number.\n\n   [6] This subject is considered in detail by Bob Metcalfe in a\n   forthcoming paper.\n\n   [7] Filler bits may be necessary as particular implementations of\n   NCP's may not allow the free communication of bits.  Instead the\n   NCP's may only accept bytes, as suggested in RFC 102.  The filler\n   count is needed to determine the boundary between transactions.\n\n   [8] 72-bits in descriptor field are convenient as 72 is the least\n   common multiple of 6, 8, 9, 18, 24 and 30, the commonly encountered\n   byte sizes on the ARPA network host computers.\n\n   [9] The execute request is intended to facilitate the indirect\n   execution of programs and subroutines.  However, this request in its\n   present form may have only limited use.  A subroutine or program\n   mediation protocol would be required for broader use of the execute\n   feature.  Metcalfe considers this problem in a forthcoming paper.\n\n   [10] The pathname idea used in Multics is similar to that of labels\n   in RFC 76 by Bouknight, Madden and Grossman.\n\n   [11] We, however, urge the use of standard network ASCII.\n\n   [12] The exact manner in which the input and output are transmitted\n   would depend on specific mediation conventions.  Names of input and\n   output files may be transmitted instead of data itself.\n\n   [13] The transactions (including terminate) are not \"echoed\", as\n   echoing does not solve any \"hung\" conditions.  Instead time-out\n   mechanisms are recommended for avoiding hang-ups.\n\n   [14] The data type mechanism suggested here does not replace data\n   reconfiguration service suggested by Harslem and Heafner in RFC 83\n   and NIC5772.  In fact, it complements the reconfiguration.  For\n\n\n\nBhushan                                                        [Page 16]\n\f\nRFC 114                 A FILE TRANSFER PROTOCOL           16 April 1971\n\n\n   example, data reconfiguration language can be expressed in EBCDIC,\n   Network ASCII or any other code that form machine may \"recognize\".\n   Subsequent data may be transmitted binary, and the form machine would\n   reconfigure it to the required form.  I have included in data types,\n   a large number suggested by Harslem and Heafner, as I do not wish to\n   preclude interpretation, reconfiguration and storage of simple forms\n   of data at individual host sites.\n\n   [15] The internal character representation in the hosts may be\n   different even in ASCII.  For example PDP-10 stores 7-bit characters,\n   five per word with 36th bit as don't care, while Multics stores them\n   four per word, right-justified in 9-bit fields.\n\n   [16] It seems that socket 1 has been assigned to logger and socket 5\n   to NETRJS.  Socket 3 seems a reasonable choice for the file transfer\n   process.\n\n   [17] The term program mediation was suggested by Bob Metcalfe who is\n   intending to write a paper on this subject.\n\n\n         [ This RFC was put into machine readable form for entry ]\n             [ into the online RFC archives by Ryan Kato 6/01]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBhushan                                                        [Page 17]\n\f\n"
}