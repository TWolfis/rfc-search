{
  "series": "Request for Comments",
  "number": "133",
  "howpublished": "RFC 133",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0133",
  "url": "https://www.rfc-editor.org/info/rfc133",
  "title": "File Transfer and Error Recovery",
  "pagetotal": "4",
  "year": "1971",
  "month": "apr",
  "day": "1",
  "body": "\n\n\n\n\n\nNetwork Working Group                                      R. L. Sunberg\nRequest for Comments: 133                             Harvard University\nNIC 6710                                                   27 April 1971\n[Categories C.4, C.5, C.6, D.4, D.7, D.7]\n\n\n                    FILE TRANSFER AND ERROR RECOVERY\n\n\n1   FILE TRANSFER PROTOCOL\n\n1A   Handshaking\n\n   I think that Mr Bhushan(RFC #114, NIC 5823) is not strict enough in\n   his concept of a transaction sequence.  Every transaction should\n   prompt a response from its recipient (recall Kalin's crates --\n   RFC #60, NIC 4762).  Control should pass back and forth until the\n   server terminates.  The server _always_ gets the last word (more on\n   error recovery later).\n\n   Some sample interchanges are given.\n\n       User                Server       Comments\n\n       \u003c...\u003e       ==\u003e                  Establish a connection\n                   \u003c==     \u003c...\u003e\n       \u003cI\u003e\u003c...\u003e    ==\u003e                  Identify self\n                   \u003c==     \u003c+\u003e          Ok, ready\n\n       \u003cR\u003e\u003c...\u003e    ==\u003e                  Retrieval request\n                   \u003c==     \u003crs\u003e         I've got your file\n       \u003crr\u003e        ==\u003e                  Send it\n                   \u003c==     \u003c,\u003e\u003c...\u003e     Here's the first part\n       \u003crr\u003e        ==\u003e                  Got it\n                   \u003c==     \u003c+\u003e          All done\n\n       \u003cS\u003e\u003c...\u003e    ==\u003e                  Store request\n                   \u003c==     \u003crr\u003e         Ok, go ahead\n       \u003c#\u003e\u003c...\u003e    ==\u003e                  Here's some protection stuff\n                   \u003c==     \u003crr\u003e         Ok\n       \u003c*\u003e\u003c...\u003e    ==\u003e                  Here's the file\n                   \u003c==     \u003c+\u003e          Got it.  All done.\n\n   See section 2B, below, for examples of error recovery.\n\n\n\n\n\n\n\nSunberg                                                         [Page 1]\n\f\nRFC 133             File Transfer and Error Recovery          April 1971\n\n\n1B  Extensions to the file transfer protocol\n\n   The file transfer protocol needs a mechanism for accessing individual\n   records of a file.  This will be particularly useful when very large\n   data bases appear on the network.  The following definitions should\n   be added to the protocol:\n\n   The store(S) and retrieve(R) requests have the data field format\n   \u003ckey\u003e, where \u003ckey\u003e has the syntax:\n\n    \u003ckey\u003e::=\u003cdevicename\u003eRS\u003cfilename\u003eUS\u003ckeyname\u003e | \u003cfilename\u003eUS\u003ckeyname\u003e.\n                           --          --                      --\n\n   The \u003cpathname\u003e syntax is changed to:\n\n       \u003cpathname\u003e::=\u003cdevicename\u003e | \u003cfilename\u003e | \u003cpathname\u003eRS\u003cfilename\u003e.\n                                                          --\n   If a retrieve(R) request is given with a data field with \u003ckey\u003e\n   syntax rather than \u003cpathname\u003e syntax, then the returned data will\n   consist of the record following the matching \u003ckey\u003e.  If a store(S)\n   request is given with a data field of \u003ckey\u003e syntax, then the\n   supplied data will replace the record following the matching\n   \u003ckeyname\u003e.  If the keyname does not exist, the record will be\n   appended to the named file.  The individual installation must\n   provide the linkage between the \u003ckeyname\u003e and the record it\n   references.\n\n   In addition, the lookup(L) request will provide a list of keynames\n   into a file (or the name of a file which contains the keynames).\n\n   Transaction code F (request File directory) requests a listing of\n   available files.  The data field of the F transaction is of the\n   form:  \u003cpathname\u003eGS\u003cpathname\u003eGS...  All files in the server system\n                    --          --\n   which match one or more of the given \u003cpathname\u003e specifiers are\n   listed in a return file.  The format of the data fields of this\n   file is:  \u003cpathname\u003eGS\u003cpathname\u003eGS...  If a \u003cpathname\u003e field in\n                       --          --\n   the request transaction does not include a \u003cname\u003e field, the\n   default is all files on the given device.  Some examples are given:\n\n       \u003cF\u003e\u003cDC1 DSK[62,50]] GS JOE\u003e\n           ---             --\n\n\n\n\n\n\n\n\nSunberg                                                         [Page 2]\n\f\nRFC 133             File Transfer and Error Recovery          April 1971\n\n\n   This example requests a list of all files on the disk specified by\n   [62,50] plus all files named JOE.  The response could contain in\n   the data field:\n\n     \u003cDC1 DSK[62,50] RS ALPHA RS BETA RS JOE GS DC1 DSK[10,50] RS JOE\u003e\n      ---            --       --      --     -- ---            --\n\n   This message states that in the [62,50] area of the disk there are\n   files ALPHA, BETA, and JOE, and that JOE is also a file in the\n   [10,50] area of the disk.\n\n2   ERROR RECOVERY\n\n2A   Error recovery procedures have been noticeably lacking to date.\n   The usual approach has been to close the connection and start from\n   scratch.  Mr Bhushan proposes a third level abort but doesn't\n   really detail the implementation.  I propose a multilevel error\n   recovery procedure as follows.\n\n2B   If an error occurs which does not cause a loss of third level\n   transaction boundaries and only affects one side of a duplex\n   connection, a third level recovery is possible via a transaction\n   sequence abort.  An example is given:\n\n       User                Server          Comments\n\n       \u003cR\u003e\u003c...\u003e    ==\u003e                     Send me this file\n                   \u003c==     \u003crs\u003e            Ok, I've got it\n       \u003crr\u003e        ==\u003e                     Ready\n                   \u003c==     \u003c*\u003e\u003c...error\u003e   Here it is (with an error)\n       \u003c-\u003e\u003cD\u003e      ==\u003e                     No.  (data) error\n                   \u003c==     \u003c-\u003e\u003cD\u003e          Sorry, forget it\n       \u003cR\u003e\u003c...\u003e    ==\u003e                     Send the file (again)\n                   |\u003c==    \u003crs\u003e            Ready (doesn't get there)\n                   ...                     (waiting)\n       \u003c-\u003e\u003c0\u003e      ==\u003e                     Error, timeout\n                   \u003c==     \u003c-\u003e\u003c0\u003e          Sorry, forget it\n       \u003cR\u003e\u003c...\u003e    ==\u003e                     Send the file (third time)\n                   \u003c==     \u003crs\u003e            Got it\n       \u003crr\u003e        ==\u003e                     Ready\n                   \u003c==     \u003c*\u003e\u003c...\u003e        There it is\n       \u003crr\u003e        ==\u003e                     Got it\n                   \u003c==     \u003c+\u003e             Done (finally\u003e\n\n   Note that the server always gets the last word in error situations\n   as well as normal transmission.\n\n\n\n\n\nSunberg                                                         [Page 3]\n\f\nRFC 133             File Transfer and Error Recovery          April 1971\n\n\n2C   Although the above examples are given in terms of Bhushan's\n   transaction codes, this form of error recovery is implementable in\n   any protocol which uses flagged blocking and duplex connections.\n\n2D   If errors cannot be recovered as above, then some means must be\n   available to clear the link completely and resynchronize.  I\n   suggest that an 8-bit argument be appended to the interrupt-on-link\n   NCP message (INR, INS).  The receiver would send \u003cINR\u003e\u003cerror\u003e to\n   indicate that the block boundaries were lost and all incoming data\n   is being discarded.  The sender, upon receiving the INR, would\n   flush all queued output and wait for the link to clear.  The NCP\n   would then send a \u003cINS\u003e\u003cnewsync\u003e message and, when it was received\n   (RFNM returned), a negative termination would be sent on the link.\n   The receiver begins accepting data again when the INS is received.\n   This assumes that any process can flush untransmitted data and\n   detect a clear link.  Note that this method is useable on any\n   simplex connection.\n\n2E  If all else fails, one can resort to closing the faulty socket.\n\n3   NCP VERSION NUMBERS\n\n3A  I suggest that the NCP be given a version number and the next\n   version include two new message types: \u003cWRU\u003e ('Who aRe yoU?')\n   requests a version number from the receiving host and \u003cIAM\u003e\u003cversion\u003e\n   ('I AM') supplies that number.\n\n3B  The messages would probably be initially used in a 'can I talk to\n   you?' sense or not at all.  Eventually, it would take on a 'what\n   can you do?' meaning.  Accordingly, the \u003cversion\u003e field should be\n   large (32 bits?) for expansion.\n\n\n\n         [ This RFC was put into machine readable form for entry ]\n           [ into the online RFC archives by Jose Tamayo 4/97 ]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSunberg                                                         [Page 4]\n\f\n"
}