{
  "series": "Request for Comments",
  "number": "492",
  "howpublished": "RFC 492",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0492",
  "url": "https://www.rfc-editor.org/info/rfc492",
  "title": "Response to RFC 467",
  "pagetotal": "7",
  "year": "1973",
  "month": "apr",
  "day": "1",
  "body": "\n\n\n\n\n\nNetwork Working Group                                           E. Meyer\nRequest for Comments: 492                                    MIT-Multics\nNIC: 15357                                                 18 April 1973\n                          RESPONSE TO RFC 467\n\n\n   Jerry Burchfiel and Ray Tomlinson of Bolt, Beranek, and Newman, Inc,\n   have issued a Network Request for Comments (#467) which proposes a\n   solution to two problems which have been annoying to Network users.\n   This document will briefly describe the problems and proposed\n   solutions, and offer comments and alternative suggestions.\n\nBACKGROUND\n\n   To establish a data connection between two hosts through the network,\n   the Host-Host protocol requires that one host send a Request for\n   Connection and that the second Host reply affirmatively.  If the\n   desired socket(\"port\") at the target host is already in use, the\n   target host replies negatively.  Once a connection is established,\n   data transmission may proceed, controlled by data allocation messages\n   dispatched by the host at the read end of the connection.  The host\n   on the write side is constrained by protocol to send only as much\n   data as has been permitted by the read side.  If it exhausts the\n   allocation it must wait until a new data allocation control message\n   is received.  Then it can send more.\n\n   One of the problems arises from the fact that messages apparently are\n   lost somewhere in the transmission path with a low but regular\n   frequency.  If an allocate control message concerning an open\n   connection is lost, a situation can occur in which data transmission\n   over the connection ceases permanently.  This can happen because the\n   host at the send side believes it has exhausted its allocation, and\n   sits holding back data to end because it is waiting for a new data\n   allocation message to come from the read side.  However, the read\n   side has actually sent out the allocation, but it was lost.  It\n   thinks that the send side may proceed and sits waiting for data to\n   come in over the connection.  This is known as the \"lost allocate\"\n   phenomenon.  However, similar symptoms can occur if a data message is\n   lost and the send side exhausts its allocation before a new\n   allocation is given by the read side.  The send side waits for a new\n   allocation, but the read side has not received one of the data\n   messages and believes there is still some allocation left.  In either\n   case, the result is a permanently blocked connection.  This appears\n   to happen with enough regularity to be annoying to users who connect\n   typewriters to foreign hosts through the Network.  When it happens,\n   the only current solution is to disconnect and to establish a new\n   connection.\n\n\n\n\nMeyer                                                           [Page 1]\n\f\nRFC 492                   RESPONSE TO RFC 467              18 April 1973\n\n\n   The solution to this problem which RFC 467 proposes is to establish a\n   pair of allocation-resetting control messages, one for use by the\n   send side (RCS) and the other for the read side (RCR).  Whenever it\n   wishes, either side may initiate the allocation-resetting sequence by\n   setting its own allocation counter to zero and dispatching an RCS or\n   RCR control message to the other side.  The host receiving it will\n   set its own allocation counter for that connection to zero and send\n   an RCR or RCS in reply.  Now the allocations for both sides are in\n   synchronization (they are zero), and data transmission can begin\n   again when a new allocation is sent by the receive side.  This\n   procedure is intended to be initiated whenever either side thinks the\n   connection has been quiescent for a suspiciously long time.  The\n   actual specification of this control message pair in RFC 467 is more\n   complex in that the pipeline between the two sides must be empty of\n   data messages before the send side may dispatch an RCS control\n   message.\n\n   The second problem arises when the host at one side of an open\n   connection crashes and purges its tables when it comes back up, while\n   the host at the other end of the connection does not notice that\n   anything has happened. (A similar situation occurs when the Network\n   path temporarily fails between the two hosts, but only one host\n   notices the failure and closes the connection.) If the host which\n   crashed attempts to re-establish the connection, the host at the\n   other end refuses to do so because the socket to which the connection\n   request is targeted is seemingly already involved in an open\n   connection.  Given the idiosyncrasies of the terminal support\n   software of some systems, users at some consoles may be unable to\n   reconnect to the distant system they were connected with when the\n   local system supporting his terminal crashed.  This can continue\n   indefinitely until the system which believes the original connections\n   to be still open resets its internal state.  This is call the \"half-\n   closed\" phenomenon, and a solution is proposed in RFC 467.  The basic\n   principle of the RFC 467 proposal is that the side which has the open\n   connection is able to detect an inconsistency whenever either side\n   performs communication regarding this connection.  When it does, it\n   is supposed to silently (without regard to normal protocol) close the\n   connection and be ready to handle connection requests to the\n   previously connected port.\n\n   There are two types of interactions in which \"half-closed\"\n   inconsistency is uncovered.  The first case occurs when the connected\n   side sends a message over a write connection.  The side which has\n   lost the connection receives this as a data message which does not\n   correspond to an open connection and replies with an Error Report\n   control message.  When the connected side receives it, it realizes\n   that the connection actually no longer exists and deletes it from its\n   own tables.  The second case occurs when the host which has lost the\n\n\n\nMeyer                                                           [Page 2]\n\f\nRFC 492                   RESPONSE TO RFC 467              18 April 1973\n\n\n   connection sends a connection request to the other host specifying\n   the same sockets as were involved in the previous connection.  The\n   host receiving this request recognizes the inconsistency, because not\n   only is the local socket already connected, it is connected to the\n   same foreign socket as specified in the connection request.  It\n   internally deletes its record of the connection, making the local\n   socket free, and responds to the connection request normally.\n\nCOMMENTS AND ALTERNATIVE PROPOSALS\n\n   The Project MAC Computer Systems Research Division opposes both\n   protocol change proposals in this RFC.  We have moderate opposition\n   to the proposal to handle half-closed connections because it fails to\n   consider all aspects of the problem and it further complicates the\n   protocol, but very strong opposition to the proposal for allocation\n   resynchronization because it attacks a symptom, not the disease, and\n   furthermore tends to mask diagnosis of a potentially very serious\n   network problem.\n\n   RFC 467 proposes the addition of two control messages, Reset\n   Connection by Sender (RCS) and Reset Connection by Receiver (RCR)\n   whose sole purpose is to resynchronize the allocation counters at\n   both ends of a connection.  In this way the \"lost allocate\"\n   phenomenon, in which allocate (ALL) control messages somehow are lost\n   in transmission so that the sending side is unable to continue\n   transmitting data is solved.  If it were truly a \"lost allocate\"\n   problem, this would be viable solution.  However, I feel that this is\n   really a \"lost message\" problem, in which messages of all kinds are\n   being lost in transmission, which is much more serious.  ALL messages\n   may be very frequent in communications with some hosts and these may\n   be the ones most often lost, but if messages are actually lost in the\n   network, it may also be data messages that are being lost, which\n   would provide similar symptoms.  A lost message in a Telnet\n   connection can be detected and overcome by the human user, but an\n   undetected lost message from the middle of a transmitted file can\n   have disastrous consequences, especially because the invalid file, if\n   ever detected, can perhaps not be corrected.  Because this \"solution\"\n   tends to paper over the immediate problem and to propagate it to a\n   point far removed in both space and time at which it appears as an\n   incomprehensible disaster, it should be strongly opposed.\n\n   The real problem appears to be the random undetected loss of messages\n   somewhere in the transmission path.  A true solution to this problem\n   is either a) to eliminate the cause of undetected loss of messages,\n   or b) to move to a new protocol which is designed to cope with an\n   unreliable physical transmission path.  Either of these solutions is\n\n\n\n\n\nMeyer                                                           [Page 3]\n\f\nRFC 492                   RESPONSE TO RFC 467              18 April 1973\n\n\n   some distance away.  A proposed interim solution which modifies the\n   existing GVB and RET commands and which has the additional feature of\n   simplifying them somewhat is outlined below.\n\n   A receiving host may at an arbitrary time issue a Give-Back\n   allocation (GVB) control message for a connection.\n\n             8       8        8        8\n         +-------+-------+--------+--------+\n         |  GVB  | link  | f =255 | f =255 |\n         |       |       |  m     |  b     |\n         +-------+-------+--------+--------+\n\n   The format of this GVB message is the same as that currently defined,\n   except that the fraction fields f(m) and f(b) are required to all 1s.\n   This is designed to provide a measure of upward compatibility.  A\n   host operating under the modified protocol will ignore the fraction\n   fields, but under the current protocol this message means return\n   everything.  A sending host which receives a GVB control message\n   immediately ceases transmission on the specified link.  When the RFNM\n   from the last message transmitted is received (indicating an empty\n   pipeline), the sending host issues a Return Allocation (RET) control\n   message, returning the remaining allocation.\n\n              8      8        16         32\n          +------+------+-----------+-----------+\n          | RET  | link | msg space | bit space |\n          +------+------+-----------+-----------+\n\n   The modified RET command has the same format as that currently\n   defined.  The two differences are that it can not be sent until data\n   transmission ceases and the last RFNM is received, and that it must\n   return all remaining allocation for the send link (i.e., the\n   allocation counters are set to zero).\n\n   When the host on the read side of the connection receives the RET\n   message, the allocation counters at the send side are zero and the\n   pipeline is empty.  Therefore, if no error has occurred during the\n   connection, the allocation returned in the RET message should be the\n   same as the allocation in the counters of the read side of the\n   connection.  If so, the read side can proceed to send a new\n   allocation secure in the knowledge that no message has been lost.  If\n   the two sets of values do not agree, some error in the transmitted\n   data may have occurred.  What to do in that case is a local host\n   option.  Some hosts may choose to close the connection, while others\n   may choose to resume transmission by sending a new allocation to the\n\n\n\n\n\nMeyer                                                           [Page 4]\n\f\nRFC 492                   RESPONSE TO RFC 467              18 April 1973\n\n\n   sending side.  I feel that as a minimum a host should send a message\n   indicating the error both to the user and to some human being at the\n   host responsible for monitoring network performance.\n\n   This modified control message pair is capable of both its originally\n   intended function,and of detecting errors and resynchronizing\n   allocations (if desired) when initiated by the receiving side.  I\n   feel that the inability of this scheme to initiate allocation\n   checking from either side is only a minor disadvantage which is more\n   than compensated for by its positive features: this scheme gives\n   positive indication that an error has occurred (the proposed RCS/RCR\n   method conceals errors), and this minor change to the protocol may\n   mean a correspondingly minor change to NCP's.\n\n   I have negative feelings regarding the solution to the \"half-closed\"\n   problem proposed in RFC 467.  To put additional burden on the RTS and\n   STR commands not only unduly complicates the protocol, but in some\n   sense can make operation less fail-safe and problems more obscure.\n   My main objection concerns the action to be taken when control\n   messages are received which conflict with the current state of the\n   receiving NCP.  This proposal suggests that an NCP receiving an STR\n   or RTS for a socket it believes to be connected assume something\n   about the state of the foreign NCP (that the foreign NCP has closed\n   the connection) and automatically change its own state to agree with\n   the assumed state at the other end (close the connection at its end).\n   This may work fine if the assumption is correct and the\n   implementations are free from bugs.  However, the following\n   situations could cause problems that are perhaps hard to diagnose: 1)\n   the foreign NCP has a bug which causes it to send an RTS or STR for a\n   connected socket, 2) the foreign NCP chooses to interpret the queuing\n   option of the current protocol as permitting RFC's to be sent for\n   already connected sockets, or 3) the local NCP has a bug which\n   erroneously causes it to regard RFC's coming from a different host or\n   from the particular foreign host but concerning a different foreign\n   socket as pertaining to the open connection attached to the target\n   socket.\n\n   A second objection is that this proposal does not cover all\n   possibilities.  Two likely possibilities are: another socket (from\n   any host) attempts to connect to the socket involved in the dead\n   connection.  Second, the host that lost a connection attached to one\n   of its read sockets makes another connection with different sockets,\n   but uses the same link number that implemented the previous\n   connection.  The second case can be handled by additional\n   complications to the protocol.  However, the first case is\n   symptomatically identical to the situation in which an RFC is issued\n   for a genuinely already-connected socket.  It can not be handled\n   using this approach.\n\n\n\nMeyer                                                           [Page 5]\n\f\nRFC 492                   RESPONSE TO RFC 467              18 April 1973\n\n\n   I believe that a more rigorous use of the existing Reset Host (RST)\n   control message would eliminate most of the causes of the \"half-\n   closed\" phenomenon; viz. one of the hosts involved in a connection\n   goes down without sending an RST when it comes back up; or the\n   network between the two hosts partitions, and only one host notes it.\n   If it were deemed necessary, a pair of Reset Link control commands to\n   reset an individual link could be added to the protocol to cope with\n   instance of the \"half-closed\" phenomenon due to other causes.\n\n   I'd like to set down here a number of principles which I think are at\n   least peripherally concerned with alleviating the \"half-closed\"\n   phenomenon.  None of these is explicitly stated in the current Host-\n   Host protocol document, but I believe that their enunciation would\n   tend to alleviate confusion caused by network and host failures.\n\n      1. A NCP which receives an Imp-to-Host message type 7 (Host Dead)\n         concerning a host should consider all connections or connection\n         attempts with that host as dead and should purge them from its\n         tables.\n\n      2. When after noting a foreign host as dead (by receiving a \"Host\n         Dead\" Imp-to-Host message), an NCP receives any message from\n         that host other than a Reset Host (RST) control message, it\n         should delete the message and respond with an RST.  It should\n         respond normally to a received RST.\n\n      3. Two hosts must exchange the RST - RRP reset control message\n         pair prior to any other form of communications.  An RST must\n         first be sent by an NCP wishing to start communications with a\n         foreign host if that host pair has not been previously reset\n         since the local NCP came up or it noted the foreign NCP as\n         down.  Note that this does not require an NCP to send resets to\n         all other hosts each time it comes up.\n\n      4. An NCP which receives an Imp-to-Host message type 9 (Incomplete\n         Transmission) concerning a write link implementing an open\n         connection, may at its option make several tries to retransmit\n         the last message until a RFNM is received or the NCP gives up.\n         However, unless the message is eventually successfully\n         transmitted to the foreign host the NCP must abort the\n         connection, sending out a CLS control message.  The successful\n         implementation of retransmission depends on the retransmitting\n         host to wait for a RFNM on a data link before sending a\n         subsequent message and on all hosts to be able to discard\n         messages which are not completely received.\n\n\n\n\n\n\nMeyer                                                           [Page 6]\n\f\nRFC 492                   RESPONSE TO RFC 467              18 April 1973\n\n\n      5. An NCP which receives a message from a foreign host that seems\n         inconsistent with its current state should take no action to\n         modify that state.  Rather it should send an ERR error control\n         message specifying the type of inconsistency and discard the\n         inconsistent message.  An NCP receiving an ERR message should\n         log it for human inspection and is then allowed to silently\n         modify its internal state or send out control messages in order\n         to remove the inconsistency. (This is an extension of the\n         proposal in RFC 467 that an NCP should delete a connection when\n         it receives an ERR message specifying that the link involved is\n         unknown.)\n\n\n        [This RFC was put into machine readable form for entry]\n   [into the online RFC archives by Helene Morin, Via Genie,12/1999]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMeyer                                                           [Page 7]\n\f\n"
}