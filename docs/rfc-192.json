{
  "series": "Request for Comments",
  "number": "192",
  "howpublished": "RFC 192",
  "publisher": "RFC Editor",
  "doi": "10.17487/RFC0192",
  "url": "https://www.rfc-editor.org/info/rfc192",
  "title": "Some factors which a Network Graphics Protocol must consider",
  "pagetotal": "19",
  "year": "1971",
  "month": "jul",
  "body": "\n\n\n\n\n\nNetwork Working Group                                          R. Watson\nRequest for Comments: 192                                        SRI-ARC\nNIC: 7137                                                   12 July 1971\n\n\n      Some Factors which a Network Graphics Protocol must Consider\n\n   After reading some of the RFC's on a network graphics protocol it\n   seems that many are not providing general enough mechanisms to handle\n   attention handling, picture structure, and other higher level\n   processes involved in interactive graphics.\n\n   Therefore for what it is worth I am sending out these rough\n   introductory notes which contain ideas that I think any network\n   graphics protocol must come to grips with.\n\n   The network graphics protocol should allow one to operate the most\n   sophisticated system with more general data structures and concepts\n   than those described in these notes and allow very simple systems to\n   function also.\n\nIntroduction\n\n   It is our contention that, if computer graphics is to be widely\n   useful, the graphics terminals must be just another type of terminal\n   on a timesharing system with minimal special privileges.  In these\n   brief notes we outline the basic features which we feel must be\n   available in a graphics support package to allow easy interactive\n   graphics application programming.\n\n   If one examines the types of tasks in industry, government and\n   universities which can avail themselves of timesharing support from\n   graphics consoles, one can estimate that the large majority can\n   effectively utilize quite simple terminals such as those employing\n   storage tubes.  I would estimate 75% of the required terminals to\n   fall in this class.  Another 15-20% of terminals may require higher\n   response and some simple realtime picture movement, thus requiring\n   simple refresh displays.  The remainder of terminals are needed for\n   high payout tasks requiring all the picture processing power one can\n   make available.  In this talk we are not considering support for this\n   latter class of applications.\n\nMAIN ASSUMPTIONS AND REQUIREMENTS FOR SYSTEM DESIGN\n\n   The main assumptions and requirements underlying the interactive\n   graphics are the following:\n\n\n\n\n\nWatson                                                          [Page 1]\n\f\nRFC 192          Some Factors which a Network Graphics      12 July 1971\n\n\n      1) The user of the graphics terminal should be just another\n         timesharing system user.\n\n      2) The graphics software support should interface to existing\n         timesharing programs.\n\n      3) The software support should allow technicians, engineers,\n         scientist, and business analysts as well as professional\n         programmers to easily create applications using a graphic\n         terminal.\n\n      4) The software support should easily allow use of new terminals\n         and types of terminals as they come on the market.\n\n      5) The software support should be expandable as experience\n         indicates new facilities are required.\n\n      6) The software support should be portable from one timesharing\n         service to another.\n\n      7) Some form of hardcopy should be available.\n\nMULTILEVEL MODULAR APPROACH TO SYSTEM DESIGN\n\n   If one wants to create as system which is easy to use by\n   inexperienced programmers and ultimately non-programmers, one needs\n   to provide powerful problem-oriented aids to program writing.  One\n   has to start with the primitive machine language used to command the\n   graphics system hardware and build upward.  The philosophy of design\n   chosen is the one becoming more common in the computer industry,\n   which is to design increasingly more powerful levels of programming\n   support, each of which interfaces to its surrounding levels and\n   builds on the lower levels.  It is important to try to design these\n   levels more or less at the same time so that the experience with each\n   will feed back on the designs of the others before they are frozen\n   and difficult to change.\n\n   One can recognize five basic levels:\n\n      1) The basic system level:\n\n         This level provides facilities for use of the terminal by the\n         assembly language programmers.\n\n\n\n\n\n\n\n\nWatson                                                          [Page 2]\n\f\nRFC 192          Some Factors which a Network Graphics      12 July 1971\n\n\n      2) The problem programming language level:\n\n         This level of support provides powerful facilities for\n         interactive graphics programming from the commonly used higher\n         level programming languages.\n\n      3) The picture editor or drawing system:\n\n         This level of support allows pictures to be drawn and linkage\n         to these pictures and application programs.\n\n      Data management support for interactive programming:\n\n         This level of support is to provide facilities to aid creation\n         and manipulation of data structures relating data associated\n         with the pictures and the application.\n\n      5) The application program level:\n\nA REVIEW OF TERMINAL HARDWARE CHARACTERISTICS OF CONCERN TO THE USERS\n\n   There are two basic kinds of general purpose cathode ray tube display\n   systems available on the present market.  Within each class there are\n   alternate forms and techniques of implementation which we do not\n   discuss here.  One type is called a \"refresh display\".  The other\n   type is called a \"storage tube display\".  The refresh display must\n   keep repainting the picture on the screen at rates of from 20-60\n   times per second.  Commands which instruct the system how to draw the\n   picture are stored in a memory.  The storage tube display on the\n   other hand, through its internal method of construction can maintain\n   on the face of the display a picture for practical purposes,\n   indefinitely once drawn.\n\nREFRESHED DISPLAYS\n\n   There are limits to how much information can be drawn on the face of\n   refreshed display before the time required to paint it forces the\n   refresh rate below a critical value and the picture appears to\n   flicker.  This quantity of information is a function of the type of\n   phosphor on the tube face, the speed of display system in drawing\n   lines and characters, and the ambient light level in the room.\n   Refresh display systems range in cost upwards from $10,000 to several\n   hundred thousand dollars.  Refresh displays, because the picture can\n   be changed every few milliseconds by simply altering its command list\n   (often called a display file or display buffer), allow the picture\n   parts to be moved on the face of the screen either under operator\n   control or computer control.  Objects on the screen can be\n   selectively erased without affecting other objects on the screen.\n\n\n\nWatson                                                          [Page 3]\n\f\nRFC 192          Some Factors which a Network Graphics      12 July 1971\n\n\n   These characteristics make refreshed displays suitable for a wide\n   range of applications.\n\nSTORAGE TUBE DISPLAYS\n\n   Storage tube based displays can display a large amount of information\n   without a flicker, and generally cost under $20,000.  Present systems\n   suffer from some limitations, however.  They cannot be selectively\n   erased.  If an object is to be moved or deleted from the screen, the\n   entire screen must be erased and then the new picture can be redrawn.\n   Because this type of display generally operates over a communication\n   line, the speed of the line may seriously restrict the amount of\n   interaction if much erasing and redrawing is required.  The graphics\n   software concepts to be described can be used with both a storage\n   tube and refreshed display, although some features are only\n   appropriate to the refreshed type of display.  The important point is\n   that new storage tube technologies insure that this class of terminal\n   will be with us a long time.\n\nINPUT DEVICES\n\n   It is necessary to allow a console user to communicate with the\n   graphics system.  This is done through a keyboard and through\n   specialized graphic input devices, the Light Pen, the Tablet, the SRI\n   \"Mouse\", and the \"Joy Stick\".  These latter devices enable a console\n   user to point to vectors and characters displayed on the CRT and to\n   input position information to the graphics system.\n\n   Comparison of the Graphics Input Devices -- Analog Comparitors\n\n      The Joy Stick, Mouse, and Tablet are similar in that they both\n      generate a two dimensional position address without the aid of the\n      display processor, but cannot be directly used to identify\n      displayed objects.  The light pen-display processor hardware\n      combination and its associated software, on the other hand, can\n      easily sense and identify displayed vectors and characters but\n      does not generate directly any position data.  A \"tracking cross\"\n      program is used to obtain the position data for the light pen.  To\n      obtain the pointing capability for the Joy Stick, Mouse, and\n      Tablet, we can use a pair of analog comparitors which generate\n      interrupts when the beam is drawn on the CRT lies within a\n      rectangular \"viewing window\" in much the same way that the light\n\n\n\n\n\n\n\n\n\nWatson                                                          [Page 4]\n\f\nRFC 192          Some Factors which a Network Graphics      12 July 1971\n\n\n      pen generates interrupts when a beam is drawn under its circular\n      viewing area.  These comparitors sense the x and y axis drive\n      voltages of the display analog bus.\n\n      A comparator will generate an output signal when the drive voltage\n      is between two limits which may be set using special display\n      processor commands.  When both comparitors generate a signal\n      simultaneously, the output voltages on the analog buss correspond\n      to a beam position within the rectangular viewing window.  The\n      position of viewing window is set based on the position of the\n      pen, Mouse, or Joy Stick.\n\n      We can also use software to simulate the effect of hardware\n      comparators.  Hardware comparators cannot be use with storage tube\n      displays and, therefore, a software simulation is required.  This\n      simulation is discussed later in these notes.\n\n      The light pen can be used only with a refreshed display.  The\n      other types of devices can be used with present storage tube\n      displays and refreshed displays.  They are used with storage tube\n      displays which have hardware which produces on the screen a dot,\n      cross or other cursor, indicating the x, y position of the device.\n      The reason one can move this cursor around it that the cursor is\n      created using special techniques to avoid its storing on the\n      screen.\n\nUSER SOFTWARE REQUIREMENTS\n\n   The user requirements on a timesharing system based interactive\n   graphics system are the following:\n\n      1) The user should have available a language for creating a\n         computer representation of the picture to be displayed.  This\n         language should allow more complex pictures to be built up from\n         simpler structures.\n\n      2) The computer representation of the picture must allow easy\n         identification of picture parts when pointed at or \"picked\" or\n         \"hit\" with graphical input devices such as light pen,\n         electronic pen-tablet, Joy Stick, SRI mouse, or other supplying\n         x, y information.\n\n      3) The computer representation of the picture must allow linking\n         of picture parts with data about these parts appropriate to the\n         application using the terminal.  There should be an appropriate\n         data management system for use with interactive application\n         programming.\n\n\n\n\nWatson                                                          [Page 5]\n\f\nRFC 192          Some Factors which a Network Graphics      12 July 1971\n\n\n      4) There must be some way of communicating events taking place at\n         the terminal in real-time, such as picking objects with the\n         light pen, with the application program running in the\n         timesharing system.\n\n      5) The user should be able to save and restore pictures from one\n         console session to the next.\n\n      6) If possible, the user should be able to use the display as a\n         stand-alone terminal or in conjunction with a teletype or other\n         typewriter terminal.\n\n      7) The user should be able to do some graphic programming by\n         drawing directly at the console.\n\n   The choice of an appropriate data structure for picture\n   representation simplifies the handling of requirements one to five.\n   It is this data structure that we consider now in more detail.\n\nPicture-Related Structures\n\n   If a picture displayed on the console had meaning only in the\n   physical position of its lines and characters, the system would be\n   little more effective than an easily erased piece of paper.  To\n   significantly enhance the capabilities of the system, we must be able\n   to express relations between displayed entities.  A line is much more\n   than just a line when it represents a boundary or a part of some more\n   complex unit.  Such units in turn may be related in a similar way to\n   higher level units.  Furthermore, we may wish to create picture\n   elements that may be used repeatedly so that a change in the one\n   master copy will be reflected in every use of that copy.\n\n   To illustrate the usefulness of this picture-subpicture relationship,\n   we shall consider the three houses of Figure 1.  While the two types\n   of houses differ in appearance, it is obvious that they have picture\n   elements that could be drawn by a designer of prefabricated houses\n   and that the designer wished to incorporate a new standard window\n   unit into all houses.  The use of conventional pencil and paper\n   techniques would require that he redraw or overlay each window on his\n   diagram to reflect the changed component.  If the window were,\n   instead, drawn by the graphics system within a common subroutine,\n   only that one master copy would have to be modified in order to\n   change the appearance of every reference to that kind of window on\n   the diagram.\n\n\n\n\n\n\n\nWatson                                                          [Page 6]\n\f\nRFC 192          Some Factors which a Network Graphics      12 July 1971\n\n\nNodes and Branches\n\n   To facilitate the discussion we will introduce the terms \"node\" and\n   \"branch\".  A node is a form of picture subroutine that may cause the\n   display of lines and characters and may also call other nodes.  The\n   subroutine call is called a \"branch\".  Nodes may also be thought of\n   as representing PICTURES or SUBPICTURES and the branches to these\n   nodes as uses or instances of these subpictures.\n\nDirected Graph Structure\n\n   The nodes and branches form a directed graph.  The branches contain\n   positioning information indicating the beam location to be used by\n   the called node.  This location is relative to the position of the\n   node in which the branch is made.  This use of relative beam\n   positions allows the user of the system to create subroutine\n   structures that make multiple branches to common nodes.  Branches may\n   also set other display parameters such as intensity and character\n   size.  A subroutine calling structure appropriate to the requirements\n   of our hypothetical designer is shown schematically in Figure 2.\n   Nodes are shown as circles and branches are shown as connecting\n   lines.  The picture of the house is composed of wall unit and roof\n   SUBPICTURES.  The wall unit is in turn composed of subpictures.\n\nNode and Branch Display Parameters\n\n   Branches may contain the setting of parameters which will be in\n   effect when the called node is executed.  The parameters which may be\n   set are the beam position to be used (relative to the current beam\n   position, i.e., a displacement value), intensity, character size,\n   line type, visibility, (the display of vectors and characters may be\n   suppressed), \"hitablility\" (whether or not vectors and text may be\n   \"viewed\" by devices such as the light pen), and blinking.\n\n   Coding within nodes may modify only the parameters controlling\n   position, intensity, character size, and line type to be used by\n   subsequent display coding or branches.  It is not necessary that a\n   node or branch specify every parameter.  For those parameters other\n   than position, the system allows a \"don't care\" option; the parameter\n   setting in effect when the node or branch is executed will be\n   retained and used in this case.\n\n\n\n\n\n\n\n\n\n\nWatson                                                          [Page 7]\n\f\nRFC 192          Some Factors which a Network Graphics      12 July 1971\n\n\nIdentification of Graphic Entities with Graphic Input Devices\n\n      Structural Hits\n\n         A console operator or application program may modify, add, or\n         delete branches to any of the nodes as well as add new nodes.\n         To allow a console operator to manipulate any branch in such a\n         structure, we have implemented a \"structural hit\n         identification\" scheme.  To illustrate the following\n         discussion, we refer the reader to Figures 1 and 2.\n\n         A viewing device, such as a light pen, can respond only to the\n         individual vectors or characters displayed on the screen.  At\n         the time a vector is drawn under the viewing area of the light\n         pen, an interrupt is generated and, if enabled, will be sent to\n         the central computer.  Even though the same node is used to\n         display the eight windows in the diagram of Figure 1, we can\n         tell which window and house is being pointed to by examining\n         the sequence of branches taken to arrive at the window\n         displayed at the time of interrupt.  If the console user points\n         to the right hand window of the middle house of Figure 1\n         (marked with an asterisk *) an examination of the subroutine\n         return addresses in the push down stack would show that the\n         current \"window\" node had been arrived at via the dotted line\n         path shown on the network of Figure 2.\n\n         There remains the question \"Are we pointing at a window, at a\n         wall, at the house, or at all three houses?\"  The location of\n         this structural hit depends on how many branches are counted in\n         examination of the return addresses before one stops to\n         consider to which branch that return jump points.  This is\n         analogous to counting a fixed number of levels from the ends of\n         the graph structure.  This number of jumps is set using\n         reserved keys on the keyboard, one incrementing and the other\n         decrementing the limit.  By manipulating these keys and\n         pointing to various displayed objects with the light pen, it is\n         possible to point to any branch in the network of subroutine\n         calls.\n\n         All information concerning the path in the node-branch network\n         taken to arrive at any displayable coding is contained in a\n         push down stack.  Return jumps are stored in the stack by the\n         subroutine calls to nodes.  These jumps when executed will\n         return the processor to the next instruction after the call.\n\n         A greatly simplified version of the display coding used to\n         generate the picture and tree of Figures 1 and 2 is shown in\n         Figure 3.  The labels a through d on the diagram represent the\n\n\n\nWatson                                                          [Page 8]\n\f\nRFC 192          Some Factors which a Network Graphics      12 July 1971\n\n\n         address of the subroutine calls which cause the display of the\n         subpicture hit by the viewing device -- in this case the right\n         hand window of the second house.  The returns from the called\n         subroutines are stored in the push down stack as jumps to the\n         location following the calls.  The routine RETURN would merely\n         execute POP instructions which ultimately will cause the\n         execution of a jump instruction previously placed in the stack\n         by the calling branch, thus returning control to the calling\n         routine.  The stack is shown in the condition at the time of\n         the hit on the right hand window of the middle house.  Note\n         that by counting 3 jumps upward (downward in the diagram) in\n         the memory containing the stack, we will arrive at the jump\n         pointing to a structural hit at (b) in Figure 3, the call to\n         model 120.\n\n      Console Operator Feedback\n\n         The console operator must be informed of where he is pointing\n         in the network of nodes and branches.  This is accomplished by\n         flashing all displayable coding below the structurally hit\n         branch when a vector or character is viewed.  This flashing is\n         a doubling of the intensity at 2 to 8 cycles per second.  In\n         addition, a list of the names of all nodes and branches taken\n         to arrive at the vector or character viewed is displayed in a\n         corner of the screen.  The name of the branch selected is\n         intensified somewhat brighter than the other names.\n\n      Generating an Attention\n\n         After the operator has confirmed the correctness of his choice,\n         he need only terminate the view in order to generate an\n         attention on the desired branch.  This is done by releasing the\n         button on the light pen or lifting the pen from the Tablet.  A\n         button on the mouse will perform the same function.  If the\n         structural hit is not correct then the operator could move the\n         viewing device to a new area.\n\n         A termination of the view on a blank area of the screen will\n         result in the generation of a \"null\" attention.  This attention\n         returns only position data; no structural data is generated.\n         The significance of this attention is determined by the\n         application program.\n\n         The above discussion assumed a refreshed display and use of a\n         light pen, but it greatly simplifies interactive graphics\n         programming if the above concepts can be implemented no matter\n         what type of display or graphical input device is being used.\n         This in fact can be accomplished as discussed later.\n\n\n\nWatson                                                          [Page 9]\n\f\nRFC 192          Some Factors which a Network Graphics      12 July 1971\n\n\nTHE GRAPHICS LANGUAGE\n\n   For the purpose of discussion we assume that the graphics language\n   statements are a set of subroutine calls, although a more\n   sophisticated syntax could be imbedded in the host programming\n   language.  The statements required are:\n\n      1) Subroutine calls for creation and manipulation of the picture-\n         subpicture data structure.\n\n      2) Subroutine calls to generate displayed pictures and picture\n         parts such as lines and characters.\n\n      3) Subroutine calls to input information about events or\n         \"attentions\" occurring in real time at the console.\n\n      4) Subroutine calls to manipulate picture parameters such as line\n         type, (solid, dashed, dotted, etc.), brightness, character\n         size, and so forth.\n\n      5) Subroutine calls to perform utility functions such as saving\n         and restoring pictures from disk files, initiating the display\n         and so forth.\n\nNAMING\n\n   A number of different naming conventions are required to meet system\n   and application programmer needs.\n\n      The Display Pointer\n\n         Nodes and branches in the system are named by assigning an\n         integer or array location as an argument in the call used to\n         create them.  The system places in these variables a number\n         which points to the physical location of the branch or node\n         position in the picture-subpicture data structure.  We call\n         this name the DISPLAY POINTER.  As long as the user does not\n         change the contents of these variables he can refer to\n         particular nodes or branches in various subroutines by use of\n         these integer variables as arguments.  In other words, to the\n         user, the name of a picture or subpicture can be thought of as\n         the variable used at the time of its creation.  Such a naming\n         scheme is clearly required if pictures or subpictures are to be\n         manipulated by the programmer.\n\n\n\n\n\n\n\nWatson                                                         [Page 10]\n\f\nRFC 192          Some Factors which a Network Graphics      12 July 1971\n\n\n      The Light Button Code\n\n         Additional identification is useful to the application\n         programmer in order to simplify his programming task.  A user\n         has no control over the number assigned by the system to a\n         Display Pointer.  There are situations in which the user would\n         like to associate a particular known number with a branch.  One\n         common example is in the use of \"light buttons\".  A light\n         button is a displayed object that the user wants to be able to\n         point at in order to command the controlling application\n         program to do something.  A light button is commonly a string\n         of characters forming an English word or words, but could be\n         any picture.  When the user picks or hits the light button,\n         information identifying the object must be transmitted to the\n         timesharing application program.  The program must then branch\n         to an appropriate statement or subroutine to perform the\n         operations required to execute the command.  The Display\n         Pointer uniquely identifies the object hit, but because its\n         value is not under the programmers control, writing the code\n         necessary to test it against the various Display Pointers\n         considered legitimate to be hit at this point in the program is\n         tedious.  If, however, the application programmer knew that at\n         this point only objects with identification numbers 20-28 were\n         legitimate to be hit, then testing to see that one was in this\n         range and branching by use of a computed GOTO simplifies the\n         programming of flow of control.  Often one does not need unique\n         identification of an object, but wants to perform a certain\n         action if any object in a class of objects is hit.\n\n         The above need for identification is satisfied by allowing the\n         application programmer the ability to assign a number, not\n         necessarily unique, to a branch.  This number is called the\n         Light Button Code.  This code can be used in any way the\n         programmer desires, but is most commonly used, as its name\n         implies, as a code identifying light buttons.  This number is\n         sent to the application program along with the Display pointer\n         of the object hit on the screen with a graphical input device.\n\n      The Back Pointer\n\n         We indicated earlier that it is required in interactive graphic\n         programming to be able to associate application oriented data\n         with picture and subpicture objects on the screen.  The data\n         may be stored in many kinds of data structures depending on the\n         nature of the application, examples being arrays, lists, trees,\n         etc.  We meet the need by associating with each branch one word\n         which could contain a pointer to the appropriate spot in the\n         application data structure containing the data associated with\n\n\n\nWatson                                                         [Page 11]\n\f\nRFC 192          Some Factors which a Network Graphics      12 July 1971\n\n\n         the branch.  We call this word the Back Pointer.  The\n         application programmer can in fact store any code he desires in\n         this word and use it in any way desired, but its common use as\n         a pointer back into a data base in the application program\n         dictated its name.\n\n         For example, consider an application which would allow a\n         chemical engineer to draw a chemical flow sheet on the screen\n         and then input this flow sheet into a process calculation\n         system.  There will be various symbol-pictures on the screen\n         representing basic process units such as heat exchangers,\n         mixers, columns, and so forth that can be copied and positioned\n         on the screen.  These units will have to be connected together\n         by streams.  The units and the streams will have names and data\n         associated with them describing their contents and properties.\n         Further, the node-branch structure. while visually indicating\n         to the user what units are connected together and how, does not\n         necessarily have the connecting information in a form easily\n         handled by the application program.\n\n         The continuity is best represented by a data structure using\n         simple list processing in which each unit and stream has a\n         block of cells associated with it containing data for it and\n         pointers containing the connectivity information.  When a\n         branch is created to position and display a unit, it will\n         contain in the Back Pointer a pointer to the block of data\n         associated with it.  The block of data will probably contain\n         the Display Pointer for the associated branch so that one can\n         go from the picture to the data block or from the data block to\n         the picture.  For example, one may point at a unit for the\n         purpose of deleting it.  Given the Back Pointer of the unit\n         hit, one can find its associated block and return that block to\n         free space.  One can then follow the appropriate chain of\n         pointers to the blocks for the streams connected to the unit.\n         In these blocks one has the Display Pointers for the branches\n         displaying the stream and can then delete it from the node-\n         branch structure, thus making it disappear from the screen.\n\n         An additional form of name is to allow the programmer to store\n         an alphanumeric string with each branch or node.  This form of\n         name is not required for most applications, but can be useful\n         with the picture editor.\n\n         To review, each node and branch has associated with it a unique\n         identifier named by the user and called the Display Pointer;\n         its value is assigned by the system.  Each branch has two\n         additional pieces of information which can be assigned to it by\n         the programmer, called the Light Button Code and Back Pointer.\n\n\n\nWatson                                                         [Page 12]\n\f\nRFC 192          Some Factors which a Network Graphics      12 July 1971\n\n\n         Given a Display Pointer for a branch, the programmer can obtain\n         the Light Button Code or the Back Pointer for the branch.\n         Given a Light Button Code or the Back Pointer, the programmer\n         can obtain a Display Pointer for a branch with such a code.\n         This display pointer may not be unique if several branches have\n         the same Light Button Code or Back Pointer.  The above naming\n         and identification inventions have proven to be easy to\n         understand and yet completely general and easy to use.\n\nCOORDINATE SYSTEMS\n\n   We now consider the question of a coordinate system within which to\n   describe picture position.  The actual display generation hardware in\n   a terminal has a fixed coordinate system (commonly 1024 by 1024 units\n   on a fixed size screen with the origin 0,0 in the left hand corner or\n   center on the screen).  Ultimately, the user wants to work on a\n   virtual screen much larger than the hardware screen and wants to\n   consider the hardware screen as a window that he can move around to\n   view this virtual screen.  Further, pictures are to be capable of\n   being constructed out of subpictures as in the example of Figures 1\n   and 2.  To be able to accomplish the latter and allow future\n   expansion to allow the former, the following coordinate system\n   conventions are used.\n\n   Each node has its own coordinate system.  When a node A is created,\n   the picture-drawing CRT beam is assumed by the programmer to be at\n   the origin of the node's coordinate system.  When a node is used\n   within a node B by use of a branch, the positioning of node A is\n   relative to the beam position in the coordinate system of node B.\n   All nodes are positioned relative to each other by x, y positioners\n   in the corresponding branches.  When a picture is actually to be\n   displayed, one node is indicated to the system as the initial or\n   Universe Node.  This initial node is positioned absolutely on the\n   screen and all other nodes appear relative to this one as specified\n   in the branches pointing to them.  This scheme is required to give\n   the flexibility and generality required in the picture-subpicture\n   tree.\n\n   Logical Completeness of Operation Set\n\n      Throughout the system design one should try to follow the\n      philosophy of incorporating a logically complete and consistent\n      set of operations.  In particular, for each call that sets a value\n      there should be another call to fetch the value.  That is, for\n      each operation there is an inverse operation whenever it is\n      meaningful to have one.  We see a need for a basic system with the\n      calls as primarily primitives.  One can incorporate calls that\n      could be created by the programmer from other calls, when it is\n\n\n\nWatson                                                         [Page 13]\n\f\nRFC 192          Some Factors which a Network Graphics      12 July 1971\n\n\n      felt that usage would warrant the expansion.  We would expect a\n      library of higher level routines in the language.\n\n      It is beyond the scope of these notes to go into all the calls\n      required except to indicate a few basic ones.  For structure\n      creation, one needs to be able to create a node or branch, delete\n      a branch, add a new branch to a node at run time.\n\n      One needs to be able to specify beam movements in nodes and place\n      text in nodes with the normal write-format statements of the host\n      programming language.  This latter point is very important for\n      easy programming.\n\n      One needs to be able to set and test parameters and convert one\n      form of name into others.\n\n      We discuss Attention handling in more detail because of its\n      importance in making interactive programming easy.\n\n   Attention Handling\n\n      The user sitting at the console is operating in real time while\n      the application program is operating in timesharing time.  At any\n      point where the user may perform some operation at the console,\n      the application program may not be running.  A mechanism must be\n      created to communicate between the user and the application\n      program.  The design of this mechanism is very important and must\n      be carefully considered.  There are many different operations that\n      one might want to provide the user at the console.  A basic\n      mechanism is discussed which will allow others to be added in the\n      future.  When the application program gets to a point where it is\n      expecting input from the terminal, it issues a call and passes an\n      array as an argument.  The Attention handling mechanism dismisses\n      the program until an event is reported from the console.  The\n      information passed back to the application is the type of event\n      which occurred and other relevant information for that event.\n\n      On refreshed displays a common input device is the light pen.  The\n      light pen has a physical field of view of about a 1/8-1/4 inch\n      circle.  The most common use of the light pen is to point at an\n      object to be hit or picked.  The logical field of view seen by the\n      user is a branch in the node-branch structure.  The picture drawn\n      by the structure below the branch is blinked to give feedback to\n      the user about what object he is going to hit or operate upon.\n      The level in the structure at which the logical view is given can\n      be set under program control or adjusted by the user from the\n      keyboard.  When the user obtains feedback indicating the correct\n      object is in view, he then presses a button on the light pen to\n\n\n\nWatson                                                         [Page 14]\n\f\nRFC 192          Some Factors which a Network Graphics      12 July 1971\n\n\n      generate an Attention.  He is said to obtain a \"structural bit\" at\n      a branch at the level in the node-branch structure set by the\n      application program or by himself.  When the hit occurs,\n      appropriate information is then entered into the Attention queue\n      as described below.\n\n      The other type of graphical input device commonly in use on both\n      refreshed and non-refreshed displays, such as electronic pen-\n      tablets, Joy Sticks, SRI Mouse, etc., produce x, y position\n      information which is fedback to the screen as some sort of cursor,\n      such as a dot or a cross.  It is difficult, if not impossible,\n      without special hardware to provide the kind of feedback possible\n      with the light pen, but structural hits can be generated by the\n      use of special hardware or software.  These devices require the\n      application programmer to set the appropriate level for an\n      expected hit.\n\n      The level of a structural hit is counted up from the bottom of the\n      node-branch structure.  A hit at level 1 is the lowest branch\n      presently in view.  A hit at level 0 is a hit on an individual\n      vector or group of characters.  Only special programs, such as a\n      picture editor, are likely to obtain hits at level 0.\n\n      The Attention type obtained when one gets a structural hit on a\n      branch returns the following information:  The information\n      returned in the array is that required by the application program,\n      the Display Pointer, the Light Button Code, and x, y, information.\n      The x, y, information returned is not the absolute x,y pen\n      position because this would not be of use on this type of hit.\n      The x, y information returned is the physical beam position just\n      before execution of the branch which was hit.  If one wants the\n      physical location of the node origin to which the hit branch is\n      connected, one executes another call to obtain the branch\n      positioner and adds these values to the corresponding values\n      obtained from the hit.  Given the Display Pointer, one can obtain\n      the Back Pointer or other parameter values associated with the\n      given branch call.\n\n      The attention type obtained when a hit is generated, but no object\n      is in view, is now discussed.  This type of attention is called a\n      null attention.  It is used frequently to position objects on the\n      screen.  The only information returned in the array is the\n      absolute screen coordinates of the position on the screen of the\n      graphic input device or cursor.  This information can be converted\n      into relative information for placement in a branch positioner or\n      for incrementing a branch position when an object is being moved.\n\n\n\n\n\nWatson                                                         [Page 15]\n\f\nRFC 192          Some Factors which a Network Graphics      12 July 1971\n\n\n      Other calls are required to obtain information about other\n      branches which are related to the one hit, and to perform other\n      functions.\n\nSTRUCTURAL HITS FOR STORAGE TUBE DISPLAYS\n\n   The final topic is to consider how to obtain structural hit\n   information using a storage tube display or device which only gives\n   absolute x, y screen information.\n\n   The problem is to take an x, y coordinate pair and determine if the\n   user is or is not pointing at an object on the screen, and if he is,\n   which object.  When a hit is generated with the light pen, the\n   display processor halts and the controlling computer can gain access\n   to the return addresses in the push down stack and to the instruction\n   location which generated the line or character causing the hit.  Use\n   of the Joy Stick, Mouse, or tablet is completely asynchronous with\n   the display for refresh displays and the hit occurs after the drawing\n   has taken place for storage tube systems.\n\n   The brute force approach to the problem would be to simulate\n   execution of the Display Buffer and calculate some measure of\n   distance between every line and the x, y coordinate of the hit.  This\n   approach would be too time consuming and is not feasible.  A second\n   approach and one commonly used is to have the programmer define a\n   rectangle surrounding each object on the screen.  Then one determines\n   which rectangle the cursor was in and that determines the object hit.\n   This approach requires extra effort by the programmer, and only works\n   well if the node-branch structure is one level deep, there are no\n   diagonal lines as nodes, and no objects have overlapping rectangles.\n   These severe restrictions eliminates this approach from serious\n   consideration.\n\n   A third approach would be to break the screen into small squares or\n   rectangles of a size such that it is unlikely a line from more than\n   one picture object would pass through the square or rectangle.  Then\n   we would record for each square the Display Pointer of the lowest\n   level object branch passing through it.  This approach would require\n   considerable system space and would take much time to determine what\n   rectangles each line passed through.\n\n   The fourth approach and the one we recommend is to split the screen\n   into horizontal and vertical strips.  When the call to DISPLAY is\n   given, the system makes one pass through the node-branch structure\n   and makes a list of the Display Pointers for the lowest branch having\n   a node with a line or character passing through or in each horizontal\n   or vertical strip.\n\n\n\n\nWatson                                                         [Page 16]\n\f\nRFC 192          Some Factors which a Network Graphics      12 July 1971\n\n\n   This calculation can be made quickly because the system can easily\n   obtain the start and end points of a line.  One then can quickly\n   determine which strips the end points fall in, as well as the\n   intermediate strips crossed.  When a hit is generated, the x, y\n   information is converted to horizontal and vertical strip numbers.\n   The Display Pointers for each of these strips are intersected to see\n   if a common Display Pointer exists.  If yes, this is the Display\n   Pointer for the object hit.  If not, then a null hit is generated.\n   Choice of strip width decreases the probability of multiple hits\n   resulting.\n\n   The above process yields the Display Pointer of the lowest branch in\n   the tree in view, but one may want to obtain information about other\n   higher branches in view.  This is accomplished by creating, not only\n   the strip lists described, but by parsing the node-branch structure\n   at the same time into a table containing an abbreviated\n   representation of the tree and the screen x, y coordinates existing\n   at each branch.  The strip lists do not actually contain Display\n   Pointers, but pointers back into the parsed representations which has\n   the Display Pointer, x, y coordinates, and the structure level for\n   each of the branches.  The parsed representation is a linear list of\n   the branches encountered as the program walks through the node-branch\n   graph.  Given the hit at the lowest level one can determine all\n   branches passed through from the top node to the hit branch by an\n   upward search of the graph representation.\n\n   Every time a branch is deleted or a new branch is added, one needs to\n   modify the screen, modify the representations and the strip lists.\n   For refresh displays, the picture can be changed immediately and the\n   strip lists and representations modified at the time of an attention\n   call.  For a storage display, erasing and redrawing the picture on\n   each deletion can be slow, if many deletions are going on, and may be\n   unnecessary.\n\n   There are three approaches to performing these functions in storage\n   tube systems:\n\n      1) Erase the screen on each deletion and recompute the picture,\n         strip lists and graph representations on each deletion and\n         addition.\n\n      2) Keep a list of each Display Buffer change and perform erase if\n         necessary and redraw or make an addition when an attention call\n         is encountered.  This is a feasible approach because it is only\n         at this point that the screen and structural hit information\n         need to be up to date.\n\n\n\n\n\nWatson                                                         [Page 17]\n\f\nRFC 192          Some Factors which a Network Graphics      12 July 1971\n\n\n      3) The third is to allow control of screen changes and other\n         updating by special subroutine call.  The recommended approach\n         uses a combination of the above.  Adding information to the\n         screen should occur at the time of the new branch call.\n         Deletions and modifications of the representation and the strip\n         lists occur only at the time of an attention call.  Routines\n         should also be provided to give the programmer control over\n         this redraw mechanism.\n\n         Experience with the above mechanism has shown it to be quite\n         fast and not to noticeably degrade response time.  One minor\n         difficulty has been encountered when a horizontal or vertical\n         line of an object is on the borderline of a strip.  Sometimes\n         this results in a null hit being generated if the cursor is on\n         the wrong side of the borderline.  A check can be made for this\n         condition and audio feedback can be given to the user with the\n         bell in the terminal to indicate a correct or erroneous hit.\n\nINTERFACE TO THE TIMESHARING SYSTEM OF A REMOTE MINICOMPUTER DRIVEN\nDISPLAY\n\n   Although the graphic system is locally controlled by a minicomputer,\n   the user does not have to worry about the mini.  Application programs\n   are written for the timesharing computer only.  The graphic system as\n   a whole behaves as a terminal of the timesharing computer.  This\n   feature is important because no matter how powerful the graphic\n   system is, it must be easy to program and use before useful\n   applications can be implemented.\n\n   Because no one wants to operate over a communication line, one needs\n   to compress the information sent to the remote system.  This is\n   accomplished by compiling a central node-branch structure in the\n   central computer and only sending minimal character strings to the\n   remote computer representing those subroutines calls that need to be\n   compiled into a Display Buffer in the remote computer for display\n   refresh.  In other words, a smaller remote version of the graphics\n   system resides in the remote minicomputer.  Simple schemes for\n   coordinating the Display Pointer in the remote and central machine\n   have to be devised.\n\nCONCLUSION\n\n   We feel that the above concepts are central to creating an\n   interactive graphics support system for use with a timesharing\n   system.  The key concepts are those associated with the node-branch\n   structure and the structured hit.  The topics of a picture editor,\n   data management system, and basic level support are also very\n   important, but beyond the scope of this lecture.\n\n\n\nWatson                                                         [Page 18]\n\f\nRFC 192          Some Factors which a Network Graphics      12 July 1971\n\n\n   Figures 1, 2. and 3, are available in both .PS and .PDF versions.\n\n\n          [This RFC was put into machine readable form for entry]\n          [into the online RFC archives by Lorrie Shiota, 10/01]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWatson                                                         [Page 19]\n\f\n"
}